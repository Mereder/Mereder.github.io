<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Mereder</title>
  
  <subtitle>珍惜现在，感谢所有，不悔将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-04T10:17:57.970Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meng Di</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-377-组合总和IV</title>
    <link href="http://yoursite.com/2020/01/04/leetcode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV/"/>
    <id>http://yoursite.com/2020/01/04/leetcode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV/</id>
    <published>2020-01-04T09:56:11.000Z</published>
    <updated>2020-01-04T10:17:57.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h2><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p>示例:</p><p>nums = [1, 2, 3]<br>target = 4</p><p>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)</p><p>请注意，顺序不同的序列被视作不同的组合。</p><p>因此输出为 7。<br>进阶：<br>如果给定的数组中含有负数会怎么样？<br>问题会产生什么变化？<br>我们需要在题目中添加什么限制来允许负数的出现？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>连续刷了一个回溯+剪枝的题目，这个拿过来就写了出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> target &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.helper(nums,target)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            cnt += self.helper(nums,target-nums[index])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p><strong>通不过呀 超时了</strong></p><p>原因很简单，如果画出递归树，很明显的能看到有许多重复计算的地方。那么如何避免重复计算呢？</p><p><strong>使用动态规划呗</strong></p><p>动态规划里有一个很重要的模块就是 <strong>备忘录</strong>，意思就是如果再次涉及到这个计算的时候，我不用再重复计算算，直接查找备忘录就可以得到对应的值，一般返回结果也是直接从备忘录里面找。</p><p>涉及两个问题，动态规划的状态是什么？状态转移方程是什么？</p><ul><li><p>状态是什么</p><p>我们要求target为和的可能个数，那么我们可以用一个备忘录来存储所有比target小的数的可能个数</p><p>即mem[i] 表示和为i时候的个数</p></li><li><p>状态转移方程是什么</p><p>状态转移方程也可以了解为递推的过程，就是如何从小到大，将整个备忘录填写完成。我们的备忘录填写过程还是要根据所给的数组来完成的。比如<code>nums=[1,3]</code> 那么产生<code>target=4</code>如何产生呢？</p><blockquote><p>mem[0] = 1</p><p>mem[1] = mem[1-nums[0]] = mem[0] = 1</p><p>mem[2] = mem[2-nums[0]] = mem[1] = 1</p><p>mem[3] = mem[3-nums[0]] + mem[3-nums[1]] = mem[2] + mem[0] = 2</p><p>mem[4] = mem[4-nums[0]] + mem[4-nums[1]] = mem[3] + mem[1] = 2+1 = 3 </p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> target &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        mem = [<span class="number">0</span>]*(target+<span class="number">1</span>)</span><br><span class="line">        mem[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= nums[j]:</span><br><span class="line">                    mem[i] += mem[i-nums[j]]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mem[target]</span><br></pre></td></tr></table></figure><h3 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h3><p>如果给定的数组中含有负数会怎么样？问题会产生什么变化？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组合总和IV&quot;&gt;&lt;a href=&quot;#组合总和IV&quot; class=&quot;headerlink&quot; title=&quot;组合总和IV&quot;&gt;&lt;/a&gt;组合总和IV&lt;/h2&gt;&lt;p&gt;给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-216-组合总和III</title>
    <link href="http://yoursite.com/2020/01/03/leetcode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/"/>
    <id>http://yoursite.com/2020/01/03/leetcode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/</id>
    <published>2020-01-03T14:17:07.000Z</published>
    <updated>2020-01-03T15:55:45.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><p>所有数字都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p><p>输入: k = 3, n = 7<br>输出: [[1,2,4]]<br>示例 2:</p><p>输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯+剪枝，轻车熟路</p><p>清楚每一次递归的元素是什么，基本都是有几个必要的元素</p><blockquote><p>结果集、栈、递归控制元素</p></blockquote><p>对应本体 结果集就是result</p><p>栈就是用来存储结果的stack</p><p>控制元素本体就是n,k</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        base = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">        <span class="comment"># 剪枝两次， n==0 k ==0</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        self.helper(base, n, k, result, stack, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, base, n, k,result,stack,start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">and</span> k ==<span class="number">0</span>:</span><br><span class="line">            result.append(stack.copy())</span><br><span class="line"><span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(start,<span class="number">9</span>):</span><br><span class="line">            stack.append(base[index])</span><br><span class="line"></span><br><span class="line">            self.helper(base,n-base[index],k<span class="number">-1</span>,result,stack,index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            stack.pop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组合总和III&quot;&gt;&lt;a href=&quot;#组合总和III&quot; class=&quot;headerlink&quot; title=&quot;组合总和III&quot;&gt;&lt;/a&gt;组合总和III&lt;/h2&gt;&lt;p&gt;找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-39-组合总和</title>
    <link href="http://yoursite.com/2020/01/03/leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>http://yoursite.com/2020/01/03/leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</id>
    <published>2020-01-03T14:16:08.000Z</published>
    <updated>2020-01-03T14:16:16.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p><p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]<br>示例 2:</p><p>输入: candidates = [2,3,5], target = 8,<br>所求解集为:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可能确实刷题刷出来感觉了，拿到题第一时间就想到了用 回溯来做，具体细节当然要使用一些剪枝。</p><p>既然使用回溯来做，最好要画图分析下（递归的过程都可以画成树）</p><p>（假装这里有个图）</p><p>搞清楚</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        self.helper(candidates, target, result, stack, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, candidates, target, result, stack, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:  <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:  <span class="comment"># 找到一个结果集</span></span><br><span class="line">            result.append(stack.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">            stack.append(candidates[index])</span><br><span class="line"><span class="comment"># 由于允许有重复 所以下一个位置还是从index 开始</span></span><br><span class="line">            self.helper(candidates, target-candidates[index], result, stack, index)</span><br><span class="line"></span><br><span class="line">            stack.pop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组合总和&quot;&gt;&lt;a href=&quot;#组合总和&quot; class=&quot;headerlink&quot; title=&quot;组合总和&quot;&gt;&lt;/a&gt;组合总和&lt;/h2&gt;&lt;p&gt;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-1138-字母板上的路径</title>
    <link href="http://yoursite.com/2020/01/02/leetcode-1138-%E5%AD%97%E6%AF%8D%E6%9D%BF%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/01/02/leetcode-1138-%E5%AD%97%E6%AF%8D%E6%9D%BF%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2020-01-02T15:53:34.000Z</published>
    <updated>2020-01-04T09:55:46.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字母板上的路径"><a href="#字母板上的路径" class="headerlink" title="字母板上的路径"></a>字母板上的路径</h2><p>我们从一块字母板上的位置 (0, 0) 出发，该坐标对应的字符为 board[0][0]。</p><p>在本题里，字母板为board = [“abcde”, “fghij”, “klmno”, “pqrst”, “uvwxy”, “z”].</p><p>我们可以按下面的指令规则行动：</p><p>如果方格存在，’U’ 意味着将我们的位置上移一行；<br>如果方格存在，’D’ 意味着将我们的位置下移一行；<br>如果方格存在，’L’ 意味着将我们的位置左移一列；<br>如果方格存在，’R’ 意味着将我们的位置右移一列；<br>‘!’ 会把在我们当前位置 (r, c) 的字符 board[r][c] 添加到答案中。<br>返回指令序列，用最小的行动次数让答案和目标 target 相同。你可以返回任何达成目标的路径。</p><blockquote><p>示例 1：</p><p>输入：target = “leet”<br>输出：”DDR!UURRR!!DDD!”<br>示例 2：</p><p>输入：target = “code”<br>输出：”RR!DDRR!UUL!R!”</p><p>提示：</p><p>1 &lt;= target.length &lt;= 100<br>target 仅含有小写英文字母。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"abcde"</span>, </span><br><span class="line"> <span class="string">"fghij"</span>, </span><br><span class="line"> <span class="string">"klmno"</span>, </span><br><span class="line"> <span class="string">"pqrst"</span>, </span><br><span class="line"> <span class="string">"uvwxy"</span>, </span><br><span class="line"> <span class="string">"z"</span>].</span><br></pre></td></tr></table></figure><p>注意遍历的顺序：先 左和上  再右和下</p><p>原因是：最后一个z的位置 比较特殊，如果想到z位置，只能从z的上面才能到，z的右侧，z的下面都不可以到达z位置，只能上面到，所以要先进行   向左或者向上  的操作。（因为如果先进行向右或者向下 势必会遍历到非法区域）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alphabetBoardPath</span><span class="params">(self, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> target:</span><br><span class="line">            error = ord(char) - ord(<span class="string">'a'</span>)</span><br><span class="line">            row = error // <span class="number">5</span></span><br><span class="line">            col = error % <span class="number">5</span></span><br><span class="line">            左侧</span><br><span class="line">            <span class="keyword">if</span> col &lt; j:</span><br><span class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> range(j-col):</span><br><span class="line">                    result += <span class="string">'L'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> row &lt; i:</span><br><span class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> range(i-row):</span><br><span class="line">                    result += <span class="string">'U'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> row &gt; i:</span><br><span class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> range(row-i):</span><br><span class="line">                    result += <span class="string">'D'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> col &gt; j:</span><br><span class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> range(col-j):</span><br><span class="line">                    result += <span class="string">'R'</span></span><br><span class="line"></span><br><span class="line">            result += <span class="string">'!'</span></span><br><span class="line">            i = row</span><br><span class="line">            j = col</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p> <strong>注意这里存在的问题</strong>：</p><p>严格意义上讲，这个题并没有通过所有的测试case</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字母板上的路径&quot;&gt;&lt;a href=&quot;#字母板上的路径&quot; class=&quot;headerlink&quot; title=&quot;字母板上的路径&quot;&gt;&lt;/a&gt;字母板上的路径&lt;/h2&gt;&lt;p&gt;我们从一块字母板上的位置 (0, 0) 出发，该坐标对应的字符为 board[0][0]。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-31-下一个排列</title>
    <link href="http://yoursite.com/2019/12/31/leetcode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2019/12/31/leetcode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2019-12-31T02:25:36.000Z</published>
    <updated>2020-01-01T15:44:19.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找下一个排列，就是用程序模拟下我们人是怎么找下一个排列的</p><blockquote><p>举个例子  1，3，5，4，2</p><p>下一个排列，我们会先定位到3这个地方，因为后一个的值比3大（最大的数就是倒序排，最小的就是正序排，那么下一个排列肯定是较大的一个数）。因为只是找下一个排列，我们找到比3大的数中最小的即4，</p><p>交换3和4得到1，4，5，3，2</p><p>只找到下一个排列，所以应将4后边的进行翻转得，1，4，2，3，5即为结果</p></blockquote><p>主要就是三步：</p><ul><li>找到需要交换的位置，即存在<code>nums[i]&lt;nums[i+1]</code>,这个过程需要从后向前遍历</li><li>再找到需要交换的元素，即被交换元素是较大数中最小的，然后交换</li><li>将位置后边的翻转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i = n<span class="number">-2</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] &lt;= nums[i]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>: <span class="comment"># 比较巧妙的是：上面如果已经是最大那么i会为-1 会直接翻转整个list</span></span><br><span class="line">            j = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= i <span class="keyword">and</span> nums[j] &lt;= nums[i]:</span><br><span class="line">                j -= <span class="number">1</span> </span><br><span class="line">            nums[i],nums[j] = nums[j],nums[i]</span><br><span class="line">        </span><br><span class="line">        self.reverse(nums,i)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, index)</span>:</span></span><br><span class="line">        left = index+<span class="number">1</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left],nums[right] = nums[right],nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下一个排列&quot;&gt;&lt;a href=&quot;#下一个排列&quot; class=&quot;headerlink&quot; title=&quot;下一个排列&quot;&gt;&lt;/a&gt;下一个排列&lt;/h2&gt;&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;p&gt;如果不存在下一个
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>training loss nan问题</title>
    <link href="http://yoursite.com/2019/12/30/Training%20loss%20nan/"/>
    <id>http://yoursite.com/2019/12/30/Training%20loss%20nan/</id>
    <published>2019-12-30T09:43:23.000Z</published>
    <updated>2019-12-30T09:45:49.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Training-loss-nan"><a href="#Training-loss-nan" class="headerlink" title="Training loss nan"></a>Training loss nan</h2><p>训练模型时候发现 training loss nan 了，简单查了下，会有很多情况导致。</p><p>我的问题就是数据有脏数据 nan的 inf的 等等…</p><p>总结的话就是发现nan之后 先check下数据！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Training-loss-nan&quot;&gt;&lt;a href=&quot;#Training-loss-nan&quot; class=&quot;headerlink&quot; title=&quot;Training loss nan&quot;&gt;&lt;/a&gt;Training loss nan&lt;/h2&gt;&lt;p&gt;训练模型时候发现 t
      
    
    </summary>
    
    
      <category term="daily" scheme="http://yoursite.com/categories/daily/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-47-全排列II</title>
    <link href="http://yoursite.com/2019/12/29/leetcode-47-%E5%85%A8%E6%8E%92%E5%88%97II/"/>
    <id>http://yoursite.com/2019/12/29/leetcode-47-%E5%85%A8%E6%8E%92%E5%88%97II/</id>
    <published>2019-12-29T14:25:00.000Z</published>
    <updated>2019-12-29T15:29:13.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>加入限制：<strong>含重复元素</strong></p><p>含重复元素带来的问题就是，会导致出现重复的排列。我们需要做的就是<strong>剪枝</strong></p><p>具体的剪枝操作如何进行呢？</p><p>回到重复元素问题，如果是数组含有重复元素，我们最好的办法是通过hash去重，或者通过预排序，预排序将重复元素都放在一起，也比较好操作。这里我们的结果都是list，list是不能进行hash的，所以使用预排序的方法。这里跟<strong>3sum</strong>的题有异曲同工之妙，通过预排序让问题更加好解决。</p><p>预排序之后呢？</p><p>预排序之后，重复元素好处理了，那么我们进行剪枝时候，可以利用排序数组的性质，将存在的重复情况跳过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>]==nums[i]:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>这里因为是回溯+剪枝，还需要考虑下状态问题，沿用<a href="">Leetcode-46-全排列</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] ==nums[i] <span class="keyword">and</span> <span class="keyword">not</span> used[i<span class="number">-1</span>]:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>当前位置如果是重复元素，并且之前的元素已经是False了，即说明已经遍历过了，那么当前元素(i)可以continue。</p><p>为什么之前相同元素状态是False就表示已经遍历过呢？因为for i 的循环是表示在同一层，前面的元素先于后边的元素进行遍历，如果前面的元素是False，肯定使用经过遍历再回溯修改状态为False，那么同一层的相同元素就没有必要再遍历了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        used = [<span class="literal">False</span>]*len(nums)</span><br><span class="line"></span><br><span class="line">        self.helper(<span class="number">0</span>, nums, stack, used, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, depth, nums, stack, used, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> depth == len(nums):</span><br><span class="line">            result.append(stack.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                <span class="comment"># 1.i &gt;0 i-1才不会越界</span></span><br><span class="line">                <span class="comment"># nums[i-1] == nums[i] 重复元素 且 nums[i-1]没有被遍历 则 证明会有重复排列</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>] <span class="keyword">and</span> used[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                stack.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                self.helper(depth+<span class="number">1</span>, nums, stack, used, result)</span><br><span class="line"></span><br><span class="line">                stack.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全排列II&quot;&gt;&lt;a href=&quot;#全排列II&quot; class=&quot;headerlink&quot; title=&quot;全排列II&quot;&gt;&lt;/a&gt;全排列II&lt;/h2&gt;&lt;p&gt;给定一个可包含重复数字的序列，返回所有不重复的全排列。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: [1,1,2]&lt;
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-60-第K个排列</title>
    <link href="http://yoursite.com/2019/12/29/leetcode-60-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2019/12/29/leetcode-60-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2019-12-29T07:53:07.000Z</published>
    <updated>2019-12-29T08:26:08.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第K个排列"><a href="#第K个排列" class="headerlink" title="第K个排列"></a>第K个排列</h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p><p>说明：</p><p>给定 n 的范围是 [1, 9]。<br>给定 k 的范围是[1,  n!]。<br>示例 1:</p><p>输入: n = 3, k = 3<br>输出: “213”<br>示例 2:</p><p>输入: n = 4, k = 9<br>输出: “2314”</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>延续全排列的办法，将全部排列都求出之后，找到第K个排列即可，当然，这道题这么做直接<strong>超时</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        result = []</span><br><span class="line">        stack = <span class="string">''</span></span><br><span class="line">        used = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        self.helper(<span class="number">0</span>,nums,stack,used,result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(result[k<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, length, nums, stack,used, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> length == len(nums):</span><br><span class="line">            result.append(stack)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                stack += str(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                self.helper(length+<span class="number">1</span>,nums,stack,used,result)</span><br><span class="line"></span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">                stack = stack[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gadnuwrckbj30m807s3yx.jpg" alt="image-20191229161342833"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>回溯+剪枝</strong>，当严格意义上来讲，并没有回溯的过程，更多的体现在<strong>剪枝</strong>上</p><p>回溯：我们需要修改状态，然后操作，之后进行回溯，再修改状态。对应排列问题就是进入时候<code>used[i]=Ture</code>,回溯<code>used[i]=False。</code></p><p>剪枝：对不满足条件的状况不再进行dfs搜索解，直接跳过。</p><p>本题的剪枝条件是<strong>个数限制</strong>。因为就是数字的全排列，那么以任一一个数字开头的可能情况都是可以计算的。以<code>n=3</code>为例。</p><blockquote><p>n = 3,可能解为[‘123’,’132’,’213’,’231’,’312’,’321’]  即 3! 等于 6</p><p>当第一位确认为‘1’时，后面只能选’2’,’3’  则 2！=2</p><p>如果我们的输入为n=3,k=3</p><p>由于第一位为’1’时候，可能解为2！=2 &lt; k=3 则不必再对’1’为第一位的情况展开搜索 直接跳过</p><p>此时注意跳过后k = k-2 =1。</p><p>接下来第一位为’2’时候，可能解为2!=2 &gt; k=1，则第k个解就在这个里面，我们只需要对该情况进行搜索即可</p></blockquote><p>上面举的例子只是考虑了第一位的情况（对应递归树就是第一层），之后的每一层都是一样的，也都是进行剪枝判断就可以了。时间并没有回溯的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_factorial</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res *= n</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        used = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        stack = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">0</span>,n,k,stack,used)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,depth, n, k, stack,used)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> depth == n:</span><br><span class="line">            <span class="keyword">return</span> stack</span><br><span class="line"></span><br><span class="line">        before = self.get_factorial(n-depth<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">          <span class="comment"># 第一次剪枝：去过的不能再去</span></span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 第二次剪枝：解的个数&lt;k</span></span><br><span class="line">            <span class="keyword">if</span> before &lt; k:</span><br><span class="line">                k -= before</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">### 并没有回溯过程</span></span><br><span class="line">            stack += str(i)</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> self.helper(depth+<span class="number">1</span>, n, k, stack, used)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第K个排列&quot;&gt;&lt;a href=&quot;#第K个排列&quot; class=&quot;headerlink&quot; title=&quot;第K个排列&quot;&gt;&lt;/a&gt;第K个排列&lt;/h2&gt;&lt;p&gt;给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。&lt;/p&gt;
&lt;p&gt;按大小顺序列出所有排列情况，并一一标
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>git日常使用</title>
    <link href="http://yoursite.com/2019/12/27/git%E6%97%A5%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/12/27/git%E6%97%A5%E5%B8%B8/</id>
    <published>2019-12-27T06:29:47.000Z</published>
    <updated>2019-12-27T06:30:23.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-日常使用"><a href="#git-日常使用" class="headerlink" title="git 日常使用"></a>git 日常使用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git-日常使用&quot;&gt;&lt;a href=&quot;#git-日常使用&quot; class=&quot;headerlink&quot; title=&quot;git 日常使用&quot;&gt;&lt;/a&gt;git 日常使用&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="daily" scheme="http://yoursite.com/categories/daily/"/>
    
    
  </entry>
  
  <entry>
    <title>BeautifulSoup 4 部分使用笔记</title>
    <link href="http://yoursite.com/2019/12/27/BeautifulSoup4/"/>
    <id>http://yoursite.com/2019/12/27/BeautifulSoup4/</id>
    <published>2019-12-26T16:22:48.000Z</published>
    <updated>2019-12-26T16:23:14.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BeautifulSoup-4-使用理解"><a href="#BeautifulSoup-4-使用理解" class="headerlink" title="BeautifulSoup 4  使用理解"></a>BeautifulSoup 4  使用理解</h1><p><strong>核心</strong>：Beautiful Soup将复杂HTML文档转换成一个复杂的<strong>树形结构</strong>,每个节点都是Python对象,所有对象可以归纳为4种: <code>Tag</code> , <code>NavigableString</code> , <code>BeautifulSoup</code> , <code>Comment</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全篇都是以这个例子进行展开</span></span><br><span class="line">html_doc = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html_doc)</span><br></pre></td></tr></table></figure><h2 id="基础节点类型"><a href="#基础节点类型" class="headerlink" title="基础节点类型"></a>基础节点类型</h2><ul><li><p>Tag：Tag节点也是最基本的节点类型。两个重要属性 name  attributes（类似字典包含id,class 等等）</p></li><li><p>NavigableString：包含在Tag中的字符串</p><p>tag中的字符串不能编辑，但是可以被替换成其他的字符串，用replace_with()</p></li><li><p>BeautifulSoup：</p><p>支持搜索文档树 和 遍历文档树的大部分方法</p></li><li><p><code>Comment</code> 对象是一个特殊类型的 <code>NavigableString</code> 对象，大部分使用用来表示注释部分</p></li></ul><p>Tag，NavigableString和BeautifulSoup基本上就可以表示html和XML中的所有内容了</p><h2 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h2><p>理解BeautifulSoup 将HTML文档解析成为DOM文档树，这个树的每个标签代表一个节点。一个Tag可能包含多个String或其他Tag，这些都是这个Tag的子节点，BeautifulSoup提供了许多操作和遍历子节点的属性</p><h3 id="contents-和-children"><a href="#contents-和-children" class="headerlink" title=".contents 和 .children"></a>.contents 和 .children</h3><p>遍历文档树的两个重要属性<code>.contents</code>和<code>.children</code></p><p>.contents 会将当前节点（TAG）的子节点以<strong>列表</strong>的形式输出</p><p><strong>一个节点其子节点可能有其他TAG 也可能有字符串String，string 是不可迭代的</strong></p><p>.children 产生<strong>生成器</strong>，可以对tag的子节点进行循环</p><h3 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h3><p><code>.descendants</code> 属性可以对所有tag的子孙节点进行<strong>递归循环</strong>遍历（<code>先序</code>遍历形式）：</p><h3 id="strings-和-stripped-strings"><a href="#strings-和-stripped-strings" class="headerlink" title=".strings 和 stripped_strings"></a>.strings 和 stripped_strings</h3><p>如果tag中包含多个字符串 ,可以使用 <code>.strings</code> 来循环获取:</p><blockquote><p>print(‘ ‘.join([string.strip() for string in soup.body.find_all(‘p’)[1].strings]))</p><p>soup 是BeautifulSoup对象，通过.body进入 body 标签下，进行find_all(‘p’)查找全部P标签</p><p>拿到[1]的p标签，然后进行strings，产生generator 通过join方式将 生成器的内容进行结合</p><p> 输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Once upon a time there were three little sisters; <span class="keyword">and</span> their names were Elsie , Lacie <span class="keyword">and</span> Tillie ;</span><br><span class="line"><span class="keyword">and</span> they lived at the bottom of a well.</span><br></pre></td></tr></table></figure></blockquote><p> <code>.stripped_strings</code> 可以去除多余空白内容(空格，空行)</p><h3 id="父节点-parent-和-parents"><a href="#父节点-parent-和-parents" class="headerlink" title="父节点.parent 和 .parents"></a>父节点.parent 和 .parents</h3><p>.parent 获取某个元素的父节点。</p><p>.parents 属性可以用递归得到元素的所有父辈节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">link = soup.a</span><br><span class="line">link</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> link.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(parent.name)</span><br><span class="line"><span class="comment"># p</span></span><br><span class="line"><span class="comment"># body</span></span><br><span class="line"><span class="comment"># html</span></span><br><span class="line"><span class="comment"># [document]</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure><h3 id="兄弟节点-next-sibling-和-previous-sibling"><a href="#兄弟节点-next-sibling-和-previous-sibling" class="headerlink" title="兄弟节点.next_sibling 和 .previous_sibling"></a>兄弟节点.next_sibling 和 .previous_sibling</h3><p>同一层的标签，是兄弟节点，他们来自同一个 父节点</p><p>在文档树中,使用 <code>.next_sibling</code> 和 <code>.previous_sibling</code> 属性来查询兄弟节点</p><p>通过 <code>.next_siblings</code> 和 <code>.previous_siblings</code> 属性可以对当前节点的兄弟节点迭代输出</p><p>BeautifulSoup解决的思路就是：</p><p>先搜索String 找到可能 关键句，然后从关键句的地方进行判断进行删除</p><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><p>心得：一般爬虫使用这个来爬取数据，正常都是用到的Bs4的搜索技巧，最近实习工作中，使用这个来对新闻进行修改（冗余优化），还需要使用<strong>修改</strong>技巧，修改嘛，无非就是（增删改）</p><p>对于增，用的比较少。（冗余优化 主要是删改）</p><p>对于删除，首先要定位到目标位置，需要观察一批数据的情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>beautifulsoup  官网中文</p><p><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id18" target="_blank" rel="noopener">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id18</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BeautifulSoup-4-使用理解&quot;&gt;&lt;a href=&quot;#BeautifulSoup-4-使用理解&quot; class=&quot;headerlink&quot; title=&quot;BeautifulSoup 4  使用理解&quot;&gt;&lt;/a&gt;BeautifulSoup 4  使用理解&lt;/h1
      
    
    </summary>
    
    
      <category term="daily" scheme="http://yoursite.com/categories/daily/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-35-搜索插入位置（一点都不easy）</title>
    <link href="http://yoursite.com/2019/12/26/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/12/26/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</id>
    <published>2019-12-26T15:14:18.000Z</published>
    <updated>2019-12-26T15:40:53.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><blockquote><p>示例 1:</p><p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p><p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p><p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p><p>输入: [1,3,5,6], 0<br>输出: 0</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>妈了个鸡，一点都不简单，二分这个坑。。。</p><p>原本的二分检索，如果检索不到target的话，跳出循环时候，会有left &gt;  right即left=right+1</p><p>这个时候对应两种情况:</p><ul><li>一种是由于<code>nums[mid]&lt;target</code>导致left=mid+1跳出，此时left-1&lt;target&lt;left</li><li>一种是由于 <code>nums[mid]&gt;target</code>导致right=mid-1跳出，此时 right&lt;target&lt;right+1 而left=right+1,即也是left-1&lt;target&lt;left</li></ul><p>即不论什么情况，只要没有检索到目标值，那么target一定介于<code>left-1</code>和<code>left</code>之间，对应插入位置就是left</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;搜索插入位置&quot;&gt;&lt;a href=&quot;#搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;搜索插入位置&quot;&gt;&lt;/a&gt;搜索插入位置&lt;/h2&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
      <category term="easy" scheme="http://yoursite.com/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-313-超级丑数</title>
    <link href="http://yoursite.com/2019/12/25/leetcode-313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/"/>
    <id>http://yoursite.com/2019/12/25/leetcode-313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</id>
    <published>2019-12-24T16:11:30.000Z</published>
    <updated>2019-12-25T14:56:57.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="超级丑数"><a href="#超级丑数" class="headerlink" title="超级丑数"></a>超级丑数</h2><p>编写一段程序来查找第 n 个超级丑数。</p><p>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</p><p>示例:</p><p>输入: n = 12, primes = [2,7,13,19]<br>输出: 32<br>解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br>说明:</p><blockquote><p>1 是任何给定 primes 的超级丑数。</p><p>给定 primes 中的数字以升序排列。<br>0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。<br>第 n 个超级丑数确保在 32 位有符整数范围内。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>原本丑数就是质因数只有2，3，5的数字，这个题目扩展为丑数为一个list的质因数</p><p>思路都是一样的，只不过需要维护一个list的指针，以及一个丑数序列</p><p><code>p_list</code>是对应<code>primes</code>数组每个元素对应的指针数组，<code>p_list</code>中元素表示<code>primes</code>中质因数的指针</p><p><code>ugly</code>来记录超级丑数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span><span class="params">(self, n, primes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type primes: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> primes:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = len(primes)</span><br><span class="line">        p_list = [<span class="number">0</span>]*length</span><br><span class="line">        ugly = [<span class="number">0</span>]*n</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            min_value = <span class="number">2</span>**<span class="number">32</span></span><br><span class="line">            <span class="comment"># 找下一个丑数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length): <span class="comment"># 升序排列的</span></span><br><span class="line">                <span class="keyword">if</span> primes[j]*ugly[p_list[j]] &lt;= min_value:</span><br><span class="line">                    min_value = primes[j]*ugly[p_list[j]]</span><br><span class="line">            <span class="comment"># 满足条件的指针+1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length):</span><br><span class="line">                <span class="keyword">if</span> primes[j]*ugly[p_list[j]] == min_value:</span><br><span class="line">                    p_list[j] += <span class="number">1</span></span><br><span class="line">            ugly[i] = min_value</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">return</span> ugly[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;超级丑数&quot;&gt;&lt;a href=&quot;#超级丑数&quot; class=&quot;headerlink&quot; title=&quot;超级丑数&quot;&gt;&lt;/a&gt;超级丑数&lt;/h2&gt;&lt;p&gt;编写一段程序来查找第 n 个超级丑数。&lt;/p&gt;
&lt;p&gt;超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-264-丑数II</title>
    <link href="http://yoursite.com/2019/12/24/leetcode-264-%E4%B8%91%E6%95%B0II/"/>
    <id>http://yoursite.com/2019/12/24/leetcode-264-%E4%B8%91%E6%95%B0II/</id>
    <published>2019-12-24T14:54:17.000Z</published>
    <updated>2019-12-24T16:00:20.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="丑数II"><a href="#丑数II" class="headerlink" title="丑数II"></a>丑数II</h2><p>编写一个程序，找出第 n 个丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p>示例:</p><p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p><blockquote><p>1 是丑数。<br>n 不超过1690。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据丑数的定义，某个数如果是丑数一定是2，3，5的公倍数，那我们可以根据这个规则将丑数逐一列举出来。</p><p>列举的基本想法就是：如果一个数已经是丑数了，那么这个数的2，3，5倍仍然是丑数。</p><p>我们可以记录之前产生的所有丑数，然后维护三个指针，<code>p2</code>,<code>p3</code>,<code>p5</code>这三个指针什么用处呢？</p><blockquote><p>三个指针分别表示下一个丑数可能产生的情况：p2*2  p3*3  p5*5</p><p>这三个数哪个最小，就是下一个丑数，以最开始为例，第一个丑数为1,那么p2,p3,p5都指向1</p><p>1的下一个丑数是什么呢？ min(1*2,1*3,1*5) 为2，那么下一个丑数就是2，同时p2指针向前挪动一个</p><p>比如此时丑数序列已经有了[1,2,3,4,5,6,8,9,10]，p2指向6，p3指向4，p5指向3，</p><p>10的下一个丑数就是min(mem[p2]*2,mem[p3]*3,mem[p5]*5)</p><p>则下一个丑数为12</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        mem = [<span class="number">0</span>]*n</span><br><span class="line">        mem[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        p3 = <span class="number">0</span></span><br><span class="line">        p5 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            mem[i] = min(mem[p2]*<span class="number">2</span>,mem[p3]*<span class="number">3</span>,mem[p5]*<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> mem[i] == mem[p2]*<span class="number">2</span>:</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mem[i] == mem[p3]*<span class="number">3</span>:</span><br><span class="line">                p3+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mem[i] == mem[p5]*<span class="number">5</span>:</span><br><span class="line">                p5+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mem[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>又一次写没写出来就是p2,p3,p5的含义搞混了</li><li>一定是在之前生成的丑数基础上进行操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;丑数II&quot;&gt;&lt;a href=&quot;#丑数II&quot; class=&quot;headerlink&quot; title=&quot;丑数II&quot;&gt;&lt;/a&gt;丑数II&lt;/h2&gt;&lt;p&gt;编写一个程序，找出第 n 个丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 2, 3, 5 的正整数。&lt;/p&gt;
&lt;p&gt;示例:&lt;/
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-263-丑数</title>
    <link href="http://yoursite.com/2019/12/23/leetcode-263-%E4%B8%91%E6%95%B0/"/>
    <id>http://yoursite.com/2019/12/23/leetcode-263-%E4%B8%91%E6%95%B0/</id>
    <published>2019-12-23T15:30:43.000Z</published>
    <updated>2019-12-23T15:33:22.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p>示例 1:</p><p>输入: 6<br>输出: true<br>解释: 6 = 2 × 3<br>示例 2:</p><p>输入: 8<br>输出: true<br>解释: 8 = 2 × 2 × 2<br>示例 3:</p><p>输入: 14<br>输出: false<br>解释: 14 不是丑数，因为它包含了另外一个质因数 7。<br>说明：</p><p>1 是丑数。<br>输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>丑数的定义已经说明白了，<code>只包含质因数2，3，5的正整数，1也是丑数</code></p><p>给我们一个数，只需要不断用丑数的质因数去除待测试的数即可，如果最后的结果是1则是丑数，否则不是</p><p>（0这个数十个坑，记得排除）</p><p>递归解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">3</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">5</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;丑数&quot;&gt;&lt;a href=&quot;#丑数&quot; class=&quot;headerlink&quot; title=&quot;丑数&quot;&gt;&lt;/a&gt;丑数&lt;/h2&gt;&lt;p&gt;编写一个程序判断给定的数是否为丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 2, 3, 5 的正整数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-23-合并K个排序链表</title>
    <link href="http://yoursite.com/2019/12/23/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/12/23/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2019-12-23T15:01:31.000Z</published>
    <updated>2019-12-23T15:17:25.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a>合并K个排序链表</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题目其实比较简单，因为其子问题就是合并两个排序链表，这个是比较简单的。如果已经能解决两个链表了，那么K个链表也好解决。这里我们采用的<strong>分治</strong>的策略。</p><p>对于k个链表，我们最终可以分别两两合并，然后再将合并的结果再两两合并…</p><p>这个过程不就是归并排序的过程嘛…</p><blockquote><p>我们回想下归并排序的过程</p><p>给定：[5,2,3,4,1,6]</p><p>[5] [2] [3] [4] [1] [6]  两两合并</p><p>[2,5],[3,4],[1,6] 再两两合并</p><p>[2,3,4,5],[1,6] 再两两合并</p><p>[1,2,3,4,5,6] </p></blockquote><p>归并排序我们操作的是两个元素比较大小然后决定谁在前谁在后，而本题我们解决的是链表，只需要把基本操作换成链表的合并即可。</p><p>模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">()</span>:</span></span><br><span class="line">  divide(全部)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">()</span>:</span></span><br><span class="line">    终止条件...</span><br><span class="line">    </span><br><span class="line">    中间 =  (左+右)/<span class="number">2</span></span><br><span class="line">    左结果 = divide 左边</span><br><span class="line">    有结果 = divide 右边</span><br><span class="line">  合并 左结果，右结果</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">()</span>:</span></span><br><span class="line">  进行合并操作</span><br></pre></td></tr></table></figure><p>根据上边的模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># divide 整个数组</span></span><br><span class="line">        <span class="keyword">return</span> self.divide(lists,<span class="number">0</span>,len(lists)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 划分操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, lists, left, right)</span>:</span></span><br><span class="line">      <span class="comment"># 终止条件: 仅一个元素</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> lists[left]</span><br><span class="line">        <span class="comment"># 找中间</span></span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 左结果 = divide 左边</span></span><br><span class="line">        l1 = self.divide(lists, left, mid)</span><br><span class="line"><span class="comment"># 右结果 = divide 右边</span></span><br><span class="line">        l2 = self.divide(lists, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="comment"># 合并（左结果，右结果）</span></span><br><span class="line">        <span class="keyword">return</span> self.merge2Lists(l1,l2)</span><br><span class="line"><span class="comment"># 合并操作：本题的合并操作是 链表级别的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge2Lists</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        p1 = left</span><br><span class="line">        p2 = right</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val &lt; p2.val:</span><br><span class="line">                p.next = p1</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">elif</span> p1.val &gt;= p2.val:</span><br><span class="line">                p.next = p2</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> p1:</span><br><span class="line">            p.next = p1</span><br><span class="line">        <span class="keyword">if</span> p2:</span><br><span class="line">            p.next = p2</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;合并K个排序链表&quot;&gt;&lt;a href=&quot;#合并K个排序链表&quot; class=&quot;headerlink&quot; title=&quot;合并K个排序链表&quot;&gt;&lt;/a&gt;合并K个排序链表&lt;/h2&gt;&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;p&gt;示例:
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-2-两数相加</title>
    <link href="http://yoursite.com/2019/12/22/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2019/12/22/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2019-12-22T11:12:41.000Z</published>
    <updated>2019-12-22T11:50:31.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><blockquote><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目不难，但是细节问题吧…还是坑不少的</p><p>下面这个解法的思路就是先对应位相加，需要进位的记录下，然后在下一位时候考虑进去。总的思路是循环加到某个链表为空，则跳出处理。那么只需要把不空的那个链表链接到结果链表后边就可以了。</p><p>但是少考虑这样会出现的问题。</p><blockquote><p>[1]</p><p>[9,9]</p><p>Result:[0,0,1]</p><p>但是我的返回结果是:[0,10]</p></blockquote><p>下面附上<strong>错误代码</strong></p><p>这个想要更正也可以，会边的if语句换成while，然后进行对应操作即可。但是这样实际上把问题变复杂了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">            tmp.val = (p1.val+p2.val+carry)%<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> p1.val + p2.val +carry &gt;=<span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">            p.next = p2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            p.next = p1</span><br><span class="line">        <span class="keyword">if</span> carry==<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> p.next:</span><br><span class="line">            a = ListNode(<span class="number">1</span>)</span><br><span class="line">            p.next = a</span><br><span class="line">        <span class="keyword">elif</span> carry==<span class="number">1</span> <span class="keyword">and</span> p.next:</span><br><span class="line">            p.next.val += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><p>正确思路：</p><p>不用提前结束为空的链表，实际过程，两个链表是同步走的，如果其中一个链表为空了，我们可认为这个部分的值<strong>为0</strong> 即可，其他操作都一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">or</span> p2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">                x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = p1.val</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">                y = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y = p2.val</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            </span><br><span class="line">            tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">            tmp.val = (x+y+carry)%<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> x+y+carry &gt;=<span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> carry==<span class="number">1</span>:</span><br><span class="line">            a = ListNode(<span class="number">1</span>)</span><br><span class="line">            p.next = a</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;两数相加&quot;&gt;&lt;a href=&quot;#两数相加&quot; class=&quot;headerlink&quot; title=&quot;两数相加&quot;&gt;&lt;/a&gt;两数相加&lt;/h2&gt;&lt;p&gt;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-16-最接近的三数之和</title>
    <link href="http://yoursite.com/2019/12/22/leetcode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/12/22/leetcode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2019-12-22T08:48:37.654Z</published>
    <updated>2019-12-22T08:57:56.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p><p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本还是<a href="https://mereder.github.io/2019/11/25/leetcode-15-三数之和/" target="_blank" rel="noopener">三数之和</a>的思路，但是不用考虑重复问题。毕竟是找最接近的，而不是完全命中。相对简单点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        min_error = <span class="number">2</span>**<span class="number">32</span><span class="number">-1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            right = n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[left] + nums[right] &lt; target:</span><br><span class="line">                    <span class="keyword">if</span> abs(nums[i] + nums[left] + nums[right] - target) &lt; min_error:</span><br><span class="line">                        min_error = abs(nums[i] + nums[left] + nums[right] - target)</span><br><span class="line">                        result = nums[i] + nums[left] + nums[right]</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[left] + nums[right] &gt;= target:</span><br><span class="line">                    <span class="keyword">if</span> abs(nums[i] + nums[left] + nums[right] - target) &lt; min_error:</span><br><span class="line">                        min_error = abs(nums[i] + nums[left] + nums[right] - target)</span><br><span class="line">                        result = nums[i] + nums[left] + nums[right]</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最接近的三数之和&quot;&gt;&lt;a href=&quot;#最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;最接近的三数之和&quot;&gt;&lt;/a&gt;最接近的三数之和&lt;/h2&gt;&lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>HDFS 操作指令</title>
    <link href="http://yoursite.com/2019/12/22/hadoop%20hdfs%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/12/22/hadoop%20hdfs%E6%93%8D%E4%BD%9C/</id>
    <published>2019-12-22T08:08:00.000Z</published>
    <updated>2019-12-23T01:53:55.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>其操作指令大部分跟linux下的命令差不多。</p><p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html</a></p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -test -e  file_path</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测路径是否存在</span></span><br><span class="line">其对应返回这可以同 shell $?  来捕捉</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HDFS&quot;&gt;&lt;a href=&quot;#HDFS&quot; class=&quot;headerlink&quot; title=&quot;HDFS&quot;&gt;&lt;/a&gt;HDFS&lt;/h2&gt;&lt;p&gt;其操作指令大部分跟linux下的命令差不多。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hadoop.apache.or
      
    
    </summary>
    
    
      <category term="daily" scheme="http://yoursite.com/categories/daily/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-278-第一个错误的版本</title>
    <link href="http://yoursite.com/2019/12/22/leetcode-278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/12/22/leetcode-278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</id>
    <published>2019-12-22T08:03:26.000Z</published>
    <updated>2019-12-22T08:07:16.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><blockquote><p> 示例:</p><p>给定 n = 5，并且 version = 4 是第一个错误的版本。</p><p>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true</p><p>所以，4 是第一个错误的版本。 </p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是将二分法应用到实际的问题解决当中。</p><p>还有诸如类似什么两地之间的电线有一处坏了，如果你是一名电工如何最快的确定出问题的地方在哪。</p><p>题随不难，上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = n+<span class="number">1</span>  <span class="comment"># 这个地方很诡异  right=n 和 right = n+1 都能过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+((right-left) &gt;&gt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一个错误的版本&quot;&gt;&lt;a href=&quot;#第一个错误的版本&quot; class=&quot;headerlink&quot; title=&quot;第一个错误的版本&quot;&gt;&lt;/a&gt;第一个错误的版本&lt;/h2&gt;&lt;p&gt;你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>两个水桶的装水问题</title>
    <link href="http://yoursite.com/2019/12/18/%E8%A3%85%E6%B0%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/18/%E8%A3%85%E6%B0%B4%E9%97%AE%E9%A2%98/</id>
    <published>2019-12-18T15:33:15.000Z</published>
    <updated>2019-12-18T15:51:34.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装水问题"><a href="#装水问题" class="headerlink" title="装水问题"></a>装水问题</h2><p>一个和尚去河边挑水，带了两个桶，一个是能装4斤水，一个能装9斤水，问如何可以装一个6斤水的出来</p><p>（or 一个能装3斤水一个能装5斤水）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>A桶4斤，B桶9斤</p><p>只能有几种操作：</p><blockquote><p>Fill A</p><p>Fill B</p><p>Empty A</p><p>Empty B</p><p>A-B</p><p>B-A</p></blockquote><p>我们的操作序列如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.fill B -&gt; A:0 B:9</span><br><span class="line">2.B-A  -&gt; A:4 B:5</span><br><span class="line">3.empty A-&gt; A:0 B:5</span><br><span class="line">4.B-A -&gt; A:4 B:1</span><br><span class="line">5.empty A-&gt; A:0 B:1</span><br><span class="line">6.B-A   -&gt; A:1 B:0</span><br><span class="line">7.fill B -&gt; A:1 B:9</span><br><span class="line">8.B-A   -&gt; A:4 B:6</span><br></pre></td></tr></table></figure><p>即此时B桶内为6斤水，完成目标</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>一个和尚去河边挑水，带了两个桶，一个是能装4斤水，一个能装9斤水</p><p>1),要求写出算法，目标是如何装出6斤水</p><p>2),假设两个桶容量任意，比如X斤和Y斤,目标是Z斤;要求写出算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;装水问题&quot;&gt;&lt;a href=&quot;#装水问题&quot; class=&quot;headerlink&quot; title=&quot;装水问题&quot;&gt;&lt;/a&gt;装水问题&lt;/h2&gt;&lt;p&gt;一个和尚去河边挑水，带了两个桶，一个是能装4斤水，一个能装9斤水，问如何可以装一个6斤水的出来&lt;/p&gt;
&lt;p&gt;（or 一个能
      
    
    </summary>
    
    
      <category term="智力题" scheme="http://yoursite.com/categories/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
    
  </entry>
  
</feed>
