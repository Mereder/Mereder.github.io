<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Mereder</title>
  
  <subtitle>珍惜现在，感谢所有，不悔将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-02T14:47:12.375Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meng Di</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-382-链表随机节点</title>
    <link href="http://yoursite.com/2020/03/02/leetcode-382-%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/03/02/leetcode-382-%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9/</id>
    <published>2020-03-01T17:49:44.000Z</published>
    <updated>2020-03-02T14:47:12.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表随机节点"><a href="#链表随机节点" class="headerlink" title="链表随机节点"></a>链表随机节点</h2><p>给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。</p><p>进阶:<br>如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？</p><p>示例:</p><blockquote><p> // 初始化一个单链表 [1,2,3].<br>ListNode head = new ListNode(1);<br>head.next = new ListNode(2);<br>head.next.next = new ListNode(3);<br>Solution solution = new Solution(head);</p><p> // getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。<br>solution.getRandom();</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-random-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-random-node</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把整个单链表看成是一个数据流，从数据流中进行采样</p><p><strong>蓄水池采样</strong>的核心是：</p><blockquote><p>假设当前正要读取第n个数据，则我们以1/n的概率留下该数据，否则留下前n-1个数据中的一个。</p><p>等概率证明：</p><p>对于只有一个数，概率就是1</p><p>对于2个数，则第一个先取到的概率为1，当第二个数来时，选择以1/2的概率保留，则总的来讲，取第一个数的概率为1*1/2，对于第二个数来讲，概率为1/2</p><p>…</p><p>对于n个数，有</p><p>第一个数：$1<em>\frac{1}{2}</em>\frac{2}{3} … *\frac{n-1}{n} = \frac{1}{n}$</p><p>第二个数：$\frac{1}{2}<em>\frac{2}{3} … </em>\frac{n-1}{n} = \frac{1}{n}$</p><p>…</p><p>第n个数：$\frac{1}{n}$</p><p>所以对于这n个数来说是等概率的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, head: ListNode)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @param head The linked list's head.</span></span><br><span class="line"><span class="string">        Note that the head is guaranteed to be not null, so it contains at least one node.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.linkedList = head</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns a random node's value.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 首元素被选中概率为1</span></span><br><span class="line">        r_data = self.linkedList.val</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        p = self.linkedList.next</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 决定是否随机替换掉</span></span><br><span class="line">            <span class="keyword">if</span> rd.randint(<span class="number">1</span>,cnt) == cnt:</span><br><span class="line">                r_data = p.val</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(head)</span></span><br><span class="line"><span class="comment"># param_1 = obj.getRandom()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表随机节点&quot;&gt;&lt;a href=&quot;#链表随机节点&quot; class=&quot;headerlink&quot; title=&quot;链表随机节点&quot;&gt;&lt;/a&gt;链表随机节点&lt;/h2&gt;&lt;p&gt;给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。&lt;/p&gt;
&lt;p&gt;进阶
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
      <category term="蓄水池采样" scheme="http://yoursite.com/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-398-随机数索引（蓄水池采样）</title>
    <link href="http://yoursite.com/2020/03/02/leetcode-398-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2020/03/02/leetcode-398-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/</id>
    <published>2020-03-01T17:34:15.000Z</published>
    <updated>2020-03-01T17:43:04.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机数索引（蓄水池采样）"><a href="#随机数索引（蓄水池采样）" class="headerlink" title="随机数索引（蓄水池采样）"></a>随机数索引（蓄水池采样）</h2><p>给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。</p><p>注意：<br>数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。</p><p>示例:</p><p>int[] nums = new int[] {1,2,3,3,3};<br>Solution solution = new Solution(nums);</p><p>// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。<br>solution.pick(3);</p><p>// pick(1) 应该返回 0。因为只有nums[0]等于1。<br>solution.pick(1);</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/random-pick-index" target="_blank" rel="noopener">https://leetcode-cn.com/problems/random-pick-index</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>限制了不可以开辟额外空间，而且数字大小很大的话，最好是O（N）遍历</p><p><strong>蓄水池采样</strong>的核心是：</p><blockquote><p>假设当前正要读取第n个数据，则我们以1/n的概率留下该数据，否则留下前n-1个数据中的一个。</p><p>等概率证明：</p><p>对于只有一个数，概率就是1</p><p>对于2个数，则第一个先取到的概率为1，当第二个数来时，选择以1/2的概率保留，则总的来讲，取第一个数的概率为1*1/2，对于第二个数来讲，概率为1/2</p><p>…</p><p>对于n个数，有</p><p>第一个数：$1<em>\frac{1}{2}</em>\frac{2}{3} … *\frac{n-1}{n} = \frac{1}{n}$</p><p>第二个数：$\frac{1}{2}<em>\frac{2}{3} … </em>\frac{n-1}{n} = \frac{1}{n}$</p><p>…</p><p>第n个数：$\frac{1}{n}$</p><p>所以对于这n个数来说是等概率的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.nums)):</span><br><span class="line">            <span class="keyword">if</span> self.nums[i] == target:</span><br><span class="line">                <span class="comment"># 第一次遇到 概率就是 1嘛</span></span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    index = i</span><br><span class="line">                <span class="comment"># </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># random.randint 返回闭区间 [a,b]</span></span><br><span class="line">                    <span class="comment"># 选到cnt的概率为  1/cnt</span></span><br><span class="line">                    <span class="keyword">if</span> rd.randint(<span class="number">1</span>,cnt) == cnt:</span><br><span class="line">                        index = i</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.pick(target)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;随机数索引（蓄水池采样）&quot;&gt;&lt;a href=&quot;#随机数索引（蓄水池采样）&quot; class=&quot;headerlink&quot; title=&quot;随机数索引（蓄水池采样）&quot;&gt;&lt;/a&gt;随机数索引（蓄水池采样）&lt;/h2&gt;&lt;p&gt;给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
      <category term="蓄水池采样" scheme="http://yoursite.com/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-周赛-178场</title>
    <link href="http://yoursite.com/2020/03/01/leetcode%E5%91%A8%E8%B5%9B178%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/01/leetcode%E5%91%A8%E8%B5%9B178%E5%9C%BA/</id>
    <published>2020-03-01T07:12:08.000Z</published>
    <updated>2020-03-01T07:56:44.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛——176场"><a href="#周赛——176场" class="headerlink" title="周赛——176场"></a>周赛——176场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">有多少小于当前数字的数字</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/rank-teams-by-votes/" target="_blank" rel="noopener">通过投票对团队排名</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/" target="_blank" rel="noopener">二叉树中的列表</a><br><code>7 分</code> - <a href="https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/" target="_blank" rel="noopener">使网格图至少有一条有效路径的最小代价</a></p><h3 id="T1-有多少小于当前数字的数字"><a href="#T1-有多少小于当前数字的数字" class="headerlink" title="T1 有多少小于当前数字的数字"></a>T1 有多少小于当前数字的数字</h3><p>看了下题目的数字限制</p><blockquote><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><p>直接暴力求解了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m = len(nums)</span><br><span class="line">        res = [<span class="number">0</span>]*m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            res[i] = cnt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="T2-通过投票对团队进行排名"><a href="#T2-通过投票对团队进行排名" class="headerlink" title="T2 通过投票对团队进行排名"></a>T2 通过投票对团队进行排名</h3><p>模拟就好了，先对每个人的投票情况进行计数，这个地方考虑一个存储结构，我用的是字典</p><blockquote><p>每个key对应的value是一个list，list的长度取决于共有多少个团队</p><p>votes = [“ABC”,”ACB”,”ABC”,”ACB”,”ACB”]</p><p>dict = {</p><p>​    ‘A’:[5,0,0],</p><p>​    ‘B’:[0,2,3],</p><p>​    ‘C:[0,3,2]’</p><p>}</p></blockquote><p>统计好投票情况之后，再进行插排即可，插入排序的比较方法需要自己定义一下：</p><p>即按照约定的大小方法，如果得票较靠前则按票数排序，如果票一样则按照字典序排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rankTeams</span><span class="params">(self, votes: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="comment">#先统计 再 插排</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> votes <span class="keyword">or</span> len(votes[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        n = len(votes)</span><br><span class="line">        m = len(votes[<span class="number">0</span>])</span><br><span class="line">        d_cnt = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 完成统计</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                ch = votes[i][j]</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> d_cnt:</span><br><span class="line">                    d_cnt[ch][j] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> ch <span class="keyword">not</span> <span class="keyword">in</span> d_cnt:</span><br><span class="line">                    d_cnt[ch] = [<span class="number">0</span>]*m</span><br><span class="line">                    d_cnt[ch][j] = <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> ch,value <span class="keyword">in</span> d_cnt.items():</span><br><span class="line">            index = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">                res.append(ch)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># insert 插入在前面插入</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">                    tmp = res[i]</span><br><span class="line">                    <span class="keyword">if</span> self.less(tmp,ch,m,d_cnt):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        index = i</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">                res.append(ch)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.insert(index,ch)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">less</span><span class="params">(self,a,b,m,d_cnt)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> d_cnt[a][i] &gt; d_cnt[b][i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> d_cnt[a][i] == d_cnt[b][i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b &gt; a</span><br></pre></td></tr></table></figure><h3 id="T3-二叉树中的列表"><a href="#T3-二叉树中的列表" class="headerlink" title="T3 二叉树中的列表"></a>T3 二叉树中的列表</h3><p>思路很简单，先找到链表头结点对应的树中节点，然后再进行DFS进行匹配即可。</p><ul><li><p>链表头结点对应的树中节点</p><p>我用的bfs，如果当前节点值与链表头结点一样 则开始进入dfs</p></li><li><p>dfs进行匹配</p><p>限制一些规则，分别进行匹配即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubPath</span><span class="params">(self, head: ListNode, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        p = head</span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">while</span> p :</span><br><span class="line">            lst.append(p.val)</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        q = []</span><br><span class="line">        q.append(root)</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span>  q:</span><br><span class="line">            node = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.val == lst[<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># print(node)</span></span><br><span class="line">                flag = self.dfs_check(node,lst,<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_check</span><span class="params">(self,node,lst,index)</span>:</span></span><br><span class="line">        <span class="comment"># print(index)</span></span><br><span class="line">        <span class="keyword">if</span> index == len(lst):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.val != lst[index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.val == lst[index]:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        left = self.dfs_check(node.left,lst,index)</span><br><span class="line">        right = self.dfs_check(node.right,lst,index)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure><h3 id="T4-使网格图至少有一条有效路径的最小代价"><a href="#T4-使网格图至少有一条有效路径的最小代价" class="headerlink" title="T4 使网格图至少有一条有效路径的最小代价"></a>T4 使网格图至少有一条有效路径的最小代价</h3><p>比赛时候都没有来得及看，自己看完题目的第一想法是</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛——176场&quot;&gt;&lt;a href=&quot;#周赛——176场&quot; class=&quot;headerlink&quot; title=&quot;周赛——176场&quot;&gt;&lt;/a&gt;周赛——176场&lt;/h2&gt;&lt;p&gt;&lt;code&gt;3 分&lt;/code&gt; - &lt;a href=&quot;https://leetcode-c
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="http://yoursite.com/2020/03/01/leetcode%E5%91%A8%E8%B5%9B177%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/01/leetcode%E5%91%A8%E8%B5%9B177%E5%9C%BA/</id>
    <published>2020-03-01T04:26:56.628Z</published>
    <updated>2020-03-01T07:12:41.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛——177场"><a href="#周赛——177场" class="headerlink" title="周赛——177场"></a>周赛——177场</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛——177场&quot;&gt;&lt;a href=&quot;#周赛——177场&quot; class=&quot;headerlink&quot; title=&quot;周赛——177场&quot;&gt;&lt;/a&gt;周赛——177场&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-13-罗马数字转整数</title>
    <link href="http://yoursite.com/2020/02/29/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/29/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</id>
    <published>2020-02-29T07:32:17.000Z</published>
    <updated>2020-02-29T07:43:31.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><p>输入: “III”<br>输出: 3<br>示例 2:</p><p>输入: “IV”<br>输出: 4<br>示例 3:</p><p>输入: “IX”<br>输出: 9<br>示例 4:</p><p>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.<br>示例 5:</p><p>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/roman-to-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本上思路就是 模拟</p><p>一个字符一个字符的置换成对应的数，如果较小的出现在较大的前面，则进行减法，其余进行加法操作。</p><p>这样就产生了前一个和当前字符的概念，需要使用两个指针来记录前一个 和后一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        table = &#123;<span class="string">'M'</span>:<span class="number">1000</span>, </span><br><span class="line">                 <span class="string">'D'</span>:<span class="number">500</span>,</span><br><span class="line">                 <span class="string">'C'</span>:<span class="number">100</span>,</span><br><span class="line">                 <span class="string">'L'</span>:<span class="number">50</span>,</span><br><span class="line">                 <span class="string">'X'</span>:<span class="number">10</span>,</span><br><span class="line">                 <span class="string">'V'</span>:<span class="number">5</span>,</span><br><span class="line">                 <span class="string">'I'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre = table[s[<span class="number">0</span>]]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            cur = table[s[i]]</span><br><span class="line">            <span class="keyword">if</span> pre &lt; cur:</span><br><span class="line">                res -= pre</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += pre</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="comment"># 退出时候，最后一个 赋值为 pre 直接加</span></span><br><span class="line">        res += pre</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;罗马数字转整数&quot;&gt;&lt;a href=&quot;#罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;罗马数字转整数&quot;&gt;&lt;/a&gt;罗马数字转整数&lt;/h2&gt;&lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;p&gt;字符       
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>娇娇实验要点</title>
    <link href="http://yoursite.com/2020/02/29/%E5%A8%87%E5%A8%87%E5%AE%9E%E9%AA%8C%E8%A6%81%E7%82%B9/"/>
    <id>http://yoursite.com/2020/02/29/%E5%A8%87%E5%A8%87%E5%AE%9E%E9%AA%8C%E8%A6%81%E7%82%B9/</id>
    <published>2020-02-28T18:16:44.886Z</published>
    <updated>2020-02-28T18:16:44.886Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-12-整数转罗马数字</title>
    <link href="http://yoursite.com/2020/02/26/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/02/26/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-26T14:15:31.000Z</published>
    <updated>2020-02-26T14:19:12.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:</p><p>输入: 3<br>输出: “III”<br>示例 2:</p><p>输入: 4<br>输出: “IV”<br>示例 3:</p><p>输入: 9<br>输出: “IX”<br>示例 4:</p><p>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.<br>示例 5:</p><p>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>主要的思路就是 查表+贪心</p><p>查表体现在：我们尽可能将核心组成数组 用一个dict 存储起来</p><p>贪心体现在：每次我们都是先用一个尽可能大的 表中数字去进行处理，优先使用大的符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        table = &#123;<span class="string">'M'</span>:<span class="number">1000</span>, </span><br><span class="line">                 <span class="string">'CM'</span>:<span class="number">900</span>,</span><br><span class="line">                 <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">                 <span class="string">'CD'</span>:<span class="number">400</span>,</span><br><span class="line">                 <span class="string">'C'</span>:<span class="number">100</span>,</span><br><span class="line">                 <span class="string">'XC'</span>:<span class="number">90</span>,</span><br><span class="line">                 <span class="string">'L'</span>:<span class="number">50</span>,</span><br><span class="line">                 <span class="string">'XL'</span>:<span class="number">40</span>,</span><br><span class="line">                 <span class="string">'X'</span>:<span class="number">10</span>,</span><br><span class="line">                 <span class="string">'IX'</span>:<span class="number">9</span>,</span><br><span class="line">                 <span class="string">'V'</span>:<span class="number">5</span>,</span><br><span class="line">                 <span class="string">'IV'</span>:<span class="number">4</span>,</span><br><span class="line">                 <span class="string">'I'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> table.keys(): <span class="comment"># 潜在的贪心过程，因为table 我是按从大到小写的，遍历过程也会按照从大到小进行</span></span><br><span class="line">            cnt = num // table[key]</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            res += cnt * key</span><br><span class="line">            num -= cnt * table[key]</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整数转罗马数字&quot;&gt;&lt;a href=&quot;#整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;整数转罗马数字&quot;&gt;&lt;/a&gt;整数转罗马数字&lt;/h2&gt;&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;p&gt;字符       
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>K个一组翻转链表</title>
    <link href="http://yoursite.com/2020/02/26/leetcode-25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/26/leetcode-25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-25T17:42:42.000Z</published>
    <updated>2020-02-25T17:50:57.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例 :</p><p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>说明 :</p><p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解题方式很简单，就是K个翻转一次，比较难理解的地方在于需要维护多个变量，来实现这个方法</p><blockquote><ul><li>start指针：待翻转链表的头结点，翻转后变成尾结点</li><li>end指针：待翻转链表的尾节点，翻转后变成头结点</li><li>pre指针：待翻转链表的前面部分（可以理解为 已经完成操作的节点的尾部）</li><li>nxt指针：未进行操作的链表头部</li></ul></blockquote><p>下图来自LeetCode讨论区：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/" target="_blank" rel="noopener">王小二</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc96g7ia6nj30lx10stax.jpg" alt="k个一组翻转链表.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pre = dummy</span><br><span class="line">        end = dummy</span><br><span class="line">        dummy.next = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> end:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                end = end.next <span class="keyword">if</span> end <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> end:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            nxt = end.next</span><br><span class="line">            end.next = <span class="literal">None</span></span><br><span class="line">            start = pre.next</span><br><span class="line">            pre.next = self.reverse(start)</span><br><span class="line">            start.next = nxt <span class="comment">### start 跑到尾部了</span></span><br><span class="line">            pre = start</span><br><span class="line">            end = start</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            nxt = p.next</span><br><span class="line">            p.next = pre</span><br><span class="line">            pre = p</span><br><span class="line">            p = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;K个一组翻转链表&quot;&gt;&lt;a href=&quot;#K个一组翻转链表&quot; class=&quot;headerlink&quot; title=&quot;K个一组翻转链表&quot;&gt;&lt;/a&gt;K个一组翻转链表&lt;/h2&gt;&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正
      
    
    </summary>
    
    
      <category term="算法算题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AE%97%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AE%97%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-138-复制带随机指针的链表</title>
    <link href="http://yoursite.com/2020/02/26/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/26/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-25T16:48:37.000Z</published>
    <updated>2020-02-25T17:45:35.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h2><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的 深拷贝。 </p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</p><p>示例 1：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc94qezsp7j31gs0aq0u5.jpg" alt="img"></p><blockquote><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p></blockquote><p>更多示例 <a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">原题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用的是剑指里面的解题思路。先把链表的每一个节点都copy一遍，并且追加到该节点之后</p><blockquote><p>即: 1-2-3-4 -&gt;  1-1’-2-2’-3-3’-4-4’</p></blockquote><p>然后再将随机指针按照原来的形式，追加到各个复制节点上</p><blockquote><p>即 若原来有一个 1——4的随机指针，那么复制的节点 也应该有 1’——4’这样一个随机指针</p></blockquote><p>然后再重新遍历整个链表，将链表拆开，返回深拷贝的链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 1.复制一遍链表</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            tmp = Node(p.val,p.next)</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = tmp.next</span><br><span class="line">        <span class="comment"># 2.复制random 指针</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p :</span><br><span class="line">            q = p.next</span><br><span class="line">            q.random = p.random.next <span class="keyword">if</span> p.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p = q.next</span><br><span class="line">        <span class="comment"># 3.从头遍历，拆出来指针</span></span><br><span class="line">        p = head</span><br><span class="line">        dummy = head.next</span><br><span class="line">        q = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q.random = p.random.next <span class="keyword">if</span> p.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p = q.next</span><br><span class="line">            q.next = p.next <span class="keyword">if</span> p <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            q = q.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;复制带随机指针的链表&quot;&gt;&lt;a href=&quot;#复制带随机指针的链表&quot; class=&quot;headerlink&quot; title=&quot;复制带随机指针的链表&quot;&gt;&lt;/a&gt;复制带随机指针的链表&lt;/h2&gt;&lt;p&gt;给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2020/02/22/SwordOffer/test/"/>
    <id>http://yoursite.com/2020/02/22/SwordOffer/test/</id>
    <published>2020-02-22T13:20:09.000Z</published>
    <updated>2020-02-22T13:20:38.084Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>SwordOffer/Untitled</title>
    <link href="http://yoursite.com/2020/02/22/SwordOffer/Untitled/"/>
    <id>http://yoursite.com/2020/02/22/SwordOffer/Untitled/</id>
    <published>2020-02-22T13:19:51.649Z</published>
    <updated>2020-02-22T13:19:51.649Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Union-Find</title>
    <link href="http://yoursite.com/2020/02/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/02/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2020-02-22T08:23:41.000Z</published>
    <updated>2020-02-22T08:25:05.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Union-find"><a href="#Union-find" class="headerlink" title="Union-find"></a>Union-find</h2><p>并查集，主要用来解决再一个集合中查找是否存在另一个元素，或者合并两个集合。</p><p>涉及到的主要操作就是Union和Find</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Union-find&quot;&gt;&lt;a href=&quot;#Union-find&quot; class=&quot;headerlink&quot; title=&quot;Union-find&quot;&gt;&lt;/a&gt;Union-find&lt;/h2&gt;&lt;p&gt;并查集，主要用来解决再一个集合中查找是否存在另一个元素，或者合并两个集合。&lt;
      
    
    </summary>
    
    
      <category term="算法基础" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>实现strStr</title>
    <link href="http://yoursite.com/2020/02/22/leetcode-28-%E5%AE%9E%E7%8E%B0strStr/"/>
    <id>http://yoursite.com/2020/02/22/leetcode-28-%E5%AE%9E%E7%8E%B0strStr/</id>
    <published>2020-02-22T08:23:07.752Z</published>
    <updated>2020-02-26T17:44:11.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr"></a>实现strStr</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        kmp = KMP(needle)</span><br><span class="line">        <span class="keyword">return</span> kmp.search(haystack)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pat)</span>:</span></span><br><span class="line">        self.p_len = len(pat)</span><br><span class="line">        self.dp = [[<span class="number">0</span>]*<span class="number">128</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.p_len)]</span><br><span class="line">        self.pat = pat</span><br><span class="line"><span class="comment"># 这段太经典了，尝试用 状态机的 形式来理解这段</span></span><br><span class="line">        <span class="comment"># i 所代表的 不要第一时间理解为下标，这个地方更好的理解是状态</span></span><br><span class="line">        x=<span class="number">0</span></span><br><span class="line">        self.dp[<span class="number">0</span>][ord(self.pat[<span class="number">0</span>])] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,self.p_len):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">128</span>):</span><br><span class="line">                <span class="keyword">if</span> ord(self.pat[i]) == j:</span><br><span class="line">                    <span class="comment"># 遇到符合标准的字符串</span></span><br><span class="line">                    self.dp[i][j] = i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.dp[i][j] = self.dp[x][j]</span><br><span class="line">            </span><br><span class="line">            x = self.dp[x][ord(self.pat[i])]</span><br><span class="line">        print(self.dp)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, tat)</span>:</span></span><br><span class="line">        m = len(tat)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            j = self.dp[j][ord(tat[i])]</span><br><span class="line">            <span class="keyword">if</span> j == self.p_len:</span><br><span class="line">                <span class="keyword">return</span> i-self.p_len+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现strStr&quot;&gt;&lt;a href=&quot;#实现strStr&quot; class=&quot;headerlink&quot; title=&quot;实现strStr&quot;&gt;&lt;/a&gt;实现strStr&lt;/h2&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-980-不同路径III</title>
    <link href="http://yoursite.com/2020/02/19/leetcode-980-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III/"/>
    <id>http://yoursite.com/2020/02/19/leetcode-980-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III/</id>
    <published>2020-02-18T17:17:06.266Z</published>
    <updated>2020-02-19T15:00:48.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不同路径III"><a href="#不同路径III" class="headerlink" title="不同路径III"></a>不同路径III</h2><p>在二维网格 grid 上，有 4 种类型的方格：</p><p>1 表示起始方格。且只有一个起始方格。<br>2 表示结束方格，且只有一个结束方格。<br>0 表示我们可以走过的空方格。<br>-1 表示我们无法跨越的障碍。<br>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><p>示例 1：</p><blockquote><p>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]<br>输出：2<br>解释：我们有以下两条路径：</p><p>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</p><p>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</p><p>示例 2：<br>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]<br>输出：4<br>解释：我们有以下四条路径： </p><p>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</p><p>(0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</p><p>(0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</p><p>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</p><p>示例 3：</p><p>输入：[[0,1],[2,0]]<br>输出：0<br>解释：<br>没有一条路能完全穿过每一个空的方格一次。<br>请注意，起始和结束方格可以位于网格中的任意位置。</p></blockquote><p>提示：</p><p>1 &lt;= grid.length * grid[0].length &lt;= 20</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>自己的思路上来就是DFS，因为给的提示是<code>1&lt;= len(grid)*len(grid[0])&lt;=20</code>,说明数据量很小，DFS应该没问题</p><p>况且，需要遍历所有0位置，一开始没有想到动态规划如何来解决。那就用DFS来遍历所有位置。</p><p>每一次到达终点时候都需要检测是否grid内部的0都被探测到了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># grid &lt;=1 &lt;= 20</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        result = []</span><br><span class="line">        stack = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    self.help(i+<span class="number">1</span>, j, m, n, grid, result, stack)</span><br><span class="line">                    self.help(i<span class="number">-1</span>, j, m, n, grid, result, stack)</span><br><span class="line">                    self.help(i, j+<span class="number">1</span>, m, n, grid, result, stack)</span><br><span class="line">                    self.help(i, j<span class="number">-1</span>, m, n, grid, result, stack)</span><br><span class="line"></span><br><span class="line">        result = len(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(self, i,j,m,n,grid, result,stack)</span>:</span> <span class="comment"># result stack  都是 set</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i &gt;=m <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> grid[i][j]==<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> grid[i][j]==<span class="number">2</span> <span class="keyword">and</span> self.check(grid,m,n):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> grid[i][j]==<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> self.check(grid,m,n):</span><br><span class="line">            result.append(stack)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            grid[i][j] = <span class="number">-2</span></span><br><span class="line">            stack.add((i,j))</span><br><span class="line">            self.help(i,j+<span class="number">1</span>,m,n,grid,result,stack)</span><br><span class="line">            self.help(i,j<span class="number">-1</span>,m,n,grid,result,stack)</span><br><span class="line">            self.help(i+<span class="number">1</span>,j,m,n,grid,result,stack)</span><br><span class="line">            self.help(i<span class="number">-1</span>,j,m,n,grid,result,stack)</span><br><span class="line">            stack.add((i,j))</span><br><span class="line">            grid[i][j] = <span class="number">0</span>        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self,grid,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="延续【不同路径】系列问题思路"><a href="#延续【不同路径】系列问题思路" class="headerlink" title="延续【不同路径】系列问题思路"></a>延续【不同路径】系列问题思路</h3><p>继续动态规划</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不同路径III&quot;&gt;&lt;a href=&quot;#不同路径III&quot; class=&quot;headerlink&quot; title=&quot;不同路径III&quot;&gt;&lt;/a&gt;不同路径III&lt;/h2&gt;&lt;p&gt;在二维网格 grid 上，有 4 种类型的方格：&lt;/p&gt;
&lt;p&gt;1 表示起始方格。且只有一个起始方格
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第一次参加Leetcode周赛</title>
    <link href="http://yoursite.com/2020/02/16/leetcode%E5%91%A8%E8%B5%9B176%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/02/16/leetcode%E5%91%A8%E8%B5%9B176%E5%9C%BA/</id>
    <published>2020-02-16T14:38:55.000Z</published>
    <updated>2020-03-01T07:10:45.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛——176场"><a href="#周赛——176场" class="headerlink" title="周赛——176场"></a>周赛——176场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/" target="_blank" rel="noopener">统计有序矩阵中的负数</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/" target="_blank" rel="noopener">最后 K 个数的乘积</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/" target="_blank" rel="noopener">最多可以参加的会议数目</a><br><code>6 分</code> - <a href="https://leetcode-cn.com/problems/construct-target-array-with-multiple-sums/" target="_blank" rel="noopener">多次求和构造目标数组</a></p><h3 id="统计有序矩阵中的负数"><a href="#统计有序矩阵中的负数" class="headerlink" title="统计有序矩阵中的负数"></a>统计有序矩阵中的负数</h3><p>谈到有序！！！瞬间想到  <code>二分查找</code>，尤其是看了题意之后，这跟<a href="">Leetcode-74-搜索二维矩阵</a>解题思路基本一致。</p><p>关键点就是，定义行标，列标，从右上角开始遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNegatives</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        col = n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> row&lt;m <span class="keyword">and</span> col &gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> grid[row][col] &lt; <span class="number">0</span>:</span><br><span class="line">                result += m-row</span><br><span class="line">                col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>时间复杂度分析：<code>o(m+n)</code> 其实就是行指针和列指针各走一遍，相比于o(m<em>n)的解题方法，这里主要是通过行列两个指针，同时移动达到优化的。原本`m</em>n`方法，行列不会进行继承，跟前面遍历过后的没有关系。</p><h3 id="最后K个数的乘积"><a href="#最后K个数的乘积" class="headerlink" title="最后K个数的乘积"></a>最后K个数的乘积</h3><p>算法设计题目，原理很简单，设置一个list来保存每次添加的数，计算乘积时候，从后向前连乘K个即可。这里有很明显的问题，就是效率问题，计算连乘时候时间复杂度是<code>O(N)</code>的。</p><p>自然想到的时间优化策略就是用空间来换，如果我们保存好每个位置的乘积结果，那么最后K个数的乘积有:</p><p><code>f(k) = f(n)/f(n-k)</code>，因为都是连乘，那么也不需要刚开始说的list来保存添加的数了，只需要一个list保存连乘结果——<code>前缀乘</code></p><p>但是！ 遇到为0的情况需要特殊处理。</p><ul><li>遇到0的地方，那么前面的连乘结果就是0了，所以当其中一个元素为0时候，我们可以考虑丢弃前面所有结果了，重置数组和参数<code>nums</code></li><li>再调用时候，如果k大于0后的元素个数，那么结果一定为0，否则按照除法求得结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductOfNumbers</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sequence = []</span><br><span class="line">        self.nums = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            self.sequence = []  <span class="comment"># 关键地方！！！</span></span><br><span class="line">            self.nums = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.nums == <span class="number">0</span>:</span><br><span class="line">                self.sequence.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.sequence.append(self.sequence[self.nums<span class="number">-1</span>]*num)</span><br><span class="line">            self.nums += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getProduct</span><span class="params">(self, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &lt; k: <span class="comment"># ！！！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.nums == k:</span><br><span class="line">            <span class="keyword">return</span> self.sequence[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.sequence[self.nums<span class="number">-1</span>] // self.sequence[self.nums-k<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 3,1,2,10,40</span></span><br><span class="line"><span class="comment"># 1,2,10,40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your ProductOfNumbers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = ProductOfNumbers()</span></span><br><span class="line"><span class="comment"># obj.add(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getProduct(k)</span></span><br></pre></td></tr></table></figure><p>时间复杂度分析：<code>o(1)</code>因为结果都已经进行了保存，直接获取即可，空间复杂度为<code>o(n)</code>如果没有0出现，将保存整个前缀积</p><h3 id="最多可以参加的会议数目"><a href="#最多可以参加的会议数目" class="headerlink" title="最多可以参加的会议数目"></a>最多可以参加的会议数目</h3><p><strong>优先队列</strong>：说白了就是小根堆或者大根堆，看出去的元素优先出最小的还是最大的。</p><p>第一次接触优先队列，就遇到这样一个，我感觉比较难的题。</p><p>参考了别人的解法，基本思路就是：</p><ol><li>按照开始时间进行排序，如果开始时间比当前时间早即：current<code>小，那么这个会议可以加入考虑，将其结束时间放入优先队列，</code>注意：python 的heapq默认实现的是小根堆，也就是优先出小的元素。`</li><li>然后对优先队列的top进行判断，check是否<code>时间&lt;current</code>，这个时间就是上一步加入的结束时间，如果<code>结束时间&lt;current</code>表示该会议无法安排，则让其出队。</li><li>然后进行判断<code>队列是否为空</code>，不空则表示有可以安排的会议，然后<code>安排且仅能安排一个，即res+=1，并且top出队</code>。</li><li>直到满足 <code>i ==n and len(queue) == 0</code> 即待安排events 没有了，且队列中没有可安排的会议。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEvents</span><span class="params">(self, events: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 按照开始时间排序</span></span><br><span class="line">        events.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        current = <span class="number">1</span></span><br><span class="line">        pq = [] <span class="comment"># 默认是个小根堆</span></span><br><span class="line">        n = len(events)</span><br><span class="line">        <span class="comment"># max_time = max(max(events,key=lambda x:x[1]))</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 1.加入  值得安排的 会议</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> events[i][<span class="number">0</span>] &lt;= current:</span><br><span class="line">                heapq.heappush(pq, events[i][<span class="number">1</span>])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 2. 剔除不满足条件的会议</span></span><br><span class="line">            <span class="keyword">while</span> len(pq) &gt; <span class="number">0</span> <span class="keyword">and</span> pq[<span class="number">0</span>] &lt; current:</span><br><span class="line">                heapq.heappop(pq)</span><br><span class="line">            <span class="comment"># 3. 安排且仅能安排一个会议</span></span><br><span class="line">            <span class="keyword">if</span> len(pq) &gt; <span class="number">0</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                heapq.heappop(pq)</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 4. 弹尽粮绝 跳出</span></span><br><span class="line">            <span class="keyword">if</span> i == n <span class="keyword">and</span> len(pq) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="多次求和构造目标数组"><a href="#多次求和构造目标数组" class="headerlink" title="多次求和构造目标数组"></a>多次求和构造目标数组</h3><p>上来自己的垃圾思路就是 DFS，直接暴力枚举所有情况，直到出现有解得情况…</p><p>即 每一步加和的结果，可以成为下一步任一位置的值…这个复杂度太高了</p><p>其实倒过来想就很简单了：<strong>由本溯源</strong></p><p>对于给定的一个序列，只需要模拟情况，由当前序列，按照规则不断递减，看能否得到全1的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPossible</span><span class="params">(self, target: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            cur_max = max(target)</span><br><span class="line">            <span class="keyword">if</span> cur_max == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            s  = sum(target)</span><br><span class="line">            idx = target.index(cur_max)</span><br><span class="line">            increase = s-cur_max</span><br><span class="line">            <span class="keyword">if</span> increase &gt;= cur_max:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            target[idx] = cur_max-increase</span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li>上面的解法对于testcase:<code>[10^9,1]</code>需要循环10^9次，肯定超时了…大佬们都在说LeetCode测试数据太弱了。将上面的  <code>target[idx] = cur_max - increase</code> 修改为: <code>target[idx] = cur_max % increase</code>换成取模后，对于上面提到的问题，可以很快解决了。</li><li>还有问题，对于testcase:<code>[2]</code>，这个问题，上面将陷入无限循环，应该首先对这个进行优先判断。</li></ul><p>完整解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPossible</span><span class="params">(self, target: List[int])</span> -&gt; bool:</span></span><br><span class="line">      <span class="keyword">if</span> len(target) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> target[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            cur_max = max(target)</span><br><span class="line">            <span class="keyword">if</span> cur_max == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            s  = sum(target)</span><br><span class="line">            idx = target.index(cur_max)</span><br><span class="line">            increase = s-cur_max</span><br><span class="line">            <span class="keyword">if</span> increase &gt;= cur_max:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            target[idx] = cur_max-increase</span><br></pre></td></tr></table></figure><h4 id="更多考虑"><a href="#更多考虑" class="headerlink" title="更多考虑"></a>更多考虑</h4><p>第四题：</p><p>来源<a href="https://leetcode-cn.com/circle/discuss/0gO5RS/" target="_blank" rel="noopener">周赛题目讨论区</a>  用户：<a href="https://leetcode-cn.com/u/scut_dell/" target="_blank" rel="noopener">小白二号</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (target.length == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       PriorityQueue&lt;Long&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">       <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length; i++) &#123;</span><br><span class="line">           sum += target[i];</span><br><span class="line">           pq.offer((<span class="keyword">long</span>)target[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果此时队列为空或者最大值就是1，直接return true</span></span><br><span class="line">       <span class="keyword">if</span> (pq.isEmpty() || pq.<span class="built_in">peek</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">//取出最大的那个</span></span><br><span class="line">           Long poll = pq.poll();</span><br><span class="line">           <span class="comment">//如果此时堆中最大的为1</span></span><br><span class="line">           <span class="keyword">if</span> (pq.<span class="built_in">peek</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//直接看它满足或不满足公式</span></span><br><span class="line">               <span class="keyword">return</span> (poll - <span class="number">1</span>) % (sum - poll) == <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//需要计算多少轮才能比第二小的数小</span></span><br><span class="line">               <span class="keyword">long</span> n = (poll - pq.<span class="built_in">peek</span>()) / (sum - poll) + <span class="number">1</span>;</span><br><span class="line">               <span class="comment">//得到这个数字</span></span><br><span class="line">               <span class="keyword">long</span> x = poll - n * (sum - poll);</span><br><span class="line">               <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//更新sum</span></span><br><span class="line">               sum = poll - (sum - poll) * (n - <span class="number">1</span>);</span><br><span class="line">               pq.offer(x);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛——176场&quot;&gt;&lt;a href=&quot;#周赛——176场&quot; class=&quot;headerlink&quot; title=&quot;周赛——176场&quot;&gt;&lt;/a&gt;周赛——176场&lt;/h2&gt;&lt;p&gt;&lt;code&gt;3 分&lt;/code&gt; - &lt;a href=&quot;https://leetcode-c
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-66-加一</title>
    <link href="http://yoursite.com/2020/02/12/leetcode-66-%E5%8A%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/12/leetcode-66-%E5%8A%A0%E4%B8%80/</id>
    <published>2020-02-11T17:10:07.632Z</published>
    <updated>2020-02-11T17:17:32.174Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title</p><hr><h2 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p><p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>模拟实现过程，并且注意特殊情况，既然是从低位开始+1，则遍历数组需要从后向前。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 倒序遍历</span></span><br><span class="line">        index = len(digits)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 初始化情况</span></span><br><span class="line">        digits[index] = digits[index]+<span class="number">1</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 满足进位条件，则进行进位</span></span><br><span class="line">            <span class="keyword">if</span> digits[index]+carry&gt;<span class="number">9</span>:</span><br><span class="line">                digits[index] = (digits[index]+carry)%<span class="number">10</span> <span class="comment"># 模10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 不满足进位，加上可能存在的carry,然后直接退出就可以了</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[index] += carry </span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 判断是否需要再补入一个1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span> <span class="keyword">and</span> carry ==<span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]+digits</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;加一&quot;&gt;&lt;a href=&quot;#加一&quot; class=&quot;headerlink&quot; title=&quot;加一&quot;&gt;&lt;/a&gt;加一&lt;/h2&gt;&lt;p&gt;给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。&lt;/p&gt;
&lt;p&gt;最高位数字存
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-369-给单链表加1</title>
    <link href="http://yoursite.com/2020/02/12/leetcode-369-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8A%A01/"/>
    <id>http://yoursite.com/2020/02/12/leetcode-369-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8A%A01/</id>
    <published>2020-02-11T16:23:52.000Z</published>
    <updated>2020-02-11T16:41:31.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给单链表加1"><a href="#给单链表加1" class="headerlink" title="给单链表加1"></a>给单链表加1</h2><p>用一个 非空 单链表来表示一个非负整数，然后将这个整数加一。</p><p>你可以假设这个整数除了 0 本身，没有任何前导的 0。</p><p>这个整数的各个数位按照 高位在链表头部、低位在链表尾部 的顺序排列。</p><p>示例:</p><p>输入: [1,2,3]<br>输出: [1,2,4]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>发现有大神分享的思路太好了，所以直接按照他们的思路进行了编码。</p><p>这个题目最棘手的问题就是遇到含有9且以9结尾，就涉及到进位的问题：</p><blockquote><p>举个例子：</p><p>1-2-9-3-4 这个我们不需要担心，因为不是以9结尾</p><p>1-2-3-9-9 这个就很棘手，如果+1的话会造成两次进位，但是问题简化下，实际只需要在3处进位一次，后边置0即可</p></blockquote><ul><li>对于某个节点值为9，我们希望有个指针停留在9之前，这样我们方便进位，也能把之后的值都置为0</li><li>对于某个节点值为0-8，我们希望指针停留在当前节点，直接在当前节点上+1即可，无需额外操作</li></ul><p>根据上面的分析，自然想到用双指针，其中一个指针用来遍历链表，另外一个指针用来表示上面的情况。由于<code>left</code>,需要先在<code>right</code>前面才能保证首位如果是9的话，left仍在前面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">dummy.next = head</span><br><span class="line">left = dummy</span><br><span class="line">right = head</span><br><span class="line"><span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">  <span class="keyword">if</span> right.val != <span class="number">9</span>:</span><br><span class="line">    left = right</span><br><span class="line">  right = right.next</span><br></pre></td></tr></table></figure><p>由于上面的移动，最终的<code>left</code>指针就是我们需要操作的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">left.val += <span class="number">1</span></span><br><span class="line">p = left.next</span><br><span class="line"><span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">  p.val = <span class="number">0</span></span><br><span class="line">  p = p.next</span><br></pre></td></tr></table></figure><p>但是这里还有另外一个问题，如果遇到首位就是9的情况怎么办？那意味着我们需要重新创建一个头结点并且值为1，后续结点都为0。</p><p>巧了！前面我们为了保证left起始时在right前面，定义了一个哑变量<code>dummy node</code>，我们可以利用这个节点，来完成，所以修改如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(<span class="number">0</span>) <span class="comment"># 由原来的-1 变为0 这样+1之后就有含义了</span></span><br><span class="line">dummy.next = head</span><br><span class="line">left = dummy</span><br><span class="line">right = head</span><br><span class="line"><span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">  <span class="keyword">if</span> right.val != <span class="number">9</span>:</span><br><span class="line">    left = right</span><br><span class="line">  right = right.next</span><br></pre></td></tr></table></figure><p>最后返回时候，我们需要确认，dummy node的值是否更新了，如果更新为1则返回dummy，否则返回dummy.next</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> dummy.val == <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">return</span> dummy.next</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure><h3 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h3><p>时间复杂度为<code>o(N)</code>,空间复杂度为<code>o(1)</code>，因为使用了一个dummy node  3个指针，都是常数级别的</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        left = dummy</span><br><span class="line">        right = head</span><br><span class="line">        <span class="comment"># 始终更新left 和right保证left 始终在某个可能的9的左侧</span></span><br><span class="line">        <span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> right.val != <span class="number">9</span>:</span><br><span class="line">                left = right</span><br><span class="line">            right = right.next </span><br><span class="line">        </span><br><span class="line">        left.val += <span class="number">1</span></span><br><span class="line">        p = left.next</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            p.val = <span class="number">0</span></span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dummy.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;给单链表加1&quot;&gt;&lt;a href=&quot;#给单链表加1&quot; class=&quot;headerlink&quot; title=&quot;给单链表加1&quot;&gt;&lt;/a&gt;给单链表加1&lt;/h2&gt;&lt;p&gt;用一个 非空 单链表来表示一个非负整数，然后将这个整数加一。&lt;/p&gt;
&lt;p&gt;你可以假设这个整数除了 0 本身
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-155-最小栈</title>
    <link href="http://yoursite.com/2020/02/11/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://yoursite.com/2020/02/11/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/</id>
    <published>2020-02-10T17:21:42.898Z</published>
    <updated>2020-02-10T17:25:17.397Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) — 将元素 x 推入栈中。<br>pop() — 删除栈顶的元素。<br>top() — 获取栈顶元素。<br>getMin() — 检索栈中的最小元素。<br>示例:</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   —&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      —&gt; 返回 0.<br>minStack.getMin();   —&gt; 返回 -2.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-stack" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是借助一个辅助栈，来实现常数时间内获取最小值。</p><p>原理就是每次加入 辅助最小栈时，先比较，如果比最小栈栈顶元素小，就压入元素，否则就把原来的最小栈栈顶元素再次压入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.m_stack = []</span><br><span class="line">        self.nums = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums == <span class="number">0</span>:</span><br><span class="line">            self.m_stack.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> x &lt; self.m_stack[<span class="number">-1</span>]:</span><br><span class="line">                self.m_stack.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.m_stack.append(self.m_stack[<span class="number">-1</span>])</span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.nums += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">            self.m_stack.pop()</span><br><span class="line">            self.nums -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'栈为空'</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.m_stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'栈为空'</span>)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&quot;最小栈&quot;&gt;&lt;a href=&quot;#最小栈&quot; class=&quot;headerlink&quot; title=&quot;最小栈&quot;&gt;&lt;/a&gt;最小栈&lt;/h2&gt;&lt;p&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;p&gt;push(x)
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-707-设计链表</title>
    <link href="http://yoursite.com/2020/02/11/leetcode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/11/leetcode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-10T16:01:19.000Z</published>
    <updated>2020-02-10T16:03:29.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p><p>示例：</p><p>MyLinkedList linkedList = new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            //返回2<br>linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>linkedList.get(1);            //返回3</p><p>提示：</p><p>所有val值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>emmm 看见几个月前用java尝试了N边都错的题，Python一遍就过了…看了下当时写的java，不忍卒读，难怪会出问题。</p><p>注意几个地方：</p><ul><li>及时更新 capacity</li><li>使用一个dummy node 当 header</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        self.val = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># dummy 头</span></span><br><span class="line">        self.head = ListNode(<span class="number">-1</span>)</span><br><span class="line">        self.capacity = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># index 范围是 0-n-1</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.capacity:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> p.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = ListNode(val)</span><br><span class="line">        tmp.next = self.head.next</span><br><span class="line">        self.head.next = tmp</span><br><span class="line">        self.capacity += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = ListNode(val)</span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p.next != <span class="literal">None</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">        p.next = tmp</span><br><span class="line">        self.capacity += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.capacity:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index == self.capacity:</span><br><span class="line">            self.addAtTail(val)</span><br><span class="line">        <span class="keyword">elif</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            self.addAtHead(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = self.head</span><br><span class="line">            <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">            tmp = ListNode(val)</span><br><span class="line">            tmp.next = p.next</span><br><span class="line">            p.next = tmp</span><br><span class="line">            self.capacity += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span><span class="params">(self, index: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.capacity <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = self.head</span><br><span class="line">            <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p.next == <span class="literal">None</span>:</span><br><span class="line">                p = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = p.next.next</span><br><span class="line">            self.capacity -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计链表&quot;&gt;&lt;a href=&quot;#设计链表&quot; class=&quot;headerlink&quot; title=&quot;设计链表&quot;&gt;&lt;/a&gt;设计链表&lt;/h2&gt;&lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>第一次参加Leetcode周赛</title>
    <link href="http://yoursite.com/2020/02/09/leetcode%E5%91%A8%E8%B5%9B175%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/02/09/leetcode%E5%91%A8%E8%B5%9B175%E5%9C%BA/</id>
    <published>2020-02-09T14:38:55.000Z</published>
    <updated>2020-02-25T17:58:26.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一次参加周赛"><a href="#第一次参加周赛" class="headerlink" title="第一次参加周赛"></a>第一次参加周赛</h2><p>之前觉得太菜了，还是好好耍基础题，搞什么周赛，直到我参加了之后，才发现，我是真的菜！….</p><h2 id="周赛-175场"><a href="#周赛-175场" class="headerlink" title="周赛-175场"></a>周赛-175场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/" target="_blank" rel="noopener">检查整数及其两倍数是否存在</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/" target="_blank" rel="noopener">制造字母异位词的最小步骤数</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/tweet-counts-per-frequency/" target="_blank" rel="noopener">推文计数</a><br><code>7 分</code> - <a href="https://leetcode-cn.com/problems/maximum-students-taking-exam/" target="_blank" rel="noopener">参加考试的最大学生数</a></p><h3 id="第一题：easy"><a href="#第一题：easy" class="headerlink" title="第一题：easy"></a>第一题：easy</h3><p>跟2sum差不多的路子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfExist</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        tmp_dict = set([])</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            tmp = arr[i]</span><br><span class="line">            <span class="keyword">if</span> tmp*<span class="number">2</span> <span class="keyword">in</span> tmp_dict:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> tmp/<span class="number">2</span> <span class="keyword">in</span> tmp_dict:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            tmp_dict.add(tmp)</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure><p>复杂度分析：时间复杂度是<code>o(n)</code>，空间复杂度也是<code>o(n)</code>，n是数组元素个数。由于使用了<code>set</code>也是一种hash结构嘛，所以空间复杂度实际应该大于<code>o(n)</code>,具体到多少，就需要看<code>set</code>的实现机制了。</p><h3 id="第二题：Medium"><a href="#第二题：Medium" class="headerlink" title="第二题：Medium"></a>第二题：Medium</h3><p>看完题意之后，表示没太看懂，然后又看例子…我的理解就是，看下diff的字母个数就好了。</p><p>就先给<code>s</code>串各个字母计个数，然后遍历<code>t</code>串时候相应的减去，最后将<code>计数个数&gt;0</code>的相加就可以了</p><p>用什么来存各个计数个数呢？因为说的都是小写字母，用个26的数组就可以了，这样空间复杂度降到o(1)了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">        mem = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            mem[ord(char)-ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">            mem[ord(char)-ord(<span class="string">'a'</span>)] -= <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> mem[i] &gt;<span class="number">0</span>:</span><br><span class="line">                cnt += mem[i]</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h3 id="第三题：Medium"><a href="#第三题：Medium" class="headerlink" title="第三题：Medium"></a>第三题：Medium</h3><p>程序设计题目，理解题目并模拟就可以了，其实主要问题在于细节的优化。</p><p>一开始直接用的<code>o(nk)</code>n是一个用户的所有记录，k是k个时间间隔，也就是两层循环套起来用的…显然超时了。</p><p>简单的优化就是 二分查找，只需要确定startTime的起始下标就可以了。(实际是二分查找的变体：找最左满足条件的)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TweetCounts</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.tweetUser = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recordTweet</span><span class="params">(self, tweetName: str, time: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tweetName <span class="keyword">in</span> self.tweetUser:</span><br><span class="line">            self.tweetUser[tweetName].append(time)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tweetUser[tweetName] = [time]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTweetCountsPerFrequency</span><span class="params">(self, freq: str, tweetName: str, startTime: int, endTime: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> tweetName <span class="keyword">not</span> <span class="keyword">in</span> self.tweetUser:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> freq == <span class="string">'minute'</span>:</span><br><span class="line">            delt = <span class="number">60</span></span><br><span class="line">        <span class="keyword">elif</span> freq == <span class="string">'hour'</span>:</span><br><span class="line">            delt = <span class="number">60</span> * <span class="number">60</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delt = <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span></span><br><span class="line">        self.tweetUser[tweetName].sort()</span><br><span class="line">        result = []</span><br><span class="line">        index = self.bs(self.tweetUser[tweetName],startTime)</span><br><span class="line">        <span class="comment"># if index == -1:</span></span><br><span class="line">        <span class="comment">#     return [0]*((endTime+1-startTime)//delt + 1)</span></span><br><span class="line">        <span class="keyword">for</span> b_interval <span class="keyword">in</span> range(startTime,endTime+<span class="number">1</span>,delt):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            e_interval = min(endTime+<span class="number">1</span>,b_interval+delt)</span><br><span class="line">            <span class="keyword">while</span> index &lt; len(self.tweetUser[tweetName]) <span class="keyword">and</span> self.tweetUser[tweetName][index] &lt; endTime+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> b_interval &lt;= self.tweetUser[tweetName][index] &lt; e_interval:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> self.tweetUser[tweetName][index] &gt;= e_interval:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            result.append(cnt)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bs</span><span class="params">(self,nums,target)</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">if</span> right == len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &gt; target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">return</span> right  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your TweetCounts object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = TweetCounts()</span></span><br><span class="line"><span class="comment"># obj.recordTweet(tweetName,time)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)</span></span><br></pre></td></tr></table></figure><p>时间复杂度为<code>o(nlogn)</code>主要来自于排序部分，其他部分二分<code>logn</code>，计算时间复杂度的依然是<code>k*n</code>但是此时的n已经不是全局的数量了，已经给二分优化后的n已经大大减少。（我感觉并没有优化一个数量级那么夸张，但是已经很客观了）</p><p>后续看分享，有大神提出来二分的过程完全可以考虑使用<code>跳表</code>，给有序链表建立多级索引。</p><h3 id="第四题：Hard"><a href="#第四题：Hard" class="headerlink" title="第四题：Hard"></a>第四题：Hard</h3><p>参加考试的最大学生，看完题的感觉跟八皇后很像，所以直接考虑DFS进行。</p><p>根据题意，我们只需要DFS那个有效作为就可以， 并不用每个座位都遍历，最大的学生数的上限就是有效座位数。很可惜，辛辛苦苦搞出来，纯粹的DFS是超时的。</p><p>如果自己继续优化的话应该考虑剪枝问题，但是当时没有想到特别好的剪枝办法。</p><p>赛后看了大神们的分享，又学会了一个新的东西 <code>状态压缩DP</code> 或 <code>状态压缩DFS</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一次参加周赛&quot;&gt;&lt;a href=&quot;#第一次参加周赛&quot; class=&quot;headerlink&quot; title=&quot;第一次参加周赛&quot;&gt;&lt;/a&gt;第一次参加周赛&lt;/h2&gt;&lt;p&gt;之前觉得太菜了，还是好好耍基础题，搞什么周赛，直到我参加了之后，才发现，我是真的菜！….&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
</feed>
