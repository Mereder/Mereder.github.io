<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Mereder</title>
  
  <subtitle>珍惜现在，感谢所有，不悔将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-06T16:00:47.427Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meng Di</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-32-最长有效括号</title>
    <link href="http://yoursite.com/2019/12/06/leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/12/06/leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</id>
    <published>2019-12-06T15:17:50.000Z</published>
    <updated>2019-12-06T16:00:47.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><blockquote><p>示例 1:</p><p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:</p><p>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="简单粗暴没通过"><a href="#简单粗暴没通过" class="headerlink" title="简单粗暴没通过"></a>简单粗暴没通过</h4><p>上来最简单的肯定是 暴力解法啊，就是罗列所有可能的字符情况，然后逐个判断是否有效。</p><p>然后就挂了… 超出时间限制，case中218/230，有一部分通不过。于是想了几个简单的优化方法</p><ul><li>有效字符串肯定是以’(‘开头，以’)’结尾</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s: 空返回</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> len(s)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">')'</span>:</span><br><span class="line">                    count-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> count == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 枚举的过程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>: <span class="comment"># 优化</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(s)):</span><br><span class="line">                    <span class="keyword">if</span> s[j] == <span class="string">')'</span>:  <span class="comment"># 优化</span></span><br><span class="line">                        <span class="keyword">if</span> valid(s[i:j+<span class="number">1</span>]):</span><br><span class="line">                            l = j-i+<span class="number">1</span></span><br><span class="line">                            mx = max(mx,l)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure><h4 id="最优化想到dp"><a href="#最优化想到dp" class="headerlink" title="最优化想到dp"></a>最优化想到dp</h4><p>首先由于括号匹配的特殊性，最长的有效括号肯定是以’)’结尾的，所以我们只需要dp来统计’)’为尾的情况的最大值。</p><p>然后就需要考虑下转移状态，也就是说第i个位置以’)结尾’的最长有效长度怎么计算的问题：</p><p>只需要考虑两种情况，即i-1位置是’(‘还是’)’：</p><p>当i-1位置为’(‘：</p><blockquote><p>那么构成 ….()，肯定是在前面的基础上能+2，前面如果都无效那就是0+2，前面如果也有效就是前面的长度+2。这里所说的前面就是 dp[i-2]的结果</p></blockquote><p>当i-1位置为’)’:</p><blockquote><p>那么就构成….))，这个怎么计算有效呢？就需要参考dp[i-1]的长度，实际问题就变成了….(有效))，如果前面有效的子串前面还有个’(‘那就可以在前面有效子串的基础上长度+2，<strong>注意</strong>，还需要再加上再前面的有效子串的长度，举个栗子！！！<br>01234567<br>( ) ( (  ) ( ) )，当第7位时，由于第6位是’)’，且第6位已经计算好了结果为dp[6]=4，即从下标3，4，5，6这四个有效长度，此时计算第七位时，会直接用： 当前位置7-前面有效长度4-1=2，此时下标2为’(‘，与7匹配上，所以后边总的有效长度为 4+2，此时！！！ 前面也是有效的括号即dp[1]=2，那么总的结果应该是4+2+2</p><p>即dp[7] = dp[6]+2+dp[7-dp[6]-2]</p><p>(有空了一定画个图)</p></blockquote><ul><li>以’)’结尾考虑：<ul><li>其前一位为’(‘: dp[i] = dp[i-2] + 2</li><li>其前一位为’)’ 且 i-dp[i-1] -1 为’(‘：dp[i] = dp[i-1]+2 + dp[i-dp[i-1]-2]</li></ul></li><li>以’(‘结尾不考虑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>]*len(s)</span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">')'</span>: <span class="comment"># 只需要判断 ')即可'</span></span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    <span class="keyword">if</span> i<span class="number">-2</span> &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[i] = dp[i<span class="number">-2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> s[i<span class="number">-1</span>] == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i-dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>:</span><br><span class="line">                      </span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span> + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]</span><br><span class="line">                        </span><br><span class="line">                mx = max(mx,dp[i])</span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure><p>其实最后只要中间过程的最大值，所以不会像一般dp过程，dp数组的最后一个元素才是结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最长有效括号&quot;&gt;&lt;a href=&quot;#最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;最长有效括号&quot;&gt;&lt;/a&gt;最长有效括号&lt;/h2&gt;&lt;p&gt;给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;
&lt;blockqu
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-20-有效括号</title>
    <link href="http://yoursite.com/2019/12/06/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/12/06/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2019-12-06T09:41:07.000Z</published>
    <updated>2019-12-06T10:19:14.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><blockquote><p>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先说只有一种类型的括号的话，我们的解决方案（这也是<a href="https://mereder.github.io/2019/11/29/leetcode-22-括号生成/" target="_blank" rel="noopener">Leetcode-22-括号生成</a>题目中的一个步骤）。</p><p>如果只有一种括号，我们在遍历字符串的时候，只需要注意两个问题：</p><ul><li>遍历过程中 左边个数&gt;=右边个数</li><li>遍历结束后 左边个数 == 右边个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(s)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">      <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">      <span class="keyword">elif</span> i == <span class="string">')'</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>对应这个问题，上述方法就行不通了，因为涉及到三种不同的符号，单考虑一种括号的顺序正确是没用的，还需要考虑到括号之间的交叉，比如:</p><blockquote><p>{ [ } ]</p></blockquote><p>单个符号的顺序没有问题，但是总的就是不正确的括号。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n5vtuvdhj30v40h2myu.jpg" alt="Leetcode官方解答"></p><p>我们可以看到，如果一整个字符串都是有效的，那么其子字符串肯定也是有效的，那么最小的子问题就是一对相邻括号是匹配的。</p><p>那么可以通过删除掉匹配到的括号，逐步将问题解决。具体操作。</p><p><strong>（图来自Leetcode官方解答，他们的图画的真的好，就拿过来了）</strong></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n66bcjb7j30ls04ct8u.jpg" alt="image-20191206181715420"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n675t327j30i404m3yp.jpg" alt="image-201912061817155"></p><p>这样可以通过栈来解决，匹配到的就出栈，否则就进栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> a==<span class="string">'('</span> <span class="keyword">and</span> b == <span class="string">')'</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">'['</span> <span class="keyword">and</span> b == <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">'&#123;'</span> <span class="keyword">and</span> b == <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(s[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> match(stack[<span class="number">-1</span>], s[i]):</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;有效括号&quot;&gt;&lt;a href=&quot;#有效括号&quot; class=&quot;headerlink&quot; title=&quot;有效括号&quot;&gt;&lt;/a&gt;有效括号&lt;/h2&gt;&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-26-删除排序数组中的重复项</title>
    <link href="http://yoursite.com/2019/12/05/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://yoursite.com/2019/12/05/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2019-12-05T11:53:14.000Z</published>
    <updated>2019-12-05T12:06:35.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><blockquote><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>说明:</p><p> 为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:(引用问题嘛，传值传引用)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>虽然是个easy的题，但是一开始确实没有很好的思路，其实每次做数组的题老是不会灵活的使用指针（也就是数组的下标），每次都是只有依次遍历的指针。没有灵活使用</p><p>这个题使用两个指针(i慢，j快)</p><ul><li>i指针用来指示有效数字（即无重复数）</li><li>j指针用来遍历数组所有数，重复就跳过，不重复就赋值到 i+1</li></ul><p>比较好的是数组是排好序的，所以单次遍历就能把重复数都找出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != nums[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;删除排序数组中的重复项&quot;&gt;&lt;a href=&quot;#删除排序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;删除排序数组中的重复项&quot;&gt;&lt;/a&gt;删除排序数组中的重复项&lt;/h2&gt;&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-81-搜索旋转的排序数组II</title>
    <link href="http://yoursite.com/2019/12/05/leetcode-81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/"/>
    <id>http://yoursite.com/2019/12/05/leetcode-81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</id>
    <published>2019-12-05T09:54:56.000Z</published>
    <updated>2019-12-05T11:32:29.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索旋转的排序数组ii"><a href="#搜索旋转的排序数组ii" class="headerlink" title="搜索旋转的排序数组ii"></a>搜索旋转的排序数组ii</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p>示例 1:</p><p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true<br>示例 2:</p><p>输入: nums = [2,5,6,0,0,1,2], target = 3<br>输出: false<br>进阶:</p><p>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>变数是出现<strong>重复的数</strong>了</p><p>原本的思路是：</p><ul><li><p>如果 mid == target 直接返回</p></li><li><p>前半部有序（指的是[3,4,5,6,7,0,12]，中间划开前面是[3,4,5,6]有序，后边是[7,0,1,2]不完全有序）</p><ul><li>target落在有序序列，即left—-mid中，则查找这个范围所以right = mid-1</li><li>target落在无序序列，即mid—right中，则left = mid+1</li></ul></li><li>后半部有序（指的是[6,7,0,1,2,3,4,5],中间划开，前面是[6,7,0,1]不完全有序，后边是[2,3,4,5]有序）<ul><li>target落在无序序列，即left—-mid中，则查找这个范围所以right = mid-1</li><li>target落在有序序列，即mid—right中，则left = mid+1</li></ul></li></ul><p>当出现重复的数字，如果不出现在两端还好，没有影响</p><p>原本只需要判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:  <span class="comment"># 命中 返回</span></span><br><span class="line">    <span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt;= nums[left]:  <span class="comment"># mid的位置，mid落在前半部还是后半部</span></span><br><span class="line">    <span class="string">'''前半部有序的操作'''</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="string">'''后半部有序的操作'''</span></span><br></pre></td></tr></table></figure><p>但是对应有重复数的出现，可能会存在下面的情况，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left == mid == right </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] <span class="keyword">or</span> [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>此时分不清到底是前半部分有序还是后半部分有序，但是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left == mid == right 一定 != target</span><br></pre></td></tr></table></figure><p>因为我们先判断了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:  <span class="comment"># 命中 返回</span></span><br><span class="line"><span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure><p>既然左left右right 都不等，我们干脆往中间移动，去掉干扰项即可，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] <span class="number">1</span> <span class="keyword">or</span> <span class="number">5</span> [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="number">5</span></span><br></pre></td></tr></table></figure><p>操作之后，问题也就回到了我们熟悉的问题上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 不能确定哪一侧有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == nums[mid] == nums[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 在左侧序列，左侧是有序的</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt;= nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[left]&lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid <span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 在右侧序列，右侧是有序的</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;搜索旋转的排序数组ii&quot;&gt;&lt;a href=&quot;#搜索旋转的排序数组ii&quot; class=&quot;headerlink&quot; title=&quot;搜索旋转的排序数组ii&quot;&gt;&lt;/a&gt;搜索旋转的排序数组ii&lt;/h2&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>新聚思（Synnex）</title>
    <link href="http://yoursite.com/2019/12/04/Synnex/"/>
    <id>http://yoursite.com/2019/12/04/Synnex/</id>
    <published>2019-12-04T12:26:09.000Z</published>
    <updated>2019-12-04T12:28:47.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synnax实习总结"><a href="#synnax实习总结" class="headerlink" title="synnax实习总结"></a>synnax实习总结</h1><p>问题：</p><p>lr 推 还可以</p><p>svm推 …</p><p>xgboost 推…</p><p>编程：</p><p>kmeans  </p><p>堆排序</p><p>鸡蛋落地问题</p><p>概率题：  </p><p>圆上3点 构成锐角三角形的概率</p><p>spark  </p><p>完全阵亡</p><p>实际业务场景应用问题</p><p>文本分类 的全流程</p><p><strong>以上问题都是笔试题（是的我在现场笔试了一个小时）</strong></p><p>其他一些细节问题</p><p>transformer 的问题 每个细节问题 </p><p>mutil过程具体怎么操作的  </p><p>为啥除以dk</p><p>add 和norm 具体操作 为什么 有什么作用</p><p>decoder中 的mask Attention 怎么操作的</p><p>实习问题：</p><p>1.薪资问题  </p><p>实习薪资：保密 :smile_cat:</p><p>2.团队规模 </p><p>400人左右 其中it技术100多人， 算法团队20人这样吧</p><p>有transfer北美的机会</p><p>3.发展问题</p><p>工程师会需要有夜班嘛 对应时差 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;synnax实习总结&quot;&gt;&lt;a href=&quot;#synnax实习总结&quot; class=&quot;headerlink&quot; title=&quot;synnax实习总结&quot;&gt;&lt;/a&gt;synnax实习总结&lt;/h1&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;lr 推 还可以&lt;/p&gt;
&lt;p&gt;svm推 …&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="实习面试经验" scheme="http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>京东搜索排序面经-已过</title>
    <link href="http://yoursite.com/2019/12/04/%E4%BA%AC%E4%B8%9C%E6%90%9C%E7%B4%A2%E6%8E%92%E5%BA%8F%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2019/12/04/%E4%BA%AC%E4%B8%9C%E6%90%9C%E7%B4%A2%E6%8E%92%E5%BA%8F%E9%9D%A2%E7%BB%8F/</id>
    <published>2019-12-04T12:17:02.000Z</published>
    <updated>2019-12-05T15:21:06.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="京东搜索排序面经"><a href="#京东搜索排序面经" class="headerlink" title="京东搜索排序面经"></a>京东搜索排序面经</h2><h3 id="jd"><a href="#jd" class="headerlink" title="jd"></a>jd</h3><p>招聘岗位：算法实习生（能获得导师许可并保证至少6个月的实习）</p><p>工作地点：北辰世纪中心，位于北京朝阳区奥林匹克公园附近</p><p>【工作内容】</p><ol><li>基于京东海量的用户和商家数据，应用机器学习算法，优化搜索排序</li></ol><p>【任职要求】</p><ol><li><p>对机器学习、数据挖掘、深度学习等算法领域有研究热情和扎实的基础</p></li><li><p>计算机、数学及相关专业研究生、博士生</p></li><li><p>熟悉python、C++与Linux开发 </p></li><li><p>良好的沟通协调能力，较好的主动性和求知欲</p></li><li><p>熟悉tensorflow、pytorch、caffe等学习框架优先</p></li><li><p>熟悉强化学习及相关框架，或对其有强烈兴趣者优先</p></li></ol><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面：</p><p>主要是聊项目经历 说一下项目</p><p>基本套路 讲一下项目背景 讲一下项目的基本过程 讲一下其中的亮点  难点 与反思 </p><p>其实后边三个是更重要的  </p><p>问了神经网络防止过拟合的方法！！！</p><p>题目一： 从m个数中随机等概率抽取n个数（面试官让我实现random.choice）</p><p>题目二：找出一个数组中，超过一半的个数的元素</p><p><a href="https://mereder.github.io/2019/12/04/leetcode-169-多数元素/" target="_blank" rel="noopener">Leetcode-169-多数元素</a></p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>主要问我的都是算法点吧…</p><p>其中着重讲了神经网络的参数更新过程（前向传播，反向传播，要写链式求导）</p><p>Xgboost，让我手推一边，能推到哪里就写到哪里，然后讲一下整个表达式中的各个含义</p><p>笔试题目：</p><p><a href="https://mereder.github.io/2019/11/29/插入排序/" target="_blank" rel="noopener">插入排序</a></p><h3 id="三面交叉面"><a href="#三面交叉面" class="headerlink" title="三面交叉面"></a>三面交叉面</h3><p>来的面试官是这边做知识图谱的一位，全程都属于聊天状态。</p><p>抛给我的问题都算是思考类型的吧</p><p>笔试题目：给出括号的对数，问有多少种不同的排列方式</p><p><a href="https://mereder.github.io/2019/11/29/leetcode-22-括号生成" target="_blank" rel="noopener">Leetcode-22-括号生成</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;京东搜索排序面经&quot;&gt;&lt;a href=&quot;#京东搜索排序面经&quot; class=&quot;headerlink&quot; title=&quot;京东搜索排序面经&quot;&gt;&lt;/a&gt;京东搜索排序面经&lt;/h2&gt;&lt;h3 id=&quot;jd&quot;&gt;&lt;a href=&quot;#jd&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="实习面试经验" scheme="http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-169-多数元素</title>
    <link href="http://yoursite.com/2019/12/04/leetcode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/12/04/leetcode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</id>
    <published>2019-12-04T11:51:15.000Z</published>
    <updated>2019-12-04T12:06:04.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多数元素（超过数组一半的元素）"><a href="#多数元素（超过数组一半的元素）" class="headerlink" title="多数元素（超过数组一半的元素）"></a>多数元素（超过数组一半的元素）</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><blockquote><p>示例 1:</p><p>输入: [3,2,3]<br>输出: 3<br>示例 2:</p><p>输入: [2,2,1,1,1,2,2]<br>输出: 2</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解题方法有很多，最直观的一种就是计数呗，看哪个元素的总数和超过了数组的一半。这种方法就需要考虑用什么来存储计数的结果，当然hash是最好的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        hash=&#123;&#125;</span><br><span class="line">        n=len(nums)</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        max_count=n//<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(nums[i] <span class="keyword">not</span> <span class="keyword">in</span> hash):</span><br><span class="line">                hash[nums[i]]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash[nums[i]]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(hash[nums[i]]&gt;max_count):</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure><p>还有一种想法，直接排序，那中间位置的元素肯定是超过数组一半的那个，那这样又涉及到排序算法。最快就是</p><p>$nlogn$ 进而想到，其实我们不用完全将数组排好序，只要我们找到中间的那个位置的元素就可以了，如何做到呢？我们知道快排有个良好的特性：每一轮快排结束后，一个元素会被放到最终的位置上，那么我们根据这个特性，只需要找到位于中间位置的那个元素就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">          <span class="comment">#类似剪枝过程，如果mid不在范围内的一侧就不用去遍历了。</span></span><br><span class="line">            index = self.partition(nums,left,right)</span><br><span class="line">            <span class="keyword">if</span> index == mid:</span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">            <span class="keyword">elif</span> index &lt; mid:</span><br><span class="line">                left = index+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = index<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> nums[mid]</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 快排基础，用来找一次快排将某个元素确定的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self,nums,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        pivot = nums[right]</span><br><span class="line">        slow = left<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> slow != i:</span><br><span class="line">                    nums[i],nums[slow] = nums[slow],nums[i]</span><br><span class="line">        slow += <span class="number">1</span></span><br><span class="line">        nums[slow],nums[right] = pivot,nums[slow]</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><p><strong>更巧妙的办法</strong>：摩尔投票法</p><p>基本思想就是，占大多数的元素个数总和肯定比其他元素总和要高。</p><p>count来计数，对于重叠的元素++，对于不同的元素—，当count为0时需要重新选一个值作为计数的基础元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                res = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] == res:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多数元素（超过数组一半的元素）&quot;&gt;&lt;a href=&quot;#多数元素（超过数组一半的元素）&quot; class=&quot;headerlink&quot; title=&quot;多数元素（超过数组一半的元素）&quot;&gt;&lt;/a&gt;多数元素（超过数组一半的元素）&lt;/h2&gt;&lt;p&gt;给定一个大小为 n 的数组，找到其中
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-82-删除排序链表中的重复元素ii</title>
    <link href="http://yoursite.com/2019/12/04/leetcode-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/"/>
    <id>http://yoursite.com/2019/12/04/leetcode-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</id>
    <published>2019-12-04T06:15:31.000Z</published>
    <updated>2019-12-04T10:34:58.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除排序链表中的重复元素ii"><a href="#删除排序链表中的重复元素ii" class="headerlink" title="删除排序链表中的重复元素ii"></a>删除排序链表中的重复元素ii</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><blockquote><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5</p><p>示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>相比于easy题目<a href="">Leetcode-83-删除排序链表中的重复元素</a></p><p>本题的难度在于不仅仅要删除后边的重复数，连本位置的重复数也要删掉。</p><p>所以需要找到所有相同的数，然后进行链表的一次删除操作（排序链表，相同的数在一起，一次删除操作即可）。</p><p>简单的地方仍在于给的是排序链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 哑变量，方便处理头部删除 前一个题不需要是因为头部不会进行删除</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        p = dummy<span class="comment"># 作为有效链表的尾部，后边只会接上不重复的数</span></span><br><span class="line">        q = dummy.next<span class="comment"># 重复数的指针，如果有重复则会一直遍历到不重复的数或者None停止</span></span><br><span class="line">        <span class="keyword">while</span> q.next:</span><br><span class="line">            tmp = q.val</span><br><span class="line">            <span class="keyword">if</span> q.next.val == tmp: <span class="comment"># 存在重复情况，进入操作</span></span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> q.val == tmp: <span class="comment"># 不为空并且值重复</span></span><br><span class="line">                    q = q.next</span><br><span class="line">                p.next = q</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> q:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 前后两个数不重复，则继续向后遍历</span></span><br><span class="line">                p = p.next</span><br><span class="line">                q = q.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;删除排序链表中的重复元素ii&quot;&gt;&lt;a href=&quot;#删除排序链表中的重复元素ii&quot; class=&quot;headerlink&quot; title=&quot;删除排序链表中的重复元素ii&quot;&gt;&lt;/a&gt;删除排序链表中的重复元素ii&lt;/h2&gt;&lt;p&gt;给定一个排序链表，删除所有含有重复数字的节点
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-83-删除排序链表中的重复元素</title>
    <link href="http://yoursite.com/2019/12/04/leetcode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/12/04/leetcode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2019-12-04T06:09:48.000Z</published>
    <updated>2019-12-04T06:14:12.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><blockquote><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p></blockquote><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>双指针遍历，较为简单</p><p>重点是：排序链表，并且删除后还保留了一个基本的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        p = head</span><br><span class="line">        q = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">                p.next = q.next</span><br><span class="line">                q = p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                q = q.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#删除排序链表中的重复元素&quot; class=&quot;headerlink&quot; title=&quot;删除排序链表中的重复元素&quot;&gt;&lt;/a&gt;删除排序链表中的重复元素&lt;/h2&gt;&lt;p&gt;给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-73-矩阵置0</title>
    <link href="http://yoursite.com/2019/12/04/leetcode-73-%E7%9F%A9%E9%98%B5%E7%BD%AE0/"/>
    <id>http://yoursite.com/2019/12/04/leetcode-73-%E7%9F%A9%E9%98%B5%E7%BD%AE0/</id>
    <published>2019-12-03T16:30:12.000Z</published>
    <updated>2019-12-04T01:49:26.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵置0"><a href="#矩阵置0" class="headerlink" title="矩阵置0"></a>矩阵置0</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p><p>示例 1</p><blockquote><p>输入:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>输出:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]<br>示例 2:</p><p>输入:<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br>输出:<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]<br>进阶:</p><p>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。<br>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。<br>你能想出一个常数空间的解决方案吗？</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>限制算法的性能：时间复杂度$O(m*n)$空间复杂度$O(1)$</p><p>如果没有任何限制，这个题目其实会很简单，就是遍历，将找到的0所在行列都置为0，那样复杂度绝对不止m*n</p><p>当时想到的解法就是，两次遍历，每次的遍历都是m*n，那么最终还是m*n的时间复杂度。</p><p>只需要找到的0，将其所在行和所在列标识出来，怎么标识，就是通过矩阵的首行和首列来当我们的存储，把需要置为0的行的首位变为0，首列变为0 ，第二次遍历的时候，只需要遍历第一行将其中为0的所在列都置为0，再遍历第一列，将其中为0的所在行都置为0。</p><p>这时又出现一个问题，就是原本首行首列就有的0怎么办？由于只能用常数空间，所以考虑两个变量来标识出来首行首列是否原本就需要都置为0 的。</p><p>细节问题：对于矩阵遍历要从1开始，这样起到保护首行首列的作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        first_row = <span class="literal">False</span></span><br><span class="line">        first_col = <span class="literal">False</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                first_col = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                first_row = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_row:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_col:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;矩阵置0&quot;&gt;&lt;a href=&quot;#矩阵置0&quot; class=&quot;headerlink&quot; title=&quot;矩阵置0&quot;&gt;&lt;/a&gt;矩阵置0&lt;/h2&gt;&lt;p&gt;给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。&lt;/p&gt;
&lt;p&gt;示例
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>作业帮算法实习生面经——已过</title>
    <link href="http://yoursite.com/2019/12/03/%E4%BD%9C%E4%B8%9A%E5%B8%AE%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2019/12/03/%E4%BD%9C%E4%B8%9A%E5%B8%AE%E9%9D%A2%E7%BB%8F/</id>
    <published>2019-12-03T15:47:25.000Z</published>
    <updated>2019-12-03T15:50:57.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jd"><a href="#jd" class="headerlink" title="jd"></a>jd</h2><p>投递岗位</p><p>1、深入自然语言处理相关的核心技术研究，如对话系统、问答系统、阅读理解等NLP技术；</p><p>2、用机器学习/深度学习等技术解决分层模型、点击预估、流失预测等业务问题；</p><p>3、负责用户增长中的算法问题，提升约课、到课、转化、回捞等相关转化率；</p><p>4、将自然语言技术应用具体业务中，包括智能客服、催到课、用户意图分类等。</p><h2 id="一面："><a href="#一面：" class="headerlink" title="一面："></a>一面：</h2><p>写题：</p><p>1.旋转数组中找target （腾讯视频NLP二面题目） 面试官指导下磕磕绊绊写出来了，腾讯视频面试时候写出来是因为当时分开完成的，先写了找到断点的地方，然后再找target</p><p><a href="https://mereder.github.io/2019/11/18/leetcode-33/" target="_blank" rel="noopener">Leetcode-33-搜索选装数组</a></p><p>2.合并两个有序数组 easy</p><p>简单聊了聊项目 对于技术点没有深挖</p><h2 id="二面："><a href="#二面：" class="headerlink" title="二面："></a>二面：</h2><p>聊项目（前一段实习在网易的项目） 实现背景 实现策略（数据、算法） 实现结果</p><p>没有深挖技术点</p><p>思路题：</p><p>给了一个问题背景</p><p>护林员统计了一片森林的各种树的特征（树的种类啊 树的高度啊 树年龄 等等）</p><p>其中有一些数据的树高统计由于人为的失误导致数据异常，问如何检查异常的树高数据</p><p>当时的回答，就是离群点检测：</p><p>如何检测离群点，我给的方案是，首先可以做回归，比如给定一些基础特征，然后根据特征来预测树高</p><p>那么正常的值应该都在回归曲线附近，那么也需要一个超参数来衡量在什么范围内的数据是正常，什么范围外的数据是异常点</p><p>其次想到了对于异常点（离群点） 背景就是数据分布属于高斯分布的情况下，那么数据可以根据 </p><p>均值 +- n个标准差来做判断</p><p>==知识点待补充，如何来分析数据的离群点==</p><p>算法题：</p><p>给一个矩阵m*N，找从左上角到右下角的路径个数，其中会有一些路径是有障碍的 没有办法走过去。</p><p><a href="https://mereder.github.io/2019/12/03/leetcode-63-不同路径II/" target="_blank" rel="noopener">Leetcode-62-不同路径II</a></p><p>提问环节：</p><p>他们组主要做对话技术部分，之前的都已经搭好了，如果现在过去的话也是做基于分析badcase的解决提高对话的有效转化</p><p>聊了下这边的技术主要内容 他们月活大概 1.2亿 </p><p>业务的应用场景主要是 约课 和课程转化率</p><p>目前主要的操作都是自动化的， ASR 到信息理解 然后输出 语音内容，通过对话来帮助客户完成课程转化或者付费内容的购买。</p><p>主要涉及的是对话技术、内容理解、用户拉新 和 约课（课程）转化</p><p>最后面完通过hr的交流，大概我当时面的是对话技术组，就是通过推荐那边得到潜在转化客户，然后通过机器人电话对客户进行约课或者付费课的转化。基本都已经搭建完了，他们现在的大部分工作应该是在处理badcase，一些对话结果可能不是很好在做处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jd&quot;&gt;&lt;a href=&quot;#jd&quot; class=&quot;headerlink&quot; title=&quot;jd&quot;&gt;&lt;/a&gt;jd&lt;/h2&gt;&lt;p&gt;投递岗位&lt;/p&gt;
&lt;p&gt;1、深入自然语言处理相关的核心技术研究，如对话系统、问答系统、阅读理解等NLP技术；&lt;/p&gt;
&lt;p&gt;2、用机器学习/
      
    
    </summary>
    
    
      <category term="实习面试经验" scheme="http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>小米桌面信息流推荐算法面经——已过</title>
    <link href="http://yoursite.com/2019/12/03/%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2019/12/03/%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</id>
    <published>2019-12-03T15:44:54.000Z</published>
    <updated>2019-12-05T15:10:50.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小米桌面信息流推荐算法工程师"><a href="#小米桌面信息流推荐算法工程师" class="headerlink" title="小米桌面信息流推荐算法工程师"></a>小米桌面信息流推荐算法工程师</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>主要聊一下项目 （经典必问问题：项目背景，项目意义指标等，难点，亮点）</p><p>全流程推一边 xgboost 完事</p><p>写题： 将 一个m*n的矩阵中，有个别的数值为0，将0所在的行和列全都置为0.</p><p>基本方法就是 暴力解决， 遍历矩阵的时间复杂度就是O(m*n) 对于一个位置为0，将其行列置为0的时间复杂度是O(m+n)</p><p>但是面试官要求，时间复杂度为O(1)，所以需要考虑下</p><p>磕磕绊绊吧 最终没有完全写出来但是跟真正的解法已经很接近了</p><p>事后补充：<a href="https://mereder.github.io/2019/12/04/leetcode-73-矩阵置0/" target="_blank" rel="noopener">73. 矩阵置零</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        first_row = <span class="literal">False</span></span><br><span class="line">        first_col = <span class="literal">False</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                first_col = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                first_row = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_row:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_col:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>聊下项目</p><p>问下transformer 的结构 以及基本的理解</p><p>问下lr基本的内容</p><p>问下 除了bert这一种预训练词向量外 还有没有了解别的。</p><p>（这个地方有必要好好把word2vec、elmo、gpt这些重新学习下）</p><p>写题：</p><p>链表重复数删除，将一个单链表中，重复的数进行删除。</p><p><a href="https://mereder.github.io/2019/12/04/leetcode-82-删除排序链表中的重复元素ii/" target="_blank" rel="noopener">Leetcode-82-删除排序链表中的重复元素ii</a></p><p>交流下基本问题：</p><p>Dau1800W 桌面信息流 推荐上层在北京这边，内容理解在武汉。他们主要做推荐侧…</p><p>其实我个人觉得小米这边对于自己学技术来说这边还是蛮合适的，尤其是晓伟哥跟我说，推荐的技术要比搜索更复杂一些的时候，觉得最后选择京东搜索排序那边可能并不是一个最好的选择吧？….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;小米桌面信息流推荐算法工程师&quot;&gt;&lt;a href=&quot;#小米桌面信息流推荐算法工程师&quot; class=&quot;headerlink&quot; title=&quot;小米桌面信息流推荐算法工程师&quot;&gt;&lt;/a&gt;小米桌面信息流推荐算法工程师&lt;/h2&gt;&lt;h3 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot;
      
    
    </summary>
    
    
      <category term="实习面试经验" scheme="http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-3-无重复字符的最长子串</title>
    <link href="http://yoursite.com/2019/12/03/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/12/03/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2019-12-03T12:38:13.000Z</published>
    <updated>2019-12-03T14:47:38.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><strong>滴滴算法工程师（EP组没记错的话  hhh）一面面试题目</strong></p><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p> 输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p> 输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个破题，前后看了好几遍才理解了最优解法的意义。</p><p>这里面主要是利用滑动窗口机制，那么还需要使用几个辅助变量来帮助实现这个思想</p><blockquote><p>d: 是一个字典用来存放&lt;字符,最后一次的位置&gt; 这个一方面 方便我们来查找重复字符 另一方面方便确认两个重复字符直接的距离</p><p>start: 是 我们找到的无重复字符串的开始</p><p>end：是我们找到的无重复字符串的结尾，同时也是遍历字符串的指针</p><p>mx：存储最长无重复字符串的长度</p></blockquote><p>无重复字符串的长度计算即:$end-start+1$</p><p>end是不断再向后走的，我们需要判断的是start应该放在什么位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s[end] <span class="keyword">in</span> d:</span><br><span class="line">  start = max(d[char]+<span class="number">1</span>,start)</span><br></pre></td></tr></table></figure><ul><li><p>查看当前字符是否重复，如果重复再看是否在 无重复串中间：</p></li><li><p>如果 在 无重复串中间 即 start &lt; d[char] 需要更新无重复字符串的开始位置为 d[char]+1</p></li><li><p>如果 不在 无重复串中间，即 start &gt; d[char] 那么当前字符不会对我们的无重复字符串产生影响</p></li><li><p>相当于重新定义了 无重复字符串的开始位置，方便后边计算无重复字符串的长度</p></li></ul><blockquote><p>举个例子：</p><p>abcdc  当遍历到第二个c时，原本的无重复串为abcd ，此时重复字符c是在重复串中间的，那么需要更新我们的窗口，将start从a的下标调整到前一个c的下标+1</p><p>再举个例子</p><p>abcdba 接着上一个分析，当经过第二个b之后，无重复子串被置为 cdb，当处理最后一个a时，尽管前面有重复的a但是对于我们的无重复子串是没有影响的，可以直接加上，变成cdba。</p><p>每次更新start位置之后，无重复字符串长度为end-start+1，不一定都能得到最长的，所以每次都需要再跟max做个比较</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        d = &#123;&#125;  <span class="comment"># 记录字符以及字符最后一次出现的位置</span></span><br><span class="line">        mx = <span class="number">0</span>  <span class="comment"># 记录最长的长度</span></span><br><span class="line">        start = <span class="number">0</span> <span class="comment"># 记录无重复字符串的开始位置</span></span><br><span class="line">        end = <span class="number">0</span>  <span class="comment"># 记录无重复字符串的结束位置</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; len(s): <span class="comment"># 遍历字符串</span></span><br><span class="line">            char = s[end]  <span class="comment"># 当前字符串</span></span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">in</span> d:</span><br><span class="line">                <span class="comment"># 查看当前字符是否重复，如果重复再看是否在 无重复串中间：</span></span><br><span class="line">                <span class="comment"># 如果 在 无重复串中间 即 start &lt; d[char] 需要更新无重复字符串的开始位置为 d[char]+1</span></span><br><span class="line">                <span class="comment"># 如果 不在 无重复串中间，即 start &gt; d[char] 那么当前字符不会对我们的无重复字符串产生影响</span></span><br><span class="line">                <span class="comment"># 相当于重新定义了 无重复字符串的开始位置，方便后边计算无重复字符串的长度</span></span><br><span class="line">                start = max(d[char]+<span class="number">1</span>,start)</span><br><span class="line">            </span><br><span class="line">            mx = max(mx,end-start+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 更新我的字典中，字符的位置信息</span></span><br><span class="line">            d[char] = end</span><br><span class="line">            end+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;滴滴算法工程师（EP组没记错的话  hhh）一面面试题目&lt;/
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-63-不同路径II</title>
    <link href="http://yoursite.com/2019/12/03/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://yoursite.com/2019/12/03/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</id>
    <published>2019-12-03T04:29:47.000Z</published>
    <updated>2019-12-03T09:36:03.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2><p><strong>作业帮算法实习生二面面试题</strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jfbb1hcej30b4053gll.jpg" alt="img"></p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><blockquote><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><p>1.向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</p><p>2.向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p></blockquote><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>机器人走路问题，还是用动态规划来解决，最基本的动态规划递归状态是</p><script type="math/tex; mode=display">当前路径数 = 左侧格子路径+上边格子路径 \\n_{i,j} = n_{i,j-1} + n_{i-1,j} \\dp[i][j] = dp[i][j-1] + dp[i-1][j]</script><p>这个题有特殊的要求，存在障碍那么就需要对障碍点进行下判断：</p><ul><li>第一步就是障碍点： 直接返回0</li><li>第一列或者第一行存在障碍点 那么后继的都应该为0</li><li>其他情况的障碍点 只需要存在就令该位置对应dp为0</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment"># 特殊情况，起始位置就是障碍则为0 否则为1</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># dp空间初始化进行赋值 第一行    </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># dp 空间初始化进行赋值 第一列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 其他情况 需要进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment"># 遇到障碍 dp = 0</span></span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">               <span class="comment"># 非障碍，根据情况进行dp[i][j]的赋值</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> dp[i<span class="number">-1</span>][j] == <span class="number">0</span> <span class="keyword">and</span> dp[i][j<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i<span class="number">-1</span>][j] == <span class="number">0</span> <span class="keyword">or</span> dp[i][j<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不同路径II&quot;&gt;&lt;a href=&quot;#不同路径II&quot; class=&quot;headerlink&quot; title=&quot;不同路径II&quot;&gt;&lt;/a&gt;不同路径II&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;作业帮算法实习生二面面试题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个机器人位于一个 m x n 
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-53-最大子序和</title>
    <link href="http://yoursite.com/2019/12/01/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://yoursite.com/2019/12/01/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</id>
    <published>2019-12-01T08:41:00.000Z</published>
    <updated>2019-12-01T16:32:46.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><blockquote><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p></blockquote><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>基本方法动态规划，动态规划就是求最值过程，其中每一个元素都面临着两种选择，要还是不要，对应dp过程：</p><blockquote><p>dp[i] = max(dp[i-1]+nums[i],num[i])</p></blockquote><p>最终结果是，dp数组中结果最大的那个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        // 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span><br><span class="line">        int result = INT_MIN;</span><br><span class="line">        int numsSize = int(nums.size());</span><br><span class="line">        // dp[i]表示nums中以nums[i]结尾的最大子序和</span><br><span class="line">        vector&lt;int&gt; dp(numsSize);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        result = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            result = max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h4><p>贪心算法就是思考每一步我的选择都是最优的，如果i之前的和为正数，那么可以继续连续和，则加上nums[i]。如果之前的和已经为负数了，那么没有必要继续连续，到i位置，我们重新定义连续和为nums[i]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">                tmp += data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = data</span><br><span class="line">            ans = max(ans,tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>使用更为精妙的分治法来求解</p><p>思路就是，求一个数组的最大连续和，可以转化为求左侧数组最大子序列和，求右侧数组最大子序列和，<strong>求跨过分界点的连续子序列</strong>，这样问题就被分治化解了。重点就是如何求跨过分界点的连续子序列和</p><p>Ps:这个思路可以了解下，但是解这道题来说，真的是时间空间都不够好</p><p>时间复杂度$O(nlogn)$，空间复杂度$O(logn)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.helper1(nums,<span class="number">0</span>,n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper1</span><span class="params">(self, nums, left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        </span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        left_res = self.helper1(nums,left,mid)</span><br><span class="line">        right_res = self.helper1(nums,mid+<span class="number">1</span>,right)</span><br><span class="line">        cross_res = self.helper2(nums,left,mid,right)</span><br><span class="line"></span><br><span class="line">        res = max(left_res,right_res,cross_res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper2</span><span class="params">(self,nums,left,mid,right)</span>:</span></span><br><span class="line">        res_left = -np.inf</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从中间向前</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid,left<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            tmp += nums[i]</span><br><span class="line">            res_left = max(tmp,res_left)</span><br><span class="line"></span><br><span class="line">        res_right = -np.inf</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从中间向后</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid+<span class="number">1</span>,right+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">            tmp += nums[i]</span><br><span class="line">            res_right = max(tmp,res_right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res_left+res_right</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最大子序和&quot;&gt;&lt;a href=&quot;#最大子序和&quot; class=&quot;headerlink&quot; title=&quot;最大子序和&quot;&gt;&lt;/a&gt;最大子序和&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2019/12/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/12/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2019-11-30T16:42:20.000Z</published>
    <updated>2019-12-01T16:39:52.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基于分治思想的排序算法，稳定的排序算法，时间复杂度$O(NlogN)$，空间复杂度为$O(N)$（需要一个备份数字来进行存储）。</p><p>排序算法的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergreSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment"># 迭代终止条件</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len(nums) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment"># 分治过程 不断划分</span></span><br><span class="line">    left = mergreSort(nums[:mid])</span><br><span class="line">    right = mergreSort(nums[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 核心操作：比较左右两个数组，将比较小的先加入备份数字</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt;= right[r]:</span><br><span class="line">            res.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left):</span><br><span class="line">        res.append(left[l])</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> r &lt; len(right):</span><br><span class="line">        res.append(right[r])</span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a =[<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">    print(a)</span><br><span class="line">    res = mergreSort(a)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>最基础的应用，求逆序对数。</p><p>基本思想就是：左边的都是小于右边的，那么逆序对数就是右边的一个对应左边每一个。</p><p>在merge过程就可以进行计数</p><p>举个例子：</p><blockquote><p>[1,3,5],[2,4,6]</p><p>左侧序列的5可以组成的逆序对有(5,2)(5,4)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;p&gt;基于分治思想的排序算法，稳定的排序算法，时间复杂度$O(NlogN)$，空间复杂度为$O(N)$（需要一个备份数字来进行存储
      
    
    </summary>
    
    
      <category term="算法基础" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-222-完全二叉树的节点个数</title>
    <link href="http://yoursite.com/2019/12/01/leetcode-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2019/12/01/leetcode-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</id>
    <published>2019-11-30T16:22:55.000Z</published>
    <updated>2019-11-30T16:29:39.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h2><p>给出一个完全二叉树，求出该树的节点个数。</p><p>说明：</p><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / \  /</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始想法是，计算完全二叉树的节点个数是有技巧的，根据其最后一层的深度以及最后一层的叶子节点个数，是可以计算出完全二叉树的节点个数的。</p><blockquote><p>若最后一层深度为d，最后一层节点个数为N</p><p>$ total = 2^{d-1}-1+N$</p></blockquote><p>但是想到我都能遍历到叶子节点了，肯定也能遍历叶子节点上面的其他节点了，所以我只需要遍历一遍二叉树，就知道我的树节点个数了-_-！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><p>解法简单粗暴</p><p>优化解法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;完全二叉树的节点个数&quot;&gt;&lt;a href=&quot;#完全二叉树的节点个数&quot; class=&quot;headerlink&quot; title=&quot;完全二叉树的节点个数&quot;&gt;&lt;/a&gt;完全二叉树的节点个数&lt;/h2&gt;&lt;p&gt;给出一个完全二叉树，求出该树的节点个数。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-117-填充每个节点的下一个右侧节点指针 II</title>
    <link href="http://yoursite.com/2019/12/01/leetcode-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/"/>
    <id>http://yoursite.com/2019/12/01/leetcode-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/</id>
    <published>2019-11-30T16:11:42.000Z</published>
    <updated>2019-11-30T16:17:24.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="填充每个节点的下一个右侧节点指针ii"><a href="#填充每个节点的下一个右侧节点指针ii" class="headerlink" title="填充每个节点的下一个右侧节点指针ii"></a>填充每个节点的下一个右侧节点指针ii</h2><p>给定一个二叉树</p><blockquote><p>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}</p></blockquote><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><blockquote><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p></blockquote><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>参考题目<a href="https://mereder.github.io/2019/11/27/leetcode-116-填充每个节点的下一个右侧节点指针/" target="_blank" rel="noopener">Leetcode-116-填充每个节点的下一个右侧节点指针</a></p><p>自己的解法还是依靠于层次遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            cur -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>,nxt):</span><br><span class="line">                    queue[index<span class="number">-1</span>].next = queue[index]</span><br><span class="line">                cur = nxt</span><br><span class="line">                nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;填充每个节点的下一个右侧节点指针ii&quot;&gt;&lt;a href=&quot;#填充每个节点的下一个右侧节点指针ii&quot; class=&quot;headerlink&quot; title=&quot;填充每个节点的下一个右侧节点指针ii&quot;&gt;&lt;/a&gt;填充每个节点的下一个右侧节点指针ii&lt;/h2&gt;&lt;p&gt;给定一个二叉
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2019/11/29/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/11/29/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2019-11-29T15:32:26.000Z</published>
    <updated>2019-12-05T15:16:48.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>基础排序算法之一，也是基于交换的排序方案</p><p>时间复杂度是$O(N^2)$</p><p>当然有可以优化的点，就是当一次插入中，没有跟  有序部分最后一个发生交换的话，可以直接退出当前循环了，继续去操作下一个数值</p><p>算法实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">        flag = <span class="literal">False</span> <span class="comment"># 优化地方</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">0</span>,<span class="number">-1</span>): <span class="comment"># j=i开始，向j=0 遍历</span></span><br><span class="line">            <span class="keyword">if</span> nums[j<span class="number">-1</span>] &gt; nums[j]:</span><br><span class="line">                nums[j<span class="number">-1</span>],nums[j] = nums[j],nums[j<span class="number">-1</span>]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag: <span class="comment"># 未发生交换</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">    insertSort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;p&gt;基础排序算法之一，也是基于交换的排序方案&lt;/p&gt;
&lt;p&gt;时间复杂度是$O(N^2)$&lt;/p&gt;
&lt;p&gt;当然有可以优化的点，就是
      
    
    </summary>
    
    
      <category term="算法基础" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-22-括号生成</title>
    <link href="http://yoursite.com/2019/11/29/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2019/11/29/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2019-11-29T15:18:25.000Z</published>
    <updated>2019-12-05T15:24:14.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p><strong>京东搜索排序实习生面试——三面试题</strong></p><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><blockquote><p>[“((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”]</p></blockquote><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>面试当时这个题实际上是没有正确的搞出来的，当时的大概思路是，我可以对括号进行全排列（类似字母组合排列的那个），然后对生成的每一次结果进行判断，如果符合括号规则就是正确的，如果不符合就不保留</p><p>（当时交叉面，只让我提了下思路，回leetcode惊人的发现这个题的暴力解法就是这样，不过怎样递归生成一个串，确实没有写出来）</p><p>面试官提示，这个题是可以通过dfs来解决的。（然并卵…..）</p><p>==正题==</p><h4 id="方法一-暴力解法"><a href="#方法一-暴力解法" class="headerlink" title="方法一 暴力解法"></a>方法一 暴力解法</h4><p>正如上边说的，我先去考虑如何生成，然后对生成的序列做判断，来判断是否有效，有效就加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(A = [])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(A) == <span class="number">2</span>*n:</span><br><span class="line">                <span class="keyword">if</span> valid(A):</span><br><span class="line">                    ans.append(<span class="string">""</span>.join(A))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.append(<span class="string">'('</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line">                A.append(<span class="string">')'</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(A)</span>:</span></span><br><span class="line">            bal = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">'('</span>: bal += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: bal -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bal &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> bal == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        generate()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="方法二-深度优先搜索"><a href="#方法二-深度优先搜索" class="headerlink" title="方法二 深度优先搜索"></a>方法二 深度优先搜索</h4><p>看解法里面大家也管这个过程叫回溯，没想明白回溯体现在哪里。</p><p>重点来了！！！</p><p>leetcode大佬的分析图：<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/" target="_blank" rel="noopener">回溯算法（深度优先遍历）+ 广度优先遍历 + 动态规划</a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9fcqtixz8j31hc0u0q9e.jpg" alt="LeetCode 第 22 题：“括号生出”题解配图.png"></p><p>对于自己来说，真的是一图胜千言，看了这个图就明白是怎么回事了。</p><p>方法一是不断的生成，生成很多个叶子节点，但是大部分都是无效的，但是采用的是”后剪枝“</p><p>那我干嘛不在生成的过程中就考虑下合法性呢？ 相当于”预剪枝“</p><p>下面解法我觉得巧妙的地方应该是<strong>left和right 两个变量</strong>的利用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        left = n</span><br><span class="line">        right = n</span><br><span class="line">        self.dfs(<span class="string">''</span>,left,right,res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, string, left,right,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right ==<span class="number">0</span>:</span><br><span class="line">            res.append(string)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span>: <span class="comment"># 对于不满足的情况不在进行遍历</span></span><br><span class="line">            self.dfs(string+<span class="string">'('</span>, left<span class="number">-1</span>,right,res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:  <span class="comment"># 对于不满足的情况不在进行遍历</span></span><br><span class="line">            self.dfs(string+<span class="string">')'</span>,left,right<span class="number">-1</span>,res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;括号生成&quot;&gt;&lt;a href=&quot;#括号生成&quot; class=&quot;headerlink&quot; title=&quot;括号生成&quot;&gt;&lt;/a&gt;括号生成&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;京东搜索排序实习生面试——三面试题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出 n 代表生成括号的对数，请你写出一
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
</feed>
