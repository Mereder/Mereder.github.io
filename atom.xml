<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Mereder</title>
  
  <subtitle>珍惜现在，感谢所有，不悔将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-26T07:45:39.615Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meng Di</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础算法/股票问题</title>
    <link href="http://yoursite.com/2020/07/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/07/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-26T07:37:09.358Z</published>
    <updated>2020-07-26T07:45:39.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="仅一次交易"><a href="#仅一次交易" class="headerlink" title="仅一次交易"></a>仅一次交易</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_val = float(<span class="string">'inf'</span>)</span><br><span class="line">        max_pro = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_val = min(price,min_val)</span><br><span class="line">            max_pro = max(max_pro,price-min_val)       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_pro</span><br></pre></td></tr></table></figure><h3 id="无限制交易"><a href="#无限制交易" class="headerlink" title="无限制交易"></a>无限制交易</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 贪心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt;= prices[i<span class="number">-1</span>]:</span><br><span class="line">                total+=prices[i]-prices[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure><h3 id="仅限制2笔"><a href="#仅限制2笔" class="headerlink" title="仅限制2笔"></a>仅限制2笔</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int T_i20 = <span class="number">0</span>;</span><br><span class="line">        int T_i21 = Integer.MIN_VALUE;</span><br><span class="line">        int T_i10 = <span class="number">0</span>;</span><br><span class="line">        int T_i11 = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            T_i20 = Math.max(T_i20,T_i21+prices[i]);</span><br><span class="line">            T_i21 = Math.max(T_i21,T_i10-prices[i]);</span><br><span class="line">            T_i10 = Math.max(T_i10,T_i11+prices[i]);</span><br><span class="line">            T_i11 = Math.max(T_i11,-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T_i20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K笔交易"><a href="#K笔交易" class="headerlink" title="K笔交易"></a>K笔交易</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices <span class="keyword">or</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时，也可以直接把超大的k替换为数组的一半，就不用写额外的贪心算法函数</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; n//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.greedy(prices)</span><br><span class="line">        </span><br><span class="line">        dp, res = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], []</span><br><span class="line">        <span class="comment"># dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票</span></span><br><span class="line">        <span class="comment"># 设定在卖出时加1次交易次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>], dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> j:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="comment"># 「所有交易次数最后一天不持有股票」的集合的最大值即为问题的解</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            res.append(dp[n<span class="number">-1</span>][m][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理k过大导致超时的问题，用贪心解决</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greedy</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                res += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="含冷冻期"><a href="#含冷冻期" class="headerlink" title="含冷冻期"></a>含冷冻期</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;仅一次交易&quot;&gt;&lt;a href=&quot;#仅一次交易&quot; class=&quot;headerlink&quot; title=&quot;仅一次交易&quot;&gt;&lt;/a&gt;仅一次交易&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>项目总结/QLQ用户体验</title>
    <link href="http://yoursite.com/2020/07/25/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/QLQ%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2020/07/25/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/QLQ%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/</id>
    <published>2020-07-25T03:58:08.591Z</published>
    <updated>2020-07-25T04:03:16.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Situations"><a href="#Situations" class="headerlink" title="Situations"></a>Situations</h3><p>由于历史演变原因，系统在线qlq暴露出来很多问题不能很好的满足凤巢新的用户体验标准对建模的要求：</p><ul><li>不能形成良好的客户优化良性互动</li><li>过度依赖广告创意维度特征，落地页引入严重不足，不能满足其建模的物理意义。</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Situations&quot;&gt;&lt;a href=&quot;#Situations&quot; class=&quot;headerlink&quot; title=&quot;Situations&quot;&gt;&lt;/a&gt;Situations&lt;/h3&gt;&lt;p&gt;由于历史演变原因，系统在线qlq暴露出来很多问题不能很好的满足凤巢新的用户体
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>激活函数</title>
    <link href="http://yoursite.com/2020/07/25/ML/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/07/25/ML/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-25T02:03:00.346Z</published>
    <updated>2020-07-25T02:30:03.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要用激活函数"><a href="#为什么要用激活函数" class="headerlink" title="为什么要用激活函数"></a>为什么要用激活函数</h3><p>对于深度学习中的神经网络，如何没有非线性激活函数，那么再深的网络也是退化到线性关系的。举例说明：</p><script type="math/tex; mode=display">无激活函数 \\F(x) = w_3(w_2(w_1x+b_1)+b_2)+b_3... \\展开即为： \\F(x) = w_3w_2w_1x + w_3w_2b_1+w_3b_2+b_3</script><h3 id="各个激活函数以及其导数"><a href="#各个激活函数以及其导数" class="headerlink" title="各个激活函数以及其导数"></a>各个激活函数以及其导数</h3><p>sigmoid：</p><script type="math/tex; mode=display">f(z) = \frac{1}{1+e^{-wx+b}} = \frac{e^{wx+b}}{1+e^{wx+b}} \\导数为： f(z)^{’} = f(z)(1-f(z))</script><h3 id="各个激活函数的优缺点"><a href="#各个激活函数的优缺点" class="headerlink" title="各个激活函数的优缺点"></a>各个激活函数的优缺点</h3><p>sigmoid 和 tanx 都是 中心附近增速快 ，两端增速慢。</p><p>导致</p><p>导致的问题就是 容易发生梯度爆炸和梯度消失，</p><p>relu 解决了梯度爆炸问题，但是引入了dead node 的问题，就是因为 负数部分无法激活，一旦参数进入了负数 该节点死掉。</p><p>所以有了 leaky relu，也就是让负数部分不完全无激活，而是给定了一个斜率较小的 激活方式。</p><p>以及 gelu，leaky relu 需要人工去调整负数区域激活的情况，所以gelu 使用用参数来去调整，让其学习。</p><h3 id="激活函数使用场景"><a href="#激活函数使用场景" class="headerlink" title="激活函数使用场景"></a>激活函数使用场景</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么要用激活函数&quot;&gt;&lt;a href=&quot;#为什么要用激活函数&quot; class=&quot;headerlink&quot; title=&quot;为什么要用激活函数&quot;&gt;&lt;/a&gt;为什么要用激活函数&lt;/h3&gt;&lt;p&gt;对于深度学习中的神经网络，如何没有非线性激活函数，那么再深的网络也是退化到线性关系的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-655-输出二叉树</title>
    <link href="http://yoursite.com/2020/07/01/Leetcode/leetcode-655-%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/01/Leetcode/leetcode-655-%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-06-30T17:29:46.000Z</published>
    <updated>2020-06-30T17:33:43.729Z</updated>
    
    <content type="html"><![CDATA[<h3 id="655-输出二叉树"><a href="#655-输出二叉树" class="headerlink" title="655 输出二叉树"></a>655 输出二叉树</h3><p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p><p>行数 m 应当等于给定二叉树的高度。<br>列数 n 应当总是奇数。<br>根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。<br>每个未使用的空间应包含一个空的字符串””。<br>使用相同的规则输出子树。<br>示例 1:</p><p>输入:<br>     1<br>    /<br>   2<br>输出:<br>[[“”, “1”, “”],<br> [“2”, “”, “”]]<br>示例 2:</p><p>输入:<br>     1<br>    / \<br>   2   3<br>    \<br>     4<br>输出:<br>[[“”, “”, “”, “1”, “”, “”, “”],<br> [“”, “2”, “”, “”, “”, “3”, “”],<br> [“”, “”, “4”, “”, “”, “”, “”]]<br>示例 3:</p><p>输入:<br>      1<br>     / \<br>    2   5<br>   /<br>  3<br> /<br>4<br>输出:<br>[[“”,  “”,  “”, “”,  “”, “”, “”, “1”, “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“”,  “”,  “”, “2”, “”, “”, “”, “”,  “”,  “”,  “”,  “5”, “”, “”, “”]<br> [“”,  “3”, “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“4”, “”,  “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]]<br>注意: 二叉树的高度在范围 [1, 10] 中。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目不难，都是跟树相关的基础知识</p><ul><li>求树高</li><li>根据树高求满二叉树节点个数</li><li>递归先序遍历 填槽（有分治思想在里面）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printTree</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 1. 求树高</span></span><br><span class="line">        depth = self.depth(root)</span><br><span class="line">        m = depth</span><br><span class="line">        <span class="comment"># 2. 观察题目，列就是 满二叉树的所有节点个数</span></span><br><span class="line">        n = <span class="number">2</span>**depth<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 3。 初始化结果集， 先序遍历填</span></span><br><span class="line">        res = [[<span class="string">""</span>]*(n) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment"># 4. 带左右边界的 先序遍历</span></span><br><span class="line">        self.helper(res, <span class="number">0</span>, <span class="number">0</span>, n, root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, res, depth, left, right, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        res[depth][mid] = str(root.val)</span><br><span class="line">        <span class="comment"># 有种分治的感觉</span></span><br><span class="line">        self.helper(res, depth+<span class="number">1</span>, left, mid<span class="number">-1</span>, root.left)</span><br><span class="line">        self.helper(res, depth+<span class="number">1</span>, mid+<span class="number">1</span>, right, root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left = self.depth(root.left)</span><br><span class="line">        right = self.depth(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;655-输出二叉树&quot;&gt;&lt;a href=&quot;#655-输出二叉树&quot; class=&quot;headerlink&quot; title=&quot;655 输出二叉树&quot;&gt;&lt;/a&gt;655 输出二叉树&lt;/h3&gt;&lt;p&gt;在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：&lt;/p&gt;
&lt;p&gt;行数 
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-739-每日温度</title>
    <link href="http://yoursite.com/2020/07/01/Leetcode/leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>http://yoursite.com/2020/07/01/Leetcode/leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</id>
    <published>2020-06-30T17:07:51.000Z</published>
    <updated>2020-06-30T17:08:54.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739 每日温度"></a>739 每日温度</h3><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p><strong>单调栈</strong></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> T:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        n  = len(T)</span><br><span class="line">        res = [<span class="number">0</span>]*n</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[i] &gt; T[stack[<span class="number">-1</span>]]:</span><br><span class="line">                top = stack.pop()</span><br><span class="line">                res[top] = i - top</span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;739-每日温度&quot;&gt;&lt;a href=&quot;#739-每日温度&quot; class=&quot;headerlink&quot; title=&quot;739 每日温度&quot;&gt;&lt;/a&gt;739 每日温度&lt;/h3&gt;&lt;p&gt;请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>树的基本操作</title>
    <link href="http://yoursite.com/2020/07/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>http://yoursite.com/2020/07/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2020-06-30T16:42:19.000Z</published>
    <updated>2020-07-26T07:21:56.418Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>使用栈来存放数据，但是栈内数据是单调的，以完成某种要求下的最优值</p><p>一般单调栈存储下标，</p><h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><ul><li><h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4><blockquote><p>单调递增栈  栈内存放下标 出栈时 计算 宽度和广度</p></blockquote></li><li><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h4><p>单调递减栈，遇到较大则进行操作，否则进栈</p></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;使用栈来存放数据，但是栈内数据是单调的，以完成某种要求下的最优值&lt;/p&gt;
&lt;p&gt;一般单调栈存储下标，&lt;/p&gt;
&lt;h3 id=&quot;典型例题&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
      <category term="单调栈" scheme="http://yoursite.com/categories/Leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>python/生成器</title>
    <link href="http://yoursite.com/2020/05/22/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2020/05/22/python/%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2020-05-22T10:18:32.868Z</published>
    <updated>2020-05-22T10:19:11.628Z</updated>
    
    <content type="html"><![CDATA[<p>yield 关键字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">  print()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;yield 关键字&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算广告/基本资料</title>
    <link href="http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E5%9F%BA%E6%9C%AC%E8%B5%84%E6%96%99/"/>
    <id>http://yoursite.com/2020/05/07/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E5%9F%BA%E6%9C%AC%E8%B5%84%E6%96%99/</id>
    <published>2020-05-07T15:56:47.035Z</published>
    <updated>2020-05-07T15:57:05.975Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/8c591feb9fc4" target="_blank" rel="noopener">https://www.jianshu.com/p/8c591feb9fc4</a></p><p><a href="https://cloud.tencent.com/developer/article/1132251" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1132251</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/8c591feb9fc4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/8c591feb9fc4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-152-乘积最大数组</title>
    <link href="http://yoursite.com/2020/04/13/Leetcode/leetcode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/04/13/Leetcode/leetcode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E6%95%B0%E7%BB%84/</id>
    <published>2020-04-12T17:09:29.000Z</published>
    <updated>2020-04-12T17:15:32.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考虑负数出现的情况，使用cur_max 和cur_min分别记录最大值和最小值。如果有负数情况，最小值会是负的。</p></blockquote><h2 id="乘积最大数组"><a href="#乘积最大数组" class="headerlink" title="乘积最大数组"></a>乘积最大数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。</p><p>示例 1:</p><p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p><p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        cur_max = <span class="number">0</span></span><br><span class="line">        cur_min = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                cur_max,cur_min = cur_min,cur_max</span><br><span class="line">            cur_max = max(cur_max*nums[i],nums[i])</span><br><span class="line">            cur_min = min(cur_min*nums[i],nums[i])</span><br><span class="line">            res = max(res,cur_max)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        cur_max = <span class="number">0</span></span><br><span class="line">        cur_min = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            t = cur_max</span><br><span class="line">            cur_max = max(cur_max*nums[i],nums[i],cur_min*nums[i])</span><br><span class="line">            cur_min = min(cur_min*nums[i],nums[i],t*nums[i])</span><br><span class="line">            res = max(res,cur_max)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;考虑负数出现的情况，使用cur_max 和cur_min分别记录最大值和最小值。如果有负数情况，最小值会是负的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;乘积最大数组&quot;&gt;&lt;a href=&quot;#乘积最大数组&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-57-插入区间</title>
    <link href="http://yoursite.com/2020/04/13/Leetcode/leetcode-57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2020/04/13/Leetcode/leetcode-57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</id>
    <published>2020-04-12T17:09:29.000Z</published>
    <updated>2020-04-12T17:09:40.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入区间"><a href="#插入区间" class="headerlink" title="插入区间"></a>插入区间</h2><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p>示例 1:</p><p>输入: intervals = [[1,3],[6,9]], newInterval = [2,5]<br>输出: [[1,5],[6,9]]<br>示例 2:</p><p>输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>输出: [[1,2],[3,10],[12,16]]<br>解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/insert-interval" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-interval</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>重点是找到重合的区域：</p><blockquote><p>重合的区域，那就有 待插入区间的左侧在 某个区间内部，</p><p>待插入区间的右侧在某个区间内部。</p><p>问题转化为去找两个满足条件的区间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">while</span> cur &lt; n <span class="keyword">and</span> newInterval[<span class="number">0</span>] &gt; intervals[cur][<span class="number">1</span>]:</span><br><span class="line">        ...</span><br><span class="line">        cur += <span class="number">1</span></span><br><span class="line">如果待插入的区间最左侧大于区间的右侧，那么就下一个，直到找到存在相交的区间</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">while</span> cur &lt; n <span class="keyword">and</span> newInterval[<span class="number">1</span>] &gt;= intervals[cur][<span class="number">0</span>]:</span><br><span class="line">        ...</span><br><span class="line">基本原理同上。</span><br></pre></td></tr></table></figure><p>对于找到的重合区间怎么做呢，所以找这些所有重合区间的最左端 和 最右端，合并为一个区间</p><p>所以使用了一个 临时变量 $tmp  = [newInterval[0],newInterval[1]]$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        n = len(intervals)</span><br><span class="line"><span class="comment"># cur 跳出时候 指向的正是 相交的区间</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt; n <span class="keyword">and</span> newInterval[<span class="number">0</span>] &gt; intervals[cur][<span class="number">1</span>]:</span><br><span class="line">            res.append(intervals[cur])</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        tmp = [newInterval[<span class="number">0</span>],newInterval[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur &lt; n <span class="keyword">and</span> newInterval[<span class="number">1</span>] &gt;= intervals[cur][<span class="number">0</span>]:</span><br><span class="line">            tmp[<span class="number">0</span>] = min(intervals[cur][<span class="number">0</span>],tmp[<span class="number">0</span>])</span><br><span class="line">            tmp[<span class="number">1</span>] = max(intervals[cur][<span class="number">1</span>],tmp[<span class="number">1</span>])</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        res.append(tmp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur &lt; n:</span><br><span class="line">            res.append(intervals[cur])</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;插入区间&quot;&gt;&lt;a href=&quot;#插入区间&quot; class=&quot;headerlink&quot; title=&quot;插入区间&quot;&gt;&lt;/a&gt;插入区间&lt;/h2&gt;&lt;p&gt;给出一个无重叠的 ，按照区间起始端点排序的区间列表。&lt;/p&gt;
&lt;p&gt;在列表中插入一个新的区间，你需要确保列表中的区间仍然有序
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>SwordOffer/二叉搜索树与双向链表</title>
    <link href="http://yoursite.com/2020/04/12/SwordOffer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/04/12/SwordOffer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2020-04-12T15:32:28.712Z</published>
    <updated>2020-04-12T15:32:48.028Z</updated>
    
    <content type="html"><![CDATA[<hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-236-二叉树的最低公共祖先</title>
    <link href="http://yoursite.com/2020/04/11/Leetcode/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://yoursite.com/2020/04/11/Leetcode/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2020-04-11T14:32:57.799Z</published>
    <updated>2020-04-11T15:25:59.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的最低公共祖先"><a href="#二叉树的最低公共祖先" class="headerlink" title="二叉树的最低公共祖先"></a>二叉树的最低公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdq7b9wjdyj305k05aa9z.jpg" alt="img"></p><p>示例 1:</p><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>示例 2:</p><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>注意限制条件！！！</p><blockquote><p>所有节点都是唯一的</p><p>p,q不同且一定存在</p></blockquote><p>上面两个比较强的条件限制，所以可以避开一些情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">   <span class="keyword">if</span> root==p <span class="keyword">or</span> root == q:</span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="comment"># 左边是None，说明左边没有P也没有Q</span></span><br><span class="line">      <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="comment"># 同上</span></span><br><span class="line">      <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:  <span class="comment"># p,q在 root的左右两边</span></span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树的最低公共祖先&quot;&gt;&lt;a href=&quot;#二叉树的最低公共祖先&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最低公共祖先&quot;&gt;&lt;/a&gt;二叉树的最低公共祖先&lt;/h2&gt;&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;百度
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>SwordOffer/二叉搜索树的最近公共祖先</title>
    <link href="http://yoursite.com/2020/04/11/SwordOffer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://yoursite.com/2020/04/11/SwordOffer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2020-04-11T09:25:34.305Z</published>
    <updated>2020-04-11T09:25:44.688Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-190-颠倒二进制</title>
    <link href="http://yoursite.com/2020/04/11/Leetcode/leetcode-190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>http://yoursite.com/2020/04/11/Leetcode/leetcode-190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6/</id>
    <published>2020-04-11T04:19:52.000Z</published>
    <updated>2020-04-11T11:15:27.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="颠倒二进制"><a href="#颠倒二进制" class="headerlink" title="颠倒二进制"></a>颠倒二进制</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p><p>示例 1：</p><p>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。<br>示例 2：</p><p>输入：11111111111111111111111111111101<br>输出：10111111111111111111111111111111<br>解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p><p>进阶:<br>如果多次调用这个函数，你将如何优化你的算法？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-bits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-bits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本想法，就是一位一位的处理，将低位的放到高位，所以有这样一个基本关系<code>低位的i</code> 对应<code>高位的31-i,i从0开始</code>。所以需要每次将数字的最低位跟1比较，判断然后再右移。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        p = <span class="number">31</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">             tmp = (n&amp;<span class="number">1</span>) &lt;&lt; p</span><br><span class="line">             n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">             res += tmp</span><br><span class="line">             p -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="高级思路"><a href="#高级思路" class="headerlink" title="高级思路"></a>高级思路</h3><p>分治思想:</p><p>基本的框架就是：</p><p>所以自顶向下就是先交换高16位和低16位，然后再交换每个16位里面的高8位，低8位</p><p>…</p><p>然后交换每个2位中的高1位和低1位。</p><p>主要用了两个</p><p><img src="https://pic.leetcode-cn.com/c57a82424197ba1f4091a67cc4a6c575b35dcc0bf9d077415838d3b22d4b1ff3-file_1585801736118" alt="来自官方题解"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        n = (n&gt;&gt;<span class="number">16</span>) | (n&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        n = (n&amp;(<span class="number">0xff00ff00</span>))&gt;&gt;<span class="number">8</span> | (n&amp;(<span class="number">0x00ff00ff</span>))&lt;&lt;<span class="number">8</span></span><br><span class="line">        n = (n&amp;<span class="number">0xf0f0f0f0</span>)&gt;&gt;<span class="number">4</span> | (n&amp;(<span class="number">0x0f0f0f0f</span>))&lt;&lt;<span class="number">4</span></span><br><span class="line">        n = (n&amp;<span class="number">0xcccccccc</span>)&gt;&gt;<span class="number">2</span> | (n&amp;(<span class="number">0x33333333</span>))&lt;&lt;<span class="number">2</span></span><br><span class="line">        n = (n&amp;<span class="number">0xaaaaaaaa</span>)&gt;&gt;<span class="number">1</span> | (n&amp;(<span class="number">0x55555555</span>))&lt;&lt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;颠倒二进制&quot;&gt;&lt;a href=&quot;#颠倒二进制&quot; class=&quot;headerlink&quot; title=&quot;颠倒二进制&quot;&gt;&lt;/a&gt;颠倒二进制&lt;/h2&gt;&lt;p&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入: 000000101001
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="http://yoursite.com/2020/04/11/SwordOffer/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/04/11/SwordOffer/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2020-04-11T03:38:21.000Z</published>
    <updated>2020-04-11T03:38:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二进制中1的个数&quot;&gt;&lt;a href=&quot;#二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;二进制中1的个数&quot;&gt;&lt;/a&gt;二进制中1的个数&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-40-组合总和II</title>
    <link href="http://yoursite.com/2020/04/06/Leetcode/leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/"/>
    <id>http://yoursite.com/2020/04/06/Leetcode/leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/</id>
    <published>2020-04-06T14:08:15.000Z</published>
    <updated>2020-04-06T15:14:17.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]<br>示例 2:</p><p>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>注意细节问题：</p><ul><li>没有额外说明都是无重复的数，所以可能存在重复的元素</li><li>每个数字在组合中只能使用一次</li><li>解集中不能包含重复的元素</li></ul><p>针对细节问题的处理：</p><ul><li>可能存在重复的元素，那么需要使用预排序，这样重复的元素会挨到一起，如果重复的元素在同一层，显然是会出现重复情况的，所以同一层时候对于同一个元素，我们只选第一个，对于后边重复的都弃用</li><li>数字只能使用一次，那么下一次开始的位置就需要在当前位置的+1位（这样连visited 辅助数组都不需要了）</li><li>前面两个处理，保证了解集中不会出现重复的元素。</li></ul><p>对于问题1的处理，我们举个例子方便理解：什么叫做同一层，</p><blockquote><p>[6,2,2,2,2,2] target = 8</p><p>排序后: [2,2,2,2,6]</p><p>结果是 [[2,6],[2,2,2,2]]</p><p>对于第一层选了1个2，那么下一层可以从[2,2,2,6]中进行选择,且只能选一个，对于选了6，那么结果就是[2,6]</p><p>对于第二层也选了2，那么下一层可以从[2,2,6]中进行选择，</p><p>….  当4个2都选完后，构成一个解[2,2,2,2] ，从一棵树的角度来看的，这4个2是在不同的层</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        stack = []</span><br><span class="line">        self.res = []</span><br><span class="line">        self.helper(candidates,stack,target,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, candidates,stack,target,start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            self.res.append(stack.copy())</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">elif</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> idx &gt; start <span class="keyword">and</span> candidates[idx] == candidates[idx<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                stack.append(candidates[idx])</span><br><span class="line">                self.helper(candidates,stack,target-candidates[idx],idx+<span class="number">1</span>)</span><br><span class="line">                stack.pop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组合总和II&quot;&gt;&lt;a href=&quot;#组合总和II&quot; class=&quot;headerlink&quot; title=&quot;组合总和II&quot;&gt;&lt;/a&gt;组合总和II&lt;/h2&gt;&lt;p&gt;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-72-编辑距离</title>
    <link href="http://yoursite.com/2020/04/06/Leetcode/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2020/04/06/Leetcode/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-04-06T13:12:57.000Z</published>
    <updated>2020-04-06T13:36:39.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>示例 1：</p><p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)<br>示例 2：</p><p>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为什么选择dp？</p><p>这个是存在最优子问题结构的，比如示例给出的<code>horse</code>和 <code>ros</code>，其中包含的子问题就是<code>hors</code> 和<code>ros</code>的编辑距离，当然也可以是<code>horse</code>和<code>ro</code>的编辑距离。子问题解决了再看最终的<code>horse</code>和<code>ros</code>的情况。由上面分析也可以知道，由于word1 和word2都需要考虑他们的子串对应的情况，所以是个二维dp。</p><p>其次就是dp 情况的说明：</p><blockquote><p>$dp[i][j]$表示的word1 前i个字符和word2的前j个字符对应的编辑距离（最少操作次数）</p><p>状态转移方程呢？</p><p>当 word1第i个字符 == word2第j个字符，那么说明这个位置不用处理，编辑距离就等于 各前一个字符处的情况，即：$dp[i][j] = d[i-1][j-1]$</p><p>当 word1第i个字符 ！= word2第j个字符，那么存在3种情况，分别为 插入、删除、替换。</p><p>因为问题是 最少的操作从word1变到word2，</p><p>所以插入操作就是在前i-1个字符基础上插入一个字符得到当前的，即$dp[i][j] = dp[i1-][j]$</p><p>对应删除操作是指，删除当前i所对应的字符，对应的就是$dp[i][j] = dp[i][j-1]$</p><p>对应替换操作，就是将i对应的字符换成j对应的字符，那么就是$dp[i][j] = dp[i-1][j-1]$</p><p>而我们要求的是最少操作次数，所以需要看上面三种情况 哪个情况的操作次数最少。</p><p>$dp[i][j] =min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j]) + 1$</p><p>最后的<code>+1</code>是指上面操作都需要一次操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 搞明白dp 的含义</span></span><br><span class="line">        <span class="comment"># dp[i][j] 表示 word1 前i个字符变到  word2前j个字符 需要的操作次数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word1 <span class="keyword">or</span> <span class="keyword">not</span> word2:</span><br><span class="line">            <span class="keyword">return</span> len(word1) <span class="keyword">or</span> len(word2)</span><br><span class="line">        n1 = len(word1)</span><br><span class="line">        n2 = len(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编辑距离&quot;&gt;&lt;a href=&quot;#编辑距离&quot; class=&quot;headerlink&quot; title=&quot;编辑距离&quot;&gt;&lt;/a&gt;编辑距离&lt;/h2&gt;&lt;p&gt;给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>自我介绍</title>
    <link href="http://yoursite.com/2020/04/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2020/04/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-04-05T08:19:46.000Z</published>
    <updated>2020-04-12T15:32:15.786Z</updated>
    
    <content type="html"><![CDATA[<p>抓住自己擅长的地方和领域，引导面试官往自己的领域靠近。</p><p>我叫孟迪，本科就读于北京交通大学计算机与科学专业，现在就读于北京大学软件工程专业，研究生二年级。想要应聘的是软件开发工程师实习生，更确切的是做算法工程相关的职位。我之前有过两份算法实习的经历，一份是在网易新闻做NLP相关的工作，主要任务是构建新闻内容质量生态，涉及打三俗、正文优化等工作。最近的这份实习是在京东做电商的搜索排序工作，主要负责的rerank 模块从0到1的构建过程。两份算法工程师的实习都是偏工程实践的，不是算法研究的那种。即为了解决什么样的问题，可以将什么样的算法进行应用，以及是否能达到预期标准，是否能满足系统的要求。我自己对实践一个比较新的算法，应用到实际的生产数据中，能够work并且能够满足客户的需求，非常感兴趣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;抓住自己擅长的地方和领域，引导面试官往自己的领域靠近。&lt;/p&gt;
&lt;p&gt;我叫孟迪，本科就读于北京交通大学计算机与科学专业，现在就读于北京大学软件工程专业，研究生二年级。想要应聘的是软件开发工程师实习生，更确切的是做算法工程相关的职位。我之前有过两份算法实习的经历，一份是在网易
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>项目分析——STAR方法</title>
    <link href="http://yoursite.com/2020/04/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/STAR%E8%A1%8C%E4%B8%BA%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/STAR%E8%A1%8C%E4%B8%BA%E6%96%B9%E6%B3%95/</id>
    <published>2020-04-05T07:58:14.000Z</published>
    <updated>2020-04-05T08:00:42.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STAR-方法"><a href="#STAR-方法" class="headerlink" title="STAR 方法"></a>STAR 方法</h2><p>STAR是一种结构化的方法，来回答基于行为的面试问题，再根据您描述的场景、任务、行动和结果展开讨论。详情如下：</p><p> （来源于亚马逊的<a href="https://www.amazon.jobs/zh/landing_pages/in-person-interview" target="_blank" rel="noopener">现场面试准备</a>）</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>描述你之前所经历的一次情况，或者你需要完成的一件任务。为面试官提供足够的细节来了解情况里的复杂性。您所描述的例子可以来自您之前的工作，学校作业，志愿者活动或任何相关事件。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>您朝着什么目标努力？</p><h3 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h3><p>描述您针对有关情况所采取的行动，并提供足够的细节；阐述时请将重点放在您的身上。 你采取了哪些具体步骤？ 你的具体的贡献是什么？ 注意，描述时请不要将焦点偏至您团队或小组的贡献。让我们了解您的个人贡献阐述行动时，请使用 “我” 而不是 “我们”</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>描述您的行动所得的结果，无需谦虚，并且将属于您的成就讲述出来。发生了什么？ 事情是如何结束的？ 您获得了什么成就？ 您学习到了什么？ 如果适宜，请提供指标或数据的示例。</p><p>考虑您自己在领导力准则方面的成功和失败。准备具体的例子来体现您的专业知识，并展示你在这个过程中如何冒险，成功，失败和成长。亚马逊最成功的一些项目是从失败的项目中脱颖而出的。失败是成功之母，是创新的必经之路。是必须经历的途径。我们了解这一点，并相信我们应该尽早尝试，失败，然后改进，直到成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;STAR-方法&quot;&gt;&lt;a href=&quot;#STAR-方法&quot; class=&quot;headerlink&quot; title=&quot;STAR 方法&quot;&gt;&lt;/a&gt;STAR 方法&lt;/h2&gt;&lt;p&gt;STAR是一种结构化的方法，来回答基于行为的面试问题，再根据您描述的场景、任务、行动和结果展开讨论。
      
    
    </summary>
    
    
      <category term="项目总结" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode/leetcode周赛183场</title>
    <link href="http://yoursite.com/2020/04/05/Leetcode/leetcode%E5%91%A8%E8%B5%9B183%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/04/05/Leetcode/leetcode%E5%91%A8%E8%B5%9B183%E5%9C%BA/</id>
    <published>2020-04-05T07:52:44.569Z</published>
    <updated>2020-04-05T07:53:50.394Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
