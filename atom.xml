<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Mereder</title>
  
  <subtitle>珍惜现在，感谢所有，不悔将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-26T14:19:12.251Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meng Di</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-12-整数转罗马数字</title>
    <link href="http://yoursite.com/2020/02/26/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/02/26/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-26T14:15:31.000Z</published>
    <updated>2020-02-26T14:19:12.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:</p><p>输入: 3<br>输出: “III”<br>示例 2:</p><p>输入: 4<br>输出: “IV”<br>示例 3:</p><p>输入: 9<br>输出: “IX”<br>示例 4:</p><p>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.<br>示例 5:</p><p>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>主要的思路就是 查表+贪心</p><p>查表体现在：我们尽可能将核心组成数组 用一个dict 存储起来</p><p>贪心体现在：每次我们都是先用一个尽可能大的 表中数字去进行处理，优先使用大的符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        table = &#123;<span class="string">'M'</span>:<span class="number">1000</span>, </span><br><span class="line">                 <span class="string">'CM'</span>:<span class="number">900</span>,</span><br><span class="line">                 <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">                 <span class="string">'CD'</span>:<span class="number">400</span>,</span><br><span class="line">                 <span class="string">'C'</span>:<span class="number">100</span>,</span><br><span class="line">                 <span class="string">'XC'</span>:<span class="number">90</span>,</span><br><span class="line">                 <span class="string">'L'</span>:<span class="number">50</span>,</span><br><span class="line">                 <span class="string">'XL'</span>:<span class="number">40</span>,</span><br><span class="line">                 <span class="string">'X'</span>:<span class="number">10</span>,</span><br><span class="line">                 <span class="string">'IX'</span>:<span class="number">9</span>,</span><br><span class="line">                 <span class="string">'V'</span>:<span class="number">5</span>,</span><br><span class="line">                 <span class="string">'IV'</span>:<span class="number">4</span>,</span><br><span class="line">                 <span class="string">'I'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> table.keys(): <span class="comment"># 潜在的贪心过程，因为table 我是按从大到小写的，遍历过程也会按照从大到小进行</span></span><br><span class="line">            cnt = num // table[key]</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            res += cnt * key</span><br><span class="line">            num -= cnt * table[key]</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整数转罗马数字&quot;&gt;&lt;a href=&quot;#整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;整数转罗马数字&quot;&gt;&lt;/a&gt;整数转罗马数字&lt;/h2&gt;&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;p&gt;字符       
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>K个一组翻转链表</title>
    <link href="http://yoursite.com/2020/02/26/leetcode-25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/26/leetcode-25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-25T17:42:42.000Z</published>
    <updated>2020-02-25T17:50:57.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例 :</p><p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>说明 :</p><p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解题方式很简单，就是K个翻转一次，比较难理解的地方在于需要维护多个变量，来实现这个方法</p><blockquote><ul><li>start指针：待翻转链表的头结点，翻转后变成尾结点</li><li>end指针：待翻转链表的尾节点，翻转后变成头结点</li><li>pre指针：待翻转链表的前面部分（可以理解为 已经完成操作的节点的尾部）</li><li>nxt指针：未进行操作的链表头部</li></ul></blockquote><p>下图来自LeetCode讨论区：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/" target="_blank" rel="noopener">王小二</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc96g7ia6nj30lx10stax.jpg" alt="k个一组翻转链表.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pre = dummy</span><br><span class="line">        end = dummy</span><br><span class="line">        dummy.next = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> end:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                end = end.next <span class="keyword">if</span> end <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> end:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            nxt = end.next</span><br><span class="line">            end.next = <span class="literal">None</span></span><br><span class="line">            start = pre.next</span><br><span class="line">            pre.next = self.reverse(start)</span><br><span class="line">            start.next = nxt <span class="comment">### start 跑到尾部了</span></span><br><span class="line">            pre = start</span><br><span class="line">            end = start</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            nxt = p.next</span><br><span class="line">            p.next = pre</span><br><span class="line">            pre = p</span><br><span class="line">            p = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;K个一组翻转链表&quot;&gt;&lt;a href=&quot;#K个一组翻转链表&quot; class=&quot;headerlink&quot; title=&quot;K个一组翻转链表&quot;&gt;&lt;/a&gt;K个一组翻转链表&lt;/h2&gt;&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正
      
    
    </summary>
    
    
      <category term="算法算题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AE%97%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AE%97%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-138-复制带随机指针的链表</title>
    <link href="http://yoursite.com/2020/02/26/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/26/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-25T16:48:37.000Z</published>
    <updated>2020-02-25T17:45:35.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h2><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的 深拷贝。 </p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</p><p>示例 1：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc94qezsp7j31gs0aq0u5.jpg" alt="img"></p><blockquote><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p></blockquote><p>更多示例 <a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">原题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用的是剑指里面的解题思路。先把链表的每一个节点都copy一遍，并且追加到该节点之后</p><blockquote><p>即: 1-2-3-4 -&gt;  1-1’-2-2’-3-3’-4-4’</p></blockquote><p>然后再将随机指针按照原来的形式，追加到各个复制节点上</p><blockquote><p>即 若原来有一个 1——4的随机指针，那么复制的节点 也应该有 1’——4’这样一个随机指针</p></blockquote><p>然后再重新遍历整个链表，将链表拆开，返回深拷贝的链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 1.复制一遍链表</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            tmp = Node(p.val,p.next)</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = tmp.next</span><br><span class="line">        <span class="comment"># 2.复制random 指针</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p :</span><br><span class="line">            q = p.next</span><br><span class="line">            q.random = p.random.next <span class="keyword">if</span> p.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p = q.next</span><br><span class="line">        <span class="comment"># 3.从头遍历，拆出来指针</span></span><br><span class="line">        p = head</span><br><span class="line">        dummy = head.next</span><br><span class="line">        q = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q.random = p.random.next <span class="keyword">if</span> p.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p = q.next</span><br><span class="line">            q.next = p.next <span class="keyword">if</span> p <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            q = q.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;复制带随机指针的链表&quot;&gt;&lt;a href=&quot;#复制带随机指针的链表&quot; class=&quot;headerlink&quot; title=&quot;复制带随机指针的链表&quot;&gt;&lt;/a&gt;复制带随机指针的链表&lt;/h2&gt;&lt;p&gt;给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2020/02/22/SwordOffer/test/"/>
    <id>http://yoursite.com/2020/02/22/SwordOffer/test/</id>
    <published>2020-02-22T13:20:09.000Z</published>
    <updated>2020-02-22T13:20:38.084Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>SwordOffer/Untitled</title>
    <link href="http://yoursite.com/2020/02/22/SwordOffer/Untitled/"/>
    <id>http://yoursite.com/2020/02/22/SwordOffer/Untitled/</id>
    <published>2020-02-22T13:19:51.649Z</published>
    <updated>2020-02-22T13:19:51.649Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Union-Find</title>
    <link href="http://yoursite.com/2020/02/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/02/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2020-02-22T08:23:41.000Z</published>
    <updated>2020-02-22T08:25:05.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Union-find"><a href="#Union-find" class="headerlink" title="Union-find"></a>Union-find</h2><p>并查集，主要用来解决再一个集合中查找是否存在另一个元素，或者合并两个集合。</p><p>涉及到的主要操作就是Union和Find</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Union-find&quot;&gt;&lt;a href=&quot;#Union-find&quot; class=&quot;headerlink&quot; title=&quot;Union-find&quot;&gt;&lt;/a&gt;Union-find&lt;/h2&gt;&lt;p&gt;并查集，主要用来解决再一个集合中查找是否存在另一个元素，或者合并两个集合。&lt;
      
    
    </summary>
    
    
      <category term="算法基础" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Untitled</title>
    <link href="http://yoursite.com/2020/02/22/Untitled/"/>
    <id>http://yoursite.com/2020/02/22/Untitled/</id>
    <published>2020-02-22T08:23:07.752Z</published>
    <updated>2020-02-22T08:23:07.752Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode-980-不同路径III</title>
    <link href="http://yoursite.com/2020/02/19/leetcode-980-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III/"/>
    <id>http://yoursite.com/2020/02/19/leetcode-980-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III/</id>
    <published>2020-02-18T17:17:06.266Z</published>
    <updated>2020-02-19T15:00:48.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不同路径III"><a href="#不同路径III" class="headerlink" title="不同路径III"></a>不同路径III</h2><p>在二维网格 grid 上，有 4 种类型的方格：</p><p>1 表示起始方格。且只有一个起始方格。<br>2 表示结束方格，且只有一个结束方格。<br>0 表示我们可以走过的空方格。<br>-1 表示我们无法跨越的障碍。<br>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><p>示例 1：</p><blockquote><p>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]<br>输出：2<br>解释：我们有以下两条路径：</p><p>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</p><p>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</p><p>示例 2：<br>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]<br>输出：4<br>解释：我们有以下四条路径： </p><p>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</p><p>(0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</p><p>(0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</p><p>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</p><p>示例 3：</p><p>输入：[[0,1],[2,0]]<br>输出：0<br>解释：<br>没有一条路能完全穿过每一个空的方格一次。<br>请注意，起始和结束方格可以位于网格中的任意位置。</p></blockquote><p>提示：</p><p>1 &lt;= grid.length * grid[0].length &lt;= 20</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>自己的思路上来就是DFS，因为给的提示是<code>1&lt;= len(grid)*len(grid[0])&lt;=20</code>,说明数据量很小，DFS应该没问题</p><p>况且，需要遍历所有0位置，一开始没有想到动态规划如何来解决。那就用DFS来遍历所有位置。</p><p>每一次到达终点时候都需要检测是否grid内部的0都被探测到了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># grid &lt;=1 &lt;= 20</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        result = []</span><br><span class="line">        stack = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    self.help(i+<span class="number">1</span>, j, m, n, grid, result, stack)</span><br><span class="line">                    self.help(i<span class="number">-1</span>, j, m, n, grid, result, stack)</span><br><span class="line">                    self.help(i, j+<span class="number">1</span>, m, n, grid, result, stack)</span><br><span class="line">                    self.help(i, j<span class="number">-1</span>, m, n, grid, result, stack)</span><br><span class="line"></span><br><span class="line">        result = len(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(self, i,j,m,n,grid, result,stack)</span>:</span> <span class="comment"># result stack  都是 set</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i &gt;=m <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> grid[i][j]==<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> grid[i][j]==<span class="number">2</span> <span class="keyword">and</span> self.check(grid,m,n):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> grid[i][j]==<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> self.check(grid,m,n):</span><br><span class="line">            result.append(stack)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            grid[i][j] = <span class="number">-2</span></span><br><span class="line">            stack.add((i,j))</span><br><span class="line">            self.help(i,j+<span class="number">1</span>,m,n,grid,result,stack)</span><br><span class="line">            self.help(i,j<span class="number">-1</span>,m,n,grid,result,stack)</span><br><span class="line">            self.help(i+<span class="number">1</span>,j,m,n,grid,result,stack)</span><br><span class="line">            self.help(i<span class="number">-1</span>,j,m,n,grid,result,stack)</span><br><span class="line">            stack.add((i,j))</span><br><span class="line">            grid[i][j] = <span class="number">0</span>        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self,grid,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="延续【不同路径】系列问题思路"><a href="#延续【不同路径】系列问题思路" class="headerlink" title="延续【不同路径】系列问题思路"></a>延续【不同路径】系列问题思路</h3><p>继续动态规划</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不同路径III&quot;&gt;&lt;a href=&quot;#不同路径III&quot; class=&quot;headerlink&quot; title=&quot;不同路径III&quot;&gt;&lt;/a&gt;不同路径III&lt;/h2&gt;&lt;p&gt;在二维网格 grid 上，有 4 种类型的方格：&lt;/p&gt;
&lt;p&gt;1 表示起始方格。且只有一个起始方格
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode-66-加一</title>
    <link href="http://yoursite.com/2020/02/12/leetcode-66-%E5%8A%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/12/leetcode-66-%E5%8A%A0%E4%B8%80/</id>
    <published>2020-02-11T17:10:07.632Z</published>
    <updated>2020-02-11T17:17:32.174Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title</p><hr><h2 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p><p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>模拟实现过程，并且注意特殊情况，既然是从低位开始+1，则遍历数组需要从后向前。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 倒序遍历</span></span><br><span class="line">        index = len(digits)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 初始化情况</span></span><br><span class="line">        digits[index] = digits[index]+<span class="number">1</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 满足进位条件，则进行进位</span></span><br><span class="line">            <span class="keyword">if</span> digits[index]+carry&gt;<span class="number">9</span>:</span><br><span class="line">                digits[index] = (digits[index]+carry)%<span class="number">10</span> <span class="comment"># 模10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 不满足进位，加上可能存在的carry,然后直接退出就可以了</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[index] += carry </span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 判断是否需要再补入一个1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span> <span class="keyword">and</span> carry ==<span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]+digits</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;加一&quot;&gt;&lt;a href=&quot;#加一&quot; class=&quot;headerlink&quot; title=&quot;加一&quot;&gt;&lt;/a&gt;加一&lt;/h2&gt;&lt;p&gt;给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。&lt;/p&gt;
&lt;p&gt;最高位数字存
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-369-给单链表加1</title>
    <link href="http://yoursite.com/2020/02/12/leetcode-369-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8A%A01/"/>
    <id>http://yoursite.com/2020/02/12/leetcode-369-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8A%A01/</id>
    <published>2020-02-11T16:23:52.000Z</published>
    <updated>2020-02-11T16:41:31.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给单链表加1"><a href="#给单链表加1" class="headerlink" title="给单链表加1"></a>给单链表加1</h2><p>用一个 非空 单链表来表示一个非负整数，然后将这个整数加一。</p><p>你可以假设这个整数除了 0 本身，没有任何前导的 0。</p><p>这个整数的各个数位按照 高位在链表头部、低位在链表尾部 的顺序排列。</p><p>示例:</p><p>输入: [1,2,3]<br>输出: [1,2,4]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>发现有大神分享的思路太好了，所以直接按照他们的思路进行了编码。</p><p>这个题目最棘手的问题就是遇到含有9且以9结尾，就涉及到进位的问题：</p><blockquote><p>举个例子：</p><p>1-2-9-3-4 这个我们不需要担心，因为不是以9结尾</p><p>1-2-3-9-9 这个就很棘手，如果+1的话会造成两次进位，但是问题简化下，实际只需要在3处进位一次，后边置0即可</p></blockquote><ul><li>对于某个节点值为9，我们希望有个指针停留在9之前，这样我们方便进位，也能把之后的值都置为0</li><li>对于某个节点值为0-8，我们希望指针停留在当前节点，直接在当前节点上+1即可，无需额外操作</li></ul><p>根据上面的分析，自然想到用双指针，其中一个指针用来遍历链表，另外一个指针用来表示上面的情况。由于<code>left</code>,需要先在<code>right</code>前面才能保证首位如果是9的话，left仍在前面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">dummy.next = head</span><br><span class="line">left = dummy</span><br><span class="line">right = head</span><br><span class="line"><span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">  <span class="keyword">if</span> right.val != <span class="number">9</span>:</span><br><span class="line">    left = right</span><br><span class="line">  right = right.next</span><br></pre></td></tr></table></figure><p>由于上面的移动，最终的<code>left</code>指针就是我们需要操作的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">left.val += <span class="number">1</span></span><br><span class="line">p = left.next</span><br><span class="line"><span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">  p.val = <span class="number">0</span></span><br><span class="line">  p = p.next</span><br></pre></td></tr></table></figure><p>但是这里还有另外一个问题，如果遇到首位就是9的情况怎么办？那意味着我们需要重新创建一个头结点并且值为1，后续结点都为0。</p><p>巧了！前面我们为了保证left起始时在right前面，定义了一个哑变量<code>dummy node</code>，我们可以利用这个节点，来完成，所以修改如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(<span class="number">0</span>) <span class="comment"># 由原来的-1 变为0 这样+1之后就有含义了</span></span><br><span class="line">dummy.next = head</span><br><span class="line">left = dummy</span><br><span class="line">right = head</span><br><span class="line"><span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">  <span class="keyword">if</span> right.val != <span class="number">9</span>:</span><br><span class="line">    left = right</span><br><span class="line">  right = right.next</span><br></pre></td></tr></table></figure><p>最后返回时候，我们需要确认，dummy node的值是否更新了，如果更新为1则返回dummy，否则返回dummy.next</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> dummy.val == <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">return</span> dummy.next</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure><h3 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h3><p>时间复杂度为<code>o(N)</code>,空间复杂度为<code>o(1)</code>，因为使用了一个dummy node  3个指针，都是常数级别的</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        left = dummy</span><br><span class="line">        right = head</span><br><span class="line">        <span class="comment"># 始终更新left 和right保证left 始终在某个可能的9的左侧</span></span><br><span class="line">        <span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> right.val != <span class="number">9</span>:</span><br><span class="line">                left = right</span><br><span class="line">            right = right.next </span><br><span class="line">        </span><br><span class="line">        left.val += <span class="number">1</span></span><br><span class="line">        p = left.next</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            p.val = <span class="number">0</span></span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dummy.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;给单链表加1&quot;&gt;&lt;a href=&quot;#给单链表加1&quot; class=&quot;headerlink&quot; title=&quot;给单链表加1&quot;&gt;&lt;/a&gt;给单链表加1&lt;/h2&gt;&lt;p&gt;用一个 非空 单链表来表示一个非负整数，然后将这个整数加一。&lt;/p&gt;
&lt;p&gt;你可以假设这个整数除了 0 本身
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-155-最小栈</title>
    <link href="http://yoursite.com/2020/02/11/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://yoursite.com/2020/02/11/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/</id>
    <published>2020-02-10T17:21:42.898Z</published>
    <updated>2020-02-10T17:25:17.397Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) — 将元素 x 推入栈中。<br>pop() — 删除栈顶的元素。<br>top() — 获取栈顶元素。<br>getMin() — 检索栈中的最小元素。<br>示例:</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   —&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      —&gt; 返回 0.<br>minStack.getMin();   —&gt; 返回 -2.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-stack" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是借助一个辅助栈，来实现常数时间内获取最小值。</p><p>原理就是每次加入 辅助最小栈时，先比较，如果比最小栈栈顶元素小，就压入元素，否则就把原来的最小栈栈顶元素再次压入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.m_stack = []</span><br><span class="line">        self.nums = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums == <span class="number">0</span>:</span><br><span class="line">            self.m_stack.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> x &lt; self.m_stack[<span class="number">-1</span>]:</span><br><span class="line">                self.m_stack.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.m_stack.append(self.m_stack[<span class="number">-1</span>])</span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.nums += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">            self.m_stack.pop()</span><br><span class="line">            self.nums -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'栈为空'</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.m_stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'栈为空'</span>)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&quot;最小栈&quot;&gt;&lt;a href=&quot;#最小栈&quot; class=&quot;headerlink&quot; title=&quot;最小栈&quot;&gt;&lt;/a&gt;最小栈&lt;/h2&gt;&lt;p&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;p&gt;push(x)
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-707-设计链表</title>
    <link href="http://yoursite.com/2020/02/11/leetcode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/11/leetcode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-10T16:01:19.000Z</published>
    <updated>2020-02-10T16:03:29.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p><p>示例：</p><p>MyLinkedList linkedList = new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            //返回2<br>linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>linkedList.get(1);            //返回3</p><p>提示：</p><p>所有val值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>emmm 看见几个月前用java尝试了N边都错的题，Python一遍就过了…看了下当时写的java，不忍卒读，难怪会出问题。</p><p>注意几个地方：</p><ul><li>及时更新 capacity</li><li>使用一个dummy node 当 header</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        self.val = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># dummy 头</span></span><br><span class="line">        self.head = ListNode(<span class="number">-1</span>)</span><br><span class="line">        self.capacity = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># index 范围是 0-n-1</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.capacity:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> p.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = ListNode(val)</span><br><span class="line">        tmp.next = self.head.next</span><br><span class="line">        self.head.next = tmp</span><br><span class="line">        self.capacity += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = ListNode(val)</span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p.next != <span class="literal">None</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">        p.next = tmp</span><br><span class="line">        self.capacity += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.capacity:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index == self.capacity:</span><br><span class="line">            self.addAtTail(val)</span><br><span class="line">        <span class="keyword">elif</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            self.addAtHead(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = self.head</span><br><span class="line">            <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">            tmp = ListNode(val)</span><br><span class="line">            tmp.next = p.next</span><br><span class="line">            p.next = tmp</span><br><span class="line">            self.capacity += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span><span class="params">(self, index: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.capacity <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = self.head</span><br><span class="line">            <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p.next == <span class="literal">None</span>:</span><br><span class="line">                p = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = p.next.next</span><br><span class="line">            self.capacity -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计链表&quot;&gt;&lt;a href=&quot;#设计链表&quot; class=&quot;headerlink&quot; title=&quot;设计链表&quot;&gt;&lt;/a&gt;设计链表&lt;/h2&gt;&lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>第一次参加Leetcode周赛</title>
    <link href="http://yoursite.com/2020/02/09/leetcode%E5%91%A8%E8%B5%9B175%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/02/09/leetcode%E5%91%A8%E8%B5%9B175%E5%9C%BA/</id>
    <published>2020-02-09T14:38:55.000Z</published>
    <updated>2020-02-25T17:58:26.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一次参加周赛"><a href="#第一次参加周赛" class="headerlink" title="第一次参加周赛"></a>第一次参加周赛</h2><p>之前觉得太菜了，还是好好耍基础题，搞什么周赛，直到我参加了之后，才发现，我是真的菜！….</p><h2 id="周赛-175场"><a href="#周赛-175场" class="headerlink" title="周赛-175场"></a>周赛-175场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/" target="_blank" rel="noopener">检查整数及其两倍数是否存在</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/" target="_blank" rel="noopener">制造字母异位词的最小步骤数</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/tweet-counts-per-frequency/" target="_blank" rel="noopener">推文计数</a><br><code>7 分</code> - <a href="https://leetcode-cn.com/problems/maximum-students-taking-exam/" target="_blank" rel="noopener">参加考试的最大学生数</a></p><h3 id="第一题：easy"><a href="#第一题：easy" class="headerlink" title="第一题：easy"></a>第一题：easy</h3><p>跟2sum差不多的路子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfExist</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        tmp_dict = set([])</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            tmp = arr[i]</span><br><span class="line">            <span class="keyword">if</span> tmp*<span class="number">2</span> <span class="keyword">in</span> tmp_dict:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> tmp/<span class="number">2</span> <span class="keyword">in</span> tmp_dict:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            tmp_dict.add(tmp)</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure><p>复杂度分析：时间复杂度是<code>o(n)</code>，空间复杂度也是<code>o(n)</code>，n是数组元素个数。由于使用了<code>set</code>也是一种hash结构嘛，所以空间复杂度实际应该大于<code>o(n)</code>,具体到多少，就需要看<code>set</code>的实现机制了。</p><h3 id="第二题：Medium"><a href="#第二题：Medium" class="headerlink" title="第二题：Medium"></a>第二题：Medium</h3><p>看完题意之后，表示没太看懂，然后又看例子…我的理解就是，看下diff的字母个数就好了。</p><p>就先给<code>s</code>串各个字母计个数，然后遍历<code>t</code>串时候相应的减去，最后将<code>计数个数&gt;0</code>的相加就可以了</p><p>用什么来存各个计数个数呢？因为说的都是小写字母，用个26的数组就可以了，这样空间复杂度降到o(1)了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">        mem = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            mem[ord(char)-ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">            mem[ord(char)-ord(<span class="string">'a'</span>)] -= <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> mem[i] &gt;<span class="number">0</span>:</span><br><span class="line">                cnt += mem[i]</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h3 id="第三题：Medium"><a href="#第三题：Medium" class="headerlink" title="第三题：Medium"></a>第三题：Medium</h3><p>程序设计题目，理解题目并模拟就可以了，其实主要问题在于细节的优化。</p><p>一开始直接用的<code>o(nk)</code>n是一个用户的所有记录，k是k个时间间隔，也就是两层循环套起来用的…显然超时了。</p><p>简单的优化就是 二分查找，只需要确定startTime的起始下标就可以了。(实际是二分查找的变体：找最左满足条件的)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TweetCounts</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.tweetUser = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recordTweet</span><span class="params">(self, tweetName: str, time: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tweetName <span class="keyword">in</span> self.tweetUser:</span><br><span class="line">            self.tweetUser[tweetName].append(time)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tweetUser[tweetName] = [time]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTweetCountsPerFrequency</span><span class="params">(self, freq: str, tweetName: str, startTime: int, endTime: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> tweetName <span class="keyword">not</span> <span class="keyword">in</span> self.tweetUser:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> freq == <span class="string">'minute'</span>:</span><br><span class="line">            delt = <span class="number">60</span></span><br><span class="line">        <span class="keyword">elif</span> freq == <span class="string">'hour'</span>:</span><br><span class="line">            delt = <span class="number">60</span> * <span class="number">60</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delt = <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span></span><br><span class="line">        self.tweetUser[tweetName].sort()</span><br><span class="line">        result = []</span><br><span class="line">        index = self.bs(self.tweetUser[tweetName],startTime)</span><br><span class="line">        <span class="comment"># if index == -1:</span></span><br><span class="line">        <span class="comment">#     return [0]*((endTime+1-startTime)//delt + 1)</span></span><br><span class="line">        <span class="keyword">for</span> b_interval <span class="keyword">in</span> range(startTime,endTime+<span class="number">1</span>,delt):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            e_interval = min(endTime+<span class="number">1</span>,b_interval+delt)</span><br><span class="line">            <span class="keyword">while</span> index &lt; len(self.tweetUser[tweetName]) <span class="keyword">and</span> self.tweetUser[tweetName][index] &lt; endTime+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> b_interval &lt;= self.tweetUser[tweetName][index] &lt; e_interval:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> self.tweetUser[tweetName][index] &gt;= e_interval:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            result.append(cnt)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bs</span><span class="params">(self,nums,target)</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">if</span> right == len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &gt; target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">return</span> right  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your TweetCounts object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = TweetCounts()</span></span><br><span class="line"><span class="comment"># obj.recordTweet(tweetName,time)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)</span></span><br></pre></td></tr></table></figure><p>时间复杂度为<code>o(nlogn)</code>主要来自于排序部分，其他部分二分<code>logn</code>，计算时间复杂度的依然是<code>k*n</code>但是此时的n已经不是全局的数量了，已经给二分优化后的n已经大大减少。（我感觉并没有优化一个数量级那么夸张，但是已经很客观了）</p><p>后续看分享，有大神提出来二分的过程完全可以考虑使用<code>跳表</code>，给有序链表建立多级索引。</p><h3 id="第四题：Hard"><a href="#第四题：Hard" class="headerlink" title="第四题：Hard"></a>第四题：Hard</h3><p>参加考试的最大学生，看完题的感觉跟八皇后很像，所以直接考虑DFS进行。</p><p>根据题意，我们只需要DFS那个有效作为就可以， 并不用每个座位都遍历，最大的学生数的上限就是有效座位数。很可惜，辛辛苦苦搞出来，纯粹的DFS是超时的。</p><p>如果自己继续优化的话应该考虑剪枝问题，但是当时没有想到特别好的剪枝办法。</p><p>赛后看了大神们的分享，又学会了一个新的东西 <code>状态压缩DP</code> 或 <code>状态压缩DFS</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一次参加周赛&quot;&gt;&lt;a href=&quot;#第一次参加周赛&quot; class=&quot;headerlink&quot; title=&quot;第一次参加周赛&quot;&gt;&lt;/a&gt;第一次参加周赛&lt;/h2&gt;&lt;p&gt;之前觉得太菜了，还是好好耍基础题，搞什么周赛，直到我参加了之后，才发现，我是真的菜！….&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>第一次参加Leetcode周赛</title>
    <link href="http://yoursite.com/2020/02/09/leetcode%E5%91%A8%E8%B5%9B176%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/02/09/leetcode%E5%91%A8%E8%B5%9B176%E5%9C%BA/</id>
    <published>2020-02-09T14:38:55.000Z</published>
    <updated>2020-02-25T17:59:56.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛——176场"><a href="#周赛——176场" class="headerlink" title="周赛——176场"></a>周赛——176场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/" target="_blank" rel="noopener">统计有序矩阵中的负数</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/" target="_blank" rel="noopener">最后 K 个数的乘积</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/" target="_blank" rel="noopener">最多可以参加的会议数目</a><br><code>6 分</code> - <a href="https://leetcode-cn.com/problems/construct-target-array-with-multiple-sums/" target="_blank" rel="noopener">多次求和构造目标数组</a></p><h3 id="统计有序矩阵中的负数"><a href="#统计有序矩阵中的负数" class="headerlink" title="统计有序矩阵中的负数"></a>统计有序矩阵中的负数</h3><p>谈到有序！！！瞬间想到  <code>二分查找</code>，尤其是看了题意之后，这跟<a href="">Leetcode-74-搜索二维矩阵</a>解题思路基本一致。</p><p>关键点就是，定义行标，列标，从右上角开始遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNegatives</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        col = n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> row&lt;m <span class="keyword">and</span> col &gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> grid[row][col] &lt; <span class="number">0</span>:</span><br><span class="line">                result += m-row</span><br><span class="line">                col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>时间复杂度分析：<code>o(m+n)</code> 其实就是行指针和列指针各走一遍，相比于o(m<em>n)的解题方法，这里主要是通过行列两个指针，同时移动达到优化的。原本`m</em>n`方法，行列不会进行继承，跟前面遍历过后的没有关系。</p><h3 id="最后K个数的乘积"><a href="#最后K个数的乘积" class="headerlink" title="最后K个数的乘积"></a>最后K个数的乘积</h3><p>算法设计题目，原理很简单，设置一个list来保存每次添加的数，计算乘积时候，从后向前连乘K个即可。这里有很明显的问题，就是效率问题，计算连乘时候时间复杂度是<code>O(N)</code>的。</p><p>自然想到的时间优化策略就是用空间来换，如果我们保存好每个位置的乘积结果，那么最后K个数的乘积有:</p><p><code>f(k) = f(n)/f(n-k)</code>，因为都是连乘，那么也不需要刚开始说的list来保存添加的数了，只需要一个list保存连乘结果——<code>前缀乘</code></p><p>但是！ 遇到为0的情况需要特殊处理。</p><ul><li>遇到0的地方，那么前面的连乘结果就是0了，所以当其中一个元素为0时候，我们可以考虑丢弃前面所有结果了，重置数组和参数<code>nums</code></li><li>再调用时候，如果k大于0后的元素个数，那么结果一定为0，否则按照除法求得结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductOfNumbers</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sequence = []</span><br><span class="line">        self.nums = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            self.sequence = []  <span class="comment"># 关键地方！！！</span></span><br><span class="line">            self.nums = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.nums == <span class="number">0</span>:</span><br><span class="line">                self.sequence.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.sequence.append(self.sequence[self.nums<span class="number">-1</span>]*num)</span><br><span class="line">            self.nums += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getProduct</span><span class="params">(self, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &lt; k: <span class="comment"># ！！！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.nums == k:</span><br><span class="line">            <span class="keyword">return</span> self.sequence[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.sequence[self.nums<span class="number">-1</span>] // self.sequence[self.nums-k<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 3,1,2,10,40</span></span><br><span class="line"><span class="comment"># 1,2,10,40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your ProductOfNumbers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = ProductOfNumbers()</span></span><br><span class="line"><span class="comment"># obj.add(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getProduct(k)</span></span><br></pre></td></tr></table></figure><p>时间复杂度分析：<code>o(1)</code>因为结果都已经进行了保存，直接获取即可，空间复杂度为<code>o(n)</code>如果没有0出现，将保存整个前缀积</p><h3 id="最多可以参加的会议数目"><a href="#最多可以参加的会议数目" class="headerlink" title="最多可以参加的会议数目"></a>最多可以参加的会议数目</h3><p><strong>优先队列</strong>：说白了就是小根堆或者大根堆，看出去的元素优先出最小的还是最大的。</p><p>第一次接触优先队列，就遇到这样一个，我感觉比较难的题。</p><p>参考了别人的解法，基本思路就是：</p><ol><li>按照开始时间进行排序，如果开始时间比当前时间早即：current<code>小，那么这个会议可以加入考虑，将其结束时间放入优先队列，</code>注意：python 的heapq默认实现的是小根堆，也就是优先出小的元素。`</li><li>然后对优先队列的top进行判断，check是否<code>时间&lt;current</code>，这个时间就是上一步加入的结束时间，如果<code>结束时间&lt;current</code>表示该会议无法安排，则让其出队。</li><li>然后进行判断<code>队列是否为空</code>，不空则表示有可以安排的会议，然后<code>安排且仅能安排一个，即res+=1，并且top出队</code>。</li><li>直到满足 <code>i ==n and len(queue) == 0</code> 即待安排events 没有了，且队列中没有可安排的会议。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEvents</span><span class="params">(self, events: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 按照开始时间排序</span></span><br><span class="line">        events.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        current = <span class="number">1</span></span><br><span class="line">        pq = [] <span class="comment"># 默认是个小根堆</span></span><br><span class="line">        n = len(events)</span><br><span class="line">        <span class="comment"># max_time = max(max(events,key=lambda x:x[1]))</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 1.加入  值得安排的 会议</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> events[i][<span class="number">0</span>] &lt;= current:</span><br><span class="line">                heapq.heappush(pq, events[i][<span class="number">1</span>])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 2. 剔除不满足条件的会议</span></span><br><span class="line">            <span class="keyword">while</span> len(pq) &gt; <span class="number">0</span> <span class="keyword">and</span> pq[<span class="number">0</span>] &lt; current:</span><br><span class="line">                heapq.heappop(pq)</span><br><span class="line">            <span class="comment"># 3. 安排且仅能安排一个会议</span></span><br><span class="line">            <span class="keyword">if</span> len(pq) &gt; <span class="number">0</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                heapq.heappop(pq)</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 4. 弹尽粮绝 跳出</span></span><br><span class="line">            <span class="keyword">if</span> i == n <span class="keyword">and</span> len(pq) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="多次求和构造目标数组"><a href="#多次求和构造目标数组" class="headerlink" title="多次求和构造目标数组"></a>多次求和构造目标数组</h3><p>上来自己的垃圾思路就是 DFS，直接暴力枚举所有情况，直到出现有解得情况…</p><p>即 每一步加和的结果，可以成为下一步任一位置的值…这个复杂度太高了</p><p>其实倒过来想就很简单了：<strong>由本溯源</strong></p><p>对于给定的一个序列，只需要模拟情况，由当前序列，按照规则不断递减，看能否得到全1的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPossible</span><span class="params">(self, target: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            cur_max = max(target)</span><br><span class="line">            <span class="keyword">if</span> cur_max == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            s  = sum(target)</span><br><span class="line">            idx = target.index(cur_max)</span><br><span class="line">            increase = s-cur_max</span><br><span class="line">            <span class="keyword">if</span> increase &gt;= cur_max:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            target[idx] = cur_max-increase</span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li>上面的解法对于testcase:<code>[10^9,1]</code>需要循环10^9次，肯定超时了…大佬们都在说LeetCode测试数据太弱了。将上面的  <code>target[idx] = cur_max - increase</code> 修改为: <code>target[idx] = cur_max % increase</code>换成取模后，对于上面提到的问题，可以很快解决了。</li><li>还有问题，对于testcase:<code>[2]</code>，这个问题，上面将陷入无限循环，应该首先对这个进行优先判断。</li></ul><p>完整解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPossible</span><span class="params">(self, target: List[int])</span> -&gt; bool:</span></span><br><span class="line">      <span class="keyword">if</span> len(target) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> target[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            cur_max = max(target)</span><br><span class="line">            <span class="keyword">if</span> cur_max == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            s  = sum(target)</span><br><span class="line">            idx = target.index(cur_max)</span><br><span class="line">            increase = s-cur_max</span><br><span class="line">            <span class="keyword">if</span> increase &gt;= cur_max:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            target[idx] = cur_max-increase</span><br></pre></td></tr></table></figure><h4 id="更多考虑"><a href="#更多考虑" class="headerlink" title="更多考虑"></a>更多考虑</h4><p>第四题：</p><p>来源<a href="https://leetcode-cn.com/circle/discuss/0gO5RS/" target="_blank" rel="noopener">周赛题目讨论区</a>  用户：<a href="https://leetcode-cn.com/u/scut_dell/" target="_blank" rel="noopener">小白二号</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (target.length == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       PriorityQueue&lt;Long&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">       <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length; i++) &#123;</span><br><span class="line">           sum += target[i];</span><br><span class="line">           pq.offer((<span class="keyword">long</span>)target[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果此时队列为空或者最大值就是1，直接return true</span></span><br><span class="line">       <span class="keyword">if</span> (pq.isEmpty() || pq.<span class="built_in">peek</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">//取出最大的那个</span></span><br><span class="line">           Long poll = pq.poll();</span><br><span class="line">           <span class="comment">//如果此时堆中最大的为1</span></span><br><span class="line">           <span class="keyword">if</span> (pq.<span class="built_in">peek</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//直接看它满足或不满足公式</span></span><br><span class="line">               <span class="keyword">return</span> (poll - <span class="number">1</span>) % (sum - poll) == <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//需要计算多少轮才能比第二小的数小</span></span><br><span class="line">               <span class="keyword">long</span> n = (poll - pq.<span class="built_in">peek</span>()) / (sum - poll) + <span class="number">1</span>;</span><br><span class="line">               <span class="comment">//得到这个数字</span></span><br><span class="line">               <span class="keyword">long</span> x = poll - n * (sum - poll);</span><br><span class="line">               <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//更新sum</span></span><br><span class="line">               sum = poll - (sum - poll) * (n - <span class="number">1</span>);</span><br><span class="line">               pq.offer(x);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛——176场&quot;&gt;&lt;a href=&quot;#周赛——176场&quot; class=&quot;headerlink&quot; title=&quot;周赛——176场&quot;&gt;&lt;/a&gt;周赛——176场&lt;/h2&gt;&lt;p&gt;&lt;code&gt;3 分&lt;/code&gt; - &lt;a href=&quot;https://leetcode-c
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-328-奇偶链表</title>
    <link href="http://yoursite.com/2020/02/07/leetcode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/07/leetcode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-07T15:25:04.648Z</published>
    <updated>2020-02-07T15:38:40.270Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br>示例 2:</p><p>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL<br>说明:</p><p>应当保持奇数节点和偶数节点的相对顺序。<br>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>真的是，以为很简单，想一遍写对真的太难了…还是自己太弱了</p><p>先说下自己的错误思路以及问题在哪</p><p>分别拿一个<code>dummy node</code>当奇偶链表的头结点，然后再把两个链表一拼接，就ok了</p><p>这样时间复杂度也是<code>o(N)</code>，空间复杂度是<code>o(1)</code>（额外使用了4个指针）</p><p>思路其实是没有问题的，但是进了链表的大坑——同一个链表分开操作。</p><p>直白讲就是，链表直接使用的就是引用，操作了就是操作了，那么后边再操作就不是初始化的链表了</p><p>下面的<strong>错误</strong>解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        odd = ListNode(<span class="number">-1</span>)</span><br><span class="line">        even = ListNode(<span class="number">-2</span>)</span><br><span class="line">        odd.next = head</span><br><span class="line">        even.next = head.next</span><br><span class="line"><span class="comment"># 企图构建一个奇数链表</span></span><br><span class="line">        p_odd = odd.next</span><br><span class="line">        <span class="keyword">while</span> p_odd <span class="keyword">and</span> p_odd.next:</span><br><span class="line">            p_odd.next = p_odd.next.next</span><br><span class="line">            p_odd = p_odd.next</span><br><span class="line">        <span class="comment">#######！！！！！！！！！！！！！！#######</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        问题就在这，上边操作后，链表已经不是原来的head了，而我还当</span></span><br><span class="line"><span class="string">        原来的head再进行偶数链表构建。XXX</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"><span class="comment"># 企图构建一个偶数链表</span></span><br><span class="line">        p_even = even.next</span><br><span class="line">        <span class="keyword">while</span> p_even <span class="keyword">and</span> p_even.next:</span><br><span class="line">            p_even.next = p_even.next.next</span><br><span class="line">            p_even = p_even.next</span><br><span class="line"></span><br><span class="line">        p_odd.next = even.next</span><br><span class="line">        <span class="keyword">return</span> odd</span><br></pre></td></tr></table></figure><h3 id="正确且简单解法"><a href="#正确且简单解法" class="headerlink" title="正确且简单解法"></a>正确且简单解法</h3><p>再链表上同时操作奇偶，需要注意的细节问题是：处理肯定先奇数再偶数，<code>p_even</code>指针始终靠后一点，所以循环的判断条件是判定，偶数或者偶数的下一个是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        even = head.next</span><br><span class="line">        p_even = even</span><br><span class="line">        p_odd = head</span><br><span class="line">        <span class="comment"># 一次同时来操作两个节点，最后的判断就是 even 因为even 后操作</span></span><br><span class="line">        <span class="keyword">while</span> p_even <span class="keyword">and</span> p_even.next:</span><br><span class="line">            p_odd.next = p_even.next</span><br><span class="line">            p_odd = p_odd.next</span><br><span class="line">            p_even.next = p_odd.next</span><br><span class="line">            p_even = p_even.next </span><br><span class="line">                    </span><br><span class="line">        p_odd.next = even</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&quot;奇偶链表&quot;&gt;&lt;a href=&quot;#奇偶链表&quot; class=&quot;headerlink&quot; title=&quot;奇偶链表&quot;&gt;&lt;/a&gt;奇偶链表&lt;/h2&gt;&lt;p&gt;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-725-分隔链表</title>
    <link href="http://yoursite.com/2020/02/07/leetcode-725-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/07/leetcode-725-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-07T03:25:57.000Z</published>
    <updated>2020-02-07T03:45:11.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p><p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p><p>返回一个符合上述规则的链表的列表。</p><p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p><p>示例 1：</p><p>输入:<br>root = [1, 2, 3], k = 5<br>输出: [[1],[2],[3],[],[]]<br>解释:<br>输入输出各部分都应该是链表，而不是数组。<br>例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。<br>第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。<br>最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。<br>示例 2：</p><p>输入:<br>root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br>解释:<br>输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/split-linked-list-in-parts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-linked-list-in-parts</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>讲一下主要的几个点：</p><ul><li><p>如何判断每次应该分几个？</p><p>其实就是看<code>元素个数➗划分k</code>的商是多少，余数是多少。按照题意，前面的应该是多的，后面的是少的，我们只需要把余数分配到前面几个就好了。举个例子</p><blockquote><p>eg: divmod(10,4) 商2余2，什么意思呢，就是将是个元素，划分成4块，每块有2个元素，余下来的2个元素放到前面两块，这样就划分成：3，3，2，2</p></blockquote></li><li><p>若有空节点，有且仅有可能有一个 </p><p>什么时候才会出现空节点也需要放入呢？就是需要划分块数大于节点个数的时候：<code>k&gt;n</code></p><p>这样才会出现需要<code>None</code> 来占位，并且出现这种情况之后，每个节点有且仅可能有一个节点。</p><blockquote><p>eg: [1,2,3]  5</p><p>将3个节点切分成5份，divmod(3,5)  商0余3，这样划分结果就是</p><p>[[1],[2],[3],[],[]]</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span><span class="params">(self, root: ListNode, k: int)</span> -&gt; List[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]*k</span><br><span class="line">        </span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        quotient, remainder = divmod(cnt,k)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            num = quotient + (<span class="number">1</span> <span class="keyword">if</span> remainder!=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            remainder = <span class="number">0</span> <span class="keyword">if</span> remainder==<span class="number">0</span> <span class="keyword">else</span> (remainder<span class="number">-1</span>)</span><br><span class="line">            p = root</span><br><span class="line">            <span class="keyword">while</span> num &gt; <span class="number">1</span>: <span class="comment"># 不需要真的移动num个 因为还涉及链表的处理</span></span><br><span class="line">                <span class="keyword">if</span> p:</span><br><span class="line">                    p = p.next</span><br><span class="line">                num -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                tmp = p.next</span><br><span class="line">                p.next = <span class="literal">None</span></span><br><span class="line">            result.append(root)</span><br><span class="line">            root = tmp</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>这个地方用到了3次循环，且每次都需要额外的一个变量控制循环次数，这样不如直接用for循环，可以减少很多额外操作。</p><p><strong>官方题解</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> N <span class="keyword">in</span> xrange(<span class="number">1001</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">break</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        width, remainder = divmod(N, k)</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            head = cur</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(width + (i &lt; remainder) - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> cur: cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                cur.next, cur = <span class="literal">None</span>, cur.next</span><br><span class="line">            ans.append(head)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https://leetcode-cn.com/problems/split-linked-list-<span class="keyword">in</span>-parts/solution/fen-ge-lian-biao-by-leetcode<span class="number">-2</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分隔链表&quot;&gt;&lt;a href=&quot;#分隔链表&quot; class=&quot;headerlink&quot; title=&quot;分隔链表&quot;&gt;&lt;/a&gt;分隔链表&lt;/h2&gt;&lt;p&gt;给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。&lt;/p&gt;
&lt;p&gt;每部分的长度应该尽可能的
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-61-旋转链表</title>
    <link href="http://yoursite.com/2020/02/07/leetcode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/07/leetcode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-06T17:29:29.000Z</published>
    <updated>2020-02-06T17:35:25.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>示例 2:</p><p>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不同于旋转数组，旋转数组方便的地方在于数组，下标可以直接使用。链表的优点是在于插入删除。</p><p>所以一开始的基本想法是 每次把尾部的节点拿出来前插到头结点前面，这样就完成了一次题意要求的移动，但这样的问题是，时间复杂度为<code>o(kn)</code></p><p>因为每次都需要遍历到最后到尾节点</p><h3 id="最优思路"><a href="#最优思路" class="headerlink" title="最优思路"></a>最优思路</h3><p>链表的优点在于方便的连接，所以只需要将本身链表的尾部和首部相连接，然后再从<code>head</code>移动<code>n-k个节点</code>，将该节点之后的部分断掉，那么就形成了 相当于将尾部<code>k</code>个节点移动到前面的操作了，最后返回断开位置后的节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        p = head</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p.next!= <span class="literal">None</span>:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        p.next = head</span><br><span class="line">        k = k%n</span><br><span class="line">        cnt = n-k<span class="number">-1</span> <span class="comment"># 小细节</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        return_head = p.next</span><br><span class="line">        p.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> return_head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;旋转链表&quot;&gt;&lt;a href=&quot;#旋转链表&quot; class=&quot;headerlink&quot; title=&quot;旋转链表&quot;&gt;&lt;/a&gt;旋转链表&lt;/h2&gt;&lt;p&gt;给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-189-旋转数组</title>
    <link href="http://yoursite.com/2020/02/06/leetcode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/02/06/leetcode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2020-02-05T17:52:01.000Z</published>
    <updated>2020-02-06T17:29:53.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p><p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为用python 解题嘛，上来最先考虑的就是python特性解决。</p><p>根据题意就是个循环移动过程，将尾部的元素拿出来放到头部</p><p>对应可用的list的方法就是<code>pop()</code>,<code>insert</code>()</p><blockquote><p><strong>insert</strong>(self, index, object, /)</p><p>  Insert object before index.</p><p><strong>pop</strong>(self, index=-1, /)</p><p>  Remove and return item at index (default last).</p><p>  Raises IndexError if list is empty or index is out of range.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">if</span> k == length <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            nums.insert(<span class="number">0</span>,nums.pop())</span><br><span class="line">            k-=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果深究时间复杂度的话，python底层实现中list的<code>insert()</code>时间复杂度是<code>o(N)</code> 而<code>pop()</code>时间复杂度是<code>o(1)</code>，并且调用<code>k</code>次，所以时间复杂度为<code>o(kn)</code></p><h3 id="正规解题姿势"><a href="#正规解题姿势" class="headerlink" title="正规解题姿势"></a>正规解题姿势</h3><p>可用通过多次旋转不同位置的元素来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k = k%n</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, k<span class="number">-1</span>)</span><br><span class="line">        self.reverse(nums, k, n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left],nums[right] = nums[right], nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总共调用了3次reverse，3次的时间复杂度分别为<code>o(n),o(k),o(n-k)</code></p><p>总的时间复杂度还是<code>o(n)</code>的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;旋转数组&quot;&gt;&lt;a href=&quot;#旋转数组&quot; class=&quot;headerlink&quot; title=&quot;旋转数组&quot;&gt;&lt;/a&gt;旋转数组&lt;/h2&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [1
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-186-翻转字符串中的单词II</title>
    <link href="http://yoursite.com/2020/02/05/leetcode-186-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DII/"/>
    <id>http://yoursite.com/2020/02/05/leetcode-186-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DII/</id>
    <published>2020-02-04T17:03:29.051Z</published>
    <updated>2020-02-04T17:07:31.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="翻转字符串中的单词II"><a href="#翻转字符串中的单词II" class="headerlink" title="翻转字符串中的单词II"></a>翻转字符串中的单词II</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例：</p><p>输入: [“t”,”h”,”e”,” “,”s”,”k”,”y”,” “,”i”,”s”,” “,”b”,”l”,”u”,”e”]<br>输出: [“b”,”l”,”u”,”e”,” “,”i”,”s”,” “,”s”,”k”,”y”,” “,”t”,”h”,”e”]<br>注意：</p><p>单词的定义是不包含空格的一系列字符<br>输入字符串中不会包含前置或尾随的空格<br>单词与单词之间永远是以单个空格隔开的<br>进阶：使用 O(1) 额外空间复杂度的原地解法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题目这么给输入输出，就是相当于给了你 <code>char array</code>，这样就可以通过o(1)的空间复杂度来实现。</p><p>原理同题目一</p><ul><li>先reverse整个数组</li><li>再逐个单词reverse</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(s,left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">                s[left],s[right] = s[right],s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = length<span class="number">-1</span></span><br><span class="line">        reverse(s,left,right)</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(right&lt;length):</span><br><span class="line">            <span class="keyword">if</span> s[right] == <span class="string">' '</span>:</span><br><span class="line">                reverse(s,left,right<span class="number">-1</span>)</span><br><span class="line">                left = right+<span class="number">1</span></span><br><span class="line">                right = right+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> right == length<span class="number">-1</span>: <span class="comment"># 这个地方需要注意下 这种形式给的字符串没有结尾符号需要自行判断</span></span><br><span class="line">                reverse(s,left,right)</span><br><span class="line">                right = right+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;翻转字符串中的单词II&quot;&gt;&lt;a href=&quot;#翻转字符串中的单词II&quot; class=&quot;headerlink&quot; title=&quot;翻转字符串中的单词II&quot;&gt;&lt;/a&gt;翻转字符串中的单词II&lt;/h2&gt;&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;p&gt;示例：&lt;
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-151-翻转字符串中的单词</title>
    <link href="http://yoursite.com/2020/02/05/leetcode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2020/02/05/leetcode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2020-02-04T16:25:24.589Z</published>
    <updated>2020-02-04T16:53:11.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="翻转字符串中的单词"><a href="#翻转字符串中的单词" class="headerlink" title="翻转字符串中的单词"></a>翻转字符串中的单词</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：</p><p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>说明：</p><p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照 剑指offer的解题思路 </p><ul><li>先翻转整个字符串</li><li>再逐个翻转单词</li></ul><p>主要的问题出现在，python解决过程出现的小坑</p><ul><li>python 中的string 是不可以进行修改的，所以做不到原地逆置</li><li>python可以用<code>split()</code>将单词分隔开，但是空白字符会之间变成 空<code>&#39;&#39;</code>，而不是<code>’ ‘</code></li></ul><blockquote><p>split(‘ ‘)和split()的切分是不一样的。</p><p>split(‘ ‘)会严格按照一个空格一个空格来切</p><p>split()会按照空白的来切掉</p><p>eg: “  hello   world    “</p><p>>&gt;&gt; a = ‘ hellow word  ‘</p><p>>&gt;&gt; a.split(‘ ‘)</p><p>[‘’, ‘hellow’, ‘’, ‘word’, ‘’, ‘’, ‘’]</p><p>>&gt;&gt; a.split()</p><p>[‘hellow’, ‘word’]</p></blockquote><p>题解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        s = self.reverse(s)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> s.split():</span><br><span class="line">            <span class="keyword">if</span> word != <span class="string">''</span>: <span class="comment"># 坑</span></span><br><span class="line">                result.append(self.reverse(word))</span><br><span class="line">        result = <span class="string">' '</span>.join(result)</span><br><span class="line">        <span class="keyword">return</span> result.strip()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self,s)</span>:</span></span><br><span class="line">        list_s = list(s) <span class="comment"># 坑</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(list_s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">            list_s[left],list_s[right] = list_s[right],list_s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(list_s)</span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>如果充分利用python 特性来解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverseWords1</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(s.split()[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>首先将字符串按照<code>&#39; &#39;</code>切分，然后得到一个list的切分结果，再将切分的结果逆置，达到了只需要把单词位置颠倒，就完成了。</p><ul><li><code>[::-1]</code>是将list内容进行逆置的操作</li><li>这个方法不用管空白字符的原因是 <code>split()</code>会以任何空白进行切割，可以参考上面对split的举例。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;翻转字符串中的单词&quot;&gt;&lt;a href=&quot;#翻转字符串中的单词&quot; class=&quot;headerlink&quot; title=&quot;翻转字符串中的单词&quot;&gt;&lt;/a&gt;翻转字符串中的单词&lt;/h2&gt;&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
