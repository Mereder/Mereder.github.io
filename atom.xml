<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Mereder</title>
  
  <subtitle>珍惜现在，感谢所有，不悔将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-18T16:47:31.285Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meng Di</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-223-矩形面积</title>
    <link href="http://yoursite.com/2020/03/19/Leetcode/leetcode-223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/03/19/Leetcode/leetcode-223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-03-18T16:34:38.000Z</published>
    <updated>2020-03-18T16:47:31.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩形面积"><a href="#矩形面积" class="headerlink" title="矩形面积"></a>矩形面积</h2><p>在<strong>二维</strong>平面上计算出两个<strong>由直线构成的</strong>矩形重叠后形成的总面积。</p><p>每个矩形由其左下顶点和右上顶点坐标表示，如图所示。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcyk5314sij30f208g0sm.jpg" alt="Rectangle Area"></p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -3, 0, 3, 4, 0, -1, 9, 2</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 假设矩形面积不会超出 <strong>int</strong> 的范围。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是计算交集部分的面积，然后让两个矩形面积相加再减去交集面积即可。</p><p>重点是交集部分如何进行计算。</p><p>如果有交集，那么交集矩形的左  边，肯定是两个矩形左  边  最大的那条边，交集矩形的右 边 ，肯定是两个矩形的右 边 最小的那条边。同理可以得到交集矩形的上下  边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">computeArea</span><span class="params">(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int)</span> -&gt; int:</span></span><br><span class="line">        rectangle_a = (C-A)*(D-B)  <span class="comment"># 求 矩形1</span></span><br><span class="line">        rectangle_b = (G-E)*(H-F)  <span class="comment"># 求 矩形2</span></span><br><span class="line">        <span class="comment"># 一定用max(0,xxx) 是因为不想交的话 会出现负值 </span></span><br><span class="line">        width = max(<span class="number">0</span>,min(C,G)-max(A,E))  <span class="comment"># 根据左右边  求 宽度</span></span><br><span class="line">        height = max(<span class="number">0</span>,min(D,H)-max(B,F)) <span class="comment"># 根据上下边  求 高度</span></span><br><span class="line">        <span class="keyword">return</span> rectangle_a+rectangle_b-width*height</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;矩形面积&quot;&gt;&lt;a href=&quot;#矩形面积&quot; class=&quot;headerlink&quot; title=&quot;矩形面积&quot;&gt;&lt;/a&gt;矩形面积&lt;/h2&gt;&lt;p&gt;在&lt;strong&gt;二维&lt;/strong&gt;平面上计算出两个&lt;strong&gt;由直线构成的&lt;/strong&gt;矩形重叠后形成的总面积
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-836-矩形重叠</title>
    <link href="http://yoursite.com/2020/03/18/Leetcode/leetcode-836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
    <id>http://yoursite.com/2020/03/18/Leetcode/leetcode-836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</id>
    <published>2020-03-18T15:26:23.000Z</published>
    <updated>2020-03-18T15:48:20.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a>矩形重叠</h2><p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>两个矩形 <code>rec1</code> 和 <code>rec2</code> 都以含有四个整数的列表的形式给出。</li><li>矩形中的所有坐标都处于 <code>-10^9</code> 和 <code>10^9</code> 之间。</li><li><code>x</code> 轴默认指向右，<code>y</code> 轴默认指向上。</li><li>你可以仅考虑矩形是正放的情况。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单题，在于题目给的条件太多了。矩形正放置，不会出现倾斜的情况。</p><p>只需要考虑四个情况即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                  <span class="comment">###############</span></span><br><span class="line">                  <span class="comment">#     上      #</span></span><br><span class="line">                  <span class="comment">###############</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############    ###############   ###################</span></span><br><span class="line"><span class="comment">#      左    #    #             #   #       右         # </span></span><br><span class="line"><span class="comment">##############    ##############    ###################</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">##############</span></span><br><span class="line">                  <span class="comment">#      下    #</span></span><br><span class="line">                  <span class="comment">##############</span></span><br></pre></td></tr></table></figure><p>根据这四个情况进行四种判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isRectangleOverlap</span><span class="params">(self, rec1: List[int], rec2: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 以2作为中心矩形</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>]         <span class="comment">#  1 在 2 上</span></span><br><span class="line">                    <span class="keyword">or</span> rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>]      <span class="comment">#  1 在 2  右</span></span><br><span class="line">                    <span class="keyword">or</span> rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>]      <span class="comment">#  1 在 2 下</span></span><br><span class="line">                    <span class="keyword">or</span> rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>])     <span class="comment">#  1 在 2 左</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;矩形重叠&quot;&gt;&lt;a href=&quot;#矩形重叠&quot; class=&quot;headerlink&quot; title=&quot;矩形重叠&quot;&gt;&lt;/a&gt;矩形重叠&lt;/h2&gt;&lt;p&gt;矩形以列表 &lt;code&gt;[x1, y1, x2, y2]&lt;/code&gt; 的形式表示，其中 &lt;code&gt;(x1, y1)&lt;/c
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>排序模块的Reranker</title>
    <link href="http://yoursite.com/2020/03/18/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/Rerank/"/>
    <id>http://yoursite.com/2020/03/18/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/Rerank/</id>
    <published>2020-03-18T11:14:43.000Z</published>
    <updated>2020-03-18T16:52:13.924Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="项目经历" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-灯泡开关问题总结</title>
    <link href="http://yoursite.com/2020/03/17/%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/17/%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-17T14:31:49.000Z</published>
    <updated>2020-03-17T14:33:10.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="灯泡开关问题1"><a href="#灯泡开关问题1" class="headerlink" title="灯泡开关问题1"></a>灯泡开关问题1</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;灯泡开关问题1&quot;&gt;&lt;a href=&quot;#灯泡开关问题1&quot; class=&quot;headerlink&quot; title=&quot;灯泡开关问题1&quot;&gt;&lt;/a&gt;灯泡开关问题1&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-周赛-179场</title>
    <link href="http://yoursite.com/2020/03/17/Leetcode/leetcode%E5%91%A8%E8%B5%9B179%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/17/Leetcode/leetcode%E5%91%A8%E8%B5%9B179%E5%9C%BA/</id>
    <published>2020-03-17T14:23:16.000Z</published>
    <updated>2020-03-18T12:29:01.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛179场"><a href="#周赛179场" class="headerlink" title="周赛179场"></a>周赛179场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener">生成每种字符都是奇数个的字符串</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/bulb-switcher-iii/" target="_blank" rel="noopener">灯泡开关 III</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/" target="_blank" rel="noopener">通知所有员工所需的时间</a><br><code>6 分</code> - <a href="https://leetcode-cn.com/problems/frog-position-after-t-seconds/" target="_blank" rel="noopener">T 秒后青蛙的位置</a></p><h3 id="T1：-生成每种字符都是奇数个的字符串"><a href="#T1：-生成每种字符都是奇数个的字符串" class="headerlink" title="T1： 生成每种字符都是奇数个的字符串"></a>T1： 生成每种字符都是奇数个的字符串</h3><p>思路就是：奇数的话返回 奇数个’a’，偶数的话返回n-1个’b’，加一个’a‘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTheString</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'a'</span>*(n<span class="number">-1</span>)+<span class="string">'b'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'a'</span>*n</span><br></pre></td></tr></table></figure><h3 id="T2-灯泡开关"><a href="#T2-灯泡开关" class="headerlink" title="T2:灯泡开关"></a>T2:灯泡开关</h3><p>灯泡开关系列问题 :<a href="">灯泡开关</a></p><h3 id="T3：-通知所有员工的时间"><a href="#T3：-通知所有员工的时间" class="headerlink" title="T3：  通知所有员工的时间"></a>T3：  通知所有员工的时间</h3><p>上来就想dfs的，写完之后超时了。发现问题在于，每次我的dfs搜索空间都是所有员工，其实只需要搜索自己的下属就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfMinutes</span><span class="params">(self, n: int, headID: int, manager: List[int], informTime: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.nxt = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># 需要先将每个人的下属放进来</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> manager[i] == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            self.nxt[manager[i]].append(i)</span><br><span class="line">        res = self.helper(headID,manager,informTime)+informTime[headID]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,headID,manager,informTime)</span>:</span></span><br><span class="line">        cur_time = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每次搜索自己的下属就可以了</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> self.nxt[headID]:</span><br><span class="line">            t = self.helper(child,manager,informTime)+informTime[child]</span><br><span class="line">            cur_time = max(cur_time,t)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur_time</span><br></pre></td></tr></table></figure><p>BFS思路差不多，主要也是每次入队的时候，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛179场&quot;&gt;&lt;a href=&quot;#周赛179场&quot; class=&quot;headerlink&quot; title=&quot;周赛179场&quot;&gt;&lt;/a&gt;周赛179场&lt;/h2&gt;&lt;p&gt;&lt;code&gt;3 分&lt;/code&gt; - &lt;a href=&quot;https://leetcode-cn.com/pr
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>字符串的排列</title>
    <link href="http://yoursite.com/2020/03/15/SwordOffer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/03/15/SwordOffer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2020-03-15T15:00:55.000Z</published>
    <updated>2020-03-15T15:03:33.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。 </p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>限制：</p><p>1 &lt;= s 的长度 &lt;= 8</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯算法的基本case例题</p><p>注意细节问题：如果存在重复元素，那么就会存在重复的排列情况，这里比较简单的使用<code>set</code>进行了去重，如果不使用<code>set</code>的话，需要对字符串排序，然后再在遍历过程中进行控制，如果相同则跳过的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res = set([])</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="comment"># s = sorted(s)</span></span><br><span class="line">        visited = [<span class="literal">False</span>]*len(s)</span><br><span class="line">        self.dfs(res,stack,visited,s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,res,stack,visited,s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(stack) == len(s):</span><br><span class="line">            res.add(<span class="string">''</span>.join(stack))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="comment"># if i &gt;0 and s[i] == s[i-1] and not visited[i]:</span></span><br><span class="line">            <span class="comment">#     continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">                stack.append(s[i])</span><br><span class="line"></span><br><span class="line">                self.dfs(res,stack,visited,s)</span><br><span class="line"></span><br><span class="line">                visited[i] = <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串的排列&quot;&gt;&lt;a href=&quot;#字符串的排列&quot; class=&quot;headerlink&quot; title=&quot;字符串的排列&quot;&gt;&lt;/a&gt;字符串的排列&lt;/h2&gt;&lt;p&gt;输入一个字符串，打印出该字符串中字符的所有排列。 &lt;/p&gt;
&lt;p&gt;你可以以任意顺序返回这个字符串数组，但里面
      
    
    </summary>
    
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>数组中的逆序对数</title>
    <link href="http://yoursite.com/2020/03/15/SwordOffer/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/15/SwordOffer/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/</id>
    <published>2020-03-15T13:11:43.000Z</published>
    <updated>2020-03-15T14:01:56.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组中的逆序对数"><a href="#数组中的逆序对数" class="headerlink" title="数组中的逆序对数"></a>数组中的逆序对数</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p> 示例 1:</p><p>输入: [7,5,6,4]<br>输出: 5</p><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 50000</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较经典的题目，之前一直记得总体解决方案是通过 归并排序来实现的。</p><p>但是自己python 盲写了一遍并没有成功AC…</p><p>还是细节地方没有考虑好：</p><ul><li>遍历顺序：<code>从大到小进行遍历比较</code></li><li>cnt 计数 每次加上的值是<code>right-mid</code>的个数</li><li>！！！ 每次merger 操作之后记得将  新数组的值赋给原来的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        arr = nums.copy()</span><br><span class="line">        res = self.split(nums,arr,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(self,nums,arr,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            arr[left] = nums[left]</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        left_res = self.split(nums,arr,left,mid)</span><br><span class="line">        right_res = self.split(nums,arr,mid+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历顺序： 都是从 左侧  和 右侧 的 尾部开始</span></span><br><span class="line">        l = mid</span><br><span class="line">        r = right</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        j = right</span><br><span class="line">        <span class="keyword">while</span> l &gt;= left <span class="keyword">and</span> r &gt;= mid+<span class="number">1</span>:  <span class="comment">## 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] &gt; nums[r]:</span><br><span class="line">                arr[j] = nums[l]</span><br><span class="line">                cnt += r-mid  <span class="comment">#### 加上的个数</span></span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr[j] = nums[r]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= left:</span><br><span class="line">            arr[j] = nums[l]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &gt;= mid+<span class="number">1</span>:</span><br><span class="line">            arr[j] = nums[r]</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="comment">####  重置数组啊！！！</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">            nums[k] = arr[k]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left_res+right_res+cnt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组中的逆序对数&quot;&gt;&lt;a href=&quot;#数组中的逆序对数&quot; class=&quot;headerlink&quot; title=&quot;数组中的逆序对数&quot;&gt;&lt;/a&gt;数组中的逆序对数&lt;/h2&gt;&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组
      
    
    </summary>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-695-岛屿的最大面积</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode/leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode/leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-03-15T09:22:50.000Z</published>
    <updated>2020-03-18T16:52:29.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p><p>示例 1:</p><p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p><p>示例 2:</p><p>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没啥好说的，直接dfs 遍历有<code>1</code>相连接的区域，优化的点在于，统计过的岛屿可以直接置为<code>0</code> 避免重复统计同一片岛屿</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    tmp = self.dfs(grid,i,j,m,n)</span><br><span class="line">                    mx = max(tmp,mx)    </span><br><span class="line">        <span class="keyword">return</span> mx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">dfs</span><span class="params">(self,grid,i,j,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> j &lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;= m <span class="keyword">or</span> j &gt;=n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        cnt += self.dfs(grid,i<span class="number">-1</span>,j,m,n)</span><br><span class="line">        cnt += self.dfs(grid,i+<span class="number">1</span>,j,m,n)</span><br><span class="line">        cnt += self.dfs(grid,i,j<span class="number">-1</span>,m,n)</span><br><span class="line">        cnt += self.dfs(grid,i,j+<span class="number">1</span>,m,n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p>时间复杂度是 $O(M*N)$，其中的M表示网格图的行数，N表示网格图的列数。 实际表示的含义就是每个点都遍历了一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;岛屿的最大面积&quot;&gt;&lt;a href=&quot;#岛屿的最大面积&quot; class=&quot;headerlink&quot; title=&quot;岛屿的最大面积&quot;&gt;&lt;/a&gt;岛屿的最大面积&lt;/h2&gt;&lt;p&gt;给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直)
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-周赛-180场</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode/leetcode%E5%91%A8%E8%B5%9B180%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode/leetcode%E5%91%A8%E8%B5%9B180%E5%9C%BA/</id>
    <published>2020-03-15T09:18:12.000Z</published>
    <updated>2020-03-15T14:29:42.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛"><a href="#周赛" class="headerlink" title="周赛"></a>周赛</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/" target="_blank" rel="noopener">矩阵中的幸运数</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener">设计一个支持增量操作的栈</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" target="_blank" rel="noopener">将二叉搜索树变平衡</a><br><code>6 分</code> - <a href="https://leetcode-cn.com/problems/maximum-performance-of-a-team/" target="_blank" rel="noopener">最大的团队表现值</a></p><h3 id="矩阵中的幸运数"><a href="#矩阵中的幸运数" class="headerlink" title="矩阵中的幸运数"></a>矩阵中的幸运数</h3><p>暴力破解，给的条件限制不大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">luckyNumbers</span> <span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                val = matrix[i][j]</span><br><span class="line">                <span class="keyword">if</span> self.isLucky(val,i,j,m,n,matrix):</span><br><span class="line">                    res.append(val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLucky</span><span class="params">(self,val,i,j,m,n,matrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val == min(matrix[i]): <span class="comment"># 一行的最小值</span></span><br><span class="line">            mx = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> range(m):</span><br><span class="line">                mx = max(matrix[row][j],mx)</span><br><span class="line">            <span class="keyword">if</span> mx == val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>时间复杂度….严格来讲这个有<code>O(N^3)</code>之多…</p><h3 id="设计一个支持增量操作的栈"><a href="#设计一个支持增量操作的栈" class="headerlink" title="设计一个支持增量操作的栈"></a>设计一个支持增量操作的栈</h3><p>模拟题， 注意下实现细节就好啦</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxSize: int)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        self.capacity = maxSize</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.cnt &lt; self.capacity:</span><br><span class="line">            self.stack.append(x)</span><br><span class="line">            self.cnt+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.cnt &lt;= <span class="number">0</span>:</span><br><span class="line">            rt =  <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rt = self.stack.pop()</span><br><span class="line">            self.cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rt</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, k: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt;= self.cnt:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                self.stack[i] += val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.cnt):</span><br><span class="line">                self.stack[i] += val</span><br><span class="line"><span class="comment"># Your CustomStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CustomStack(maxSize)</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># obj.increment(k,val)</span></span><br></pre></td></tr></table></figure><p>分析下时间复杂度：</p><p><code>pop</code>：时间复杂度为<code>o(1)</code></p><p><code>push</code>：时间复杂度<code>o(1)</code></p><h3 id="将二叉树变平衡"><a href="#将二叉树变平衡" class="headerlink" title="将二叉树变平衡"></a>将二叉树变平衡</h3><p>想到了当时平衡二叉搜索树的调整过程，但是印象中那个操作太难了。。。</p><p>本题：二叉树搜索树的中序遍历就是有序数组，根据有序数组构建平衡搜索二叉树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balanceBST</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 中序遍历的结果是 有序的</span></span><br><span class="line">        <span class="comment"># 平衡建树 就是让左右两部分尽量个数均匀</span></span><br><span class="line">        self.nums = []</span><br><span class="line">        self.visitBST(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(self.nums)<span class="number">-1</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(self.nums[mid])</span><br><span class="line">        root.left = self.buildBST(root,left,mid<span class="number">-1</span>)</span><br><span class="line">        root.right = self.buildBST(root,mid+<span class="number">1</span>,right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildBST</span><span class="params">(self,root,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        node = TreeNode(self.nums[mid])</span><br><span class="line">        node.left = self.buildBST(node,left,mid<span class="number">-1</span>)</span><br><span class="line">        node.right = self.buildBST(node,mid+<span class="number">1</span>,right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visitBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        self.visitBST(root.left)</span><br><span class="line">        self.nums.append(root.val)</span><br><span class="line">        self.visitBST(root.right)</span><br></pre></td></tr></table></figure><h3 id="最大的团队表现值"><a href="#最大的团队表现值" class="headerlink" title="最大的团队表现值"></a>最大的团队表现值</h3><p>先将efficiency按照降序排列，然后从前向后遍历，每次都计算并更新res的值</p><p>使用<code>优先队列</code>可以再遍历过程中，如果speed小于队首，则跳过，否则将speed 最小的先出队，再加入一个新的speed。</p><p>（主要的思想是贪心，但是为啥这样是有效的需要证明….）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPerformance</span><span class="params">(self, n: int, speed: List[int], efficiency: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        cls = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            cls.append((efficiency[i],speed[i]))</span><br><span class="line">        </span><br><span class="line">        cls = sorted(cls,key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        q = []</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &lt; k:</span><br><span class="line">                heapq.heappush(q,cls[i][<span class="number">1</span>])</span><br><span class="line">                s += cls[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q[<span class="number">0</span>] &lt; cls[i][<span class="number">1</span>]:</span><br><span class="line">                    s -= heapq.heappop(q)</span><br><span class="line">                    s += cls[i][<span class="number">1</span>]</span><br><span class="line">                    heapq.heappush(q,cls[i][<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># heapq.heappush(q,cls[i][1])</span></span><br><span class="line">            <span class="comment"># s += cls[i][1]</span></span><br><span class="line">            <span class="comment"># if len(q) &gt; k:</span></span><br><span class="line">            <span class="comment">#     s -= heapq.heappop(q)</span></span><br><span class="line">            res = max(res, s*cls[i][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛&quot;&gt;&lt;a href=&quot;#周赛&quot; class=&quot;headerlink&quot; title=&quot;周赛&quot;&gt;&lt;/a&gt;周赛&lt;/h2&gt;&lt;p&gt;&lt;code&gt;3 分&lt;/code&gt; - &lt;a href=&quot;https://leetcode-cn.com/problems/lucky-num
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-333-最大BST树</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode/leetcode-333-%E6%9C%80%E5%A4%A7BST%E6%A0%91/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode/leetcode-333-%E6%9C%80%E5%A4%A7BST%E6%A0%91/</id>
    <published>2020-03-15T02:16:57.000Z</published>
    <updated>2020-03-15T10:22:09.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最大BST树"><a href="#最大BST树" class="headerlink" title="最大BST树"></a>最大BST树</h2><p>给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，其中最大指的是子树节点数最多的。</p><p>注意:<br>子树必须包含其所有后代。</p><p>示例:</p><p>输入: [10,5,15,1,8,null,7]</p><p>   10<br>   / \<br>  5  15<br> / \   \<br>1   8   7</p><p>输出: 3<br>解释: 高亮部分为最大的 BST 子树。<br>     返回值 3 在这个样例中为子树大小。<br>进阶:<br>你能想出用 O(n) 的时间复杂度解决这个问题吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/largest-bst-subtree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-bst-subtree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>见到这个题的时候，瞬间想到了之前做过的一次双周赛的题目：<a href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/" target="_blank" rel="noopener">1373. 二叉搜索子树的最大键值和</a></p><p>本质思想都是 树节点的回溯以及判断 是否是BST的过程。</p><p>以往判断一棵树是不是BST返回的信息只需要是True or False</p><p>这里每次返回的信息只告诉你（info，left_boundary，right_boundary），如果满足BST会对 <code>info</code>字段进行更新，如果不满足则会返回 (info,  minInt,  maxInt) 来表示只要包含此节点都不可能成为BST</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestBSTSubtree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        final = self.isBST(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBST</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        return (info, left_boundary, right_boundary)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="comment"># 对于空节点，是可以任意节点的子节点的  所以 让左边最大，右边界最小</span></span><br><span class="line">            <span class="comment"># 可以 满足 下面 对BST的判断</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>))</span><br><span class="line">        </span><br><span class="line">        left_res = self.isBST(root.left)</span><br><span class="line">        right_res = self.isBST(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断左子树的最大值 小于 根； 右子树的最小值  大于 根  则为BST</span></span><br><span class="line">        <span class="keyword">if</span> left_res[<span class="number">2</span>] &lt; root.val  <span class="keyword">and</span>  root.val &lt; right_res[<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 本题 info: 最大个数，当然这里可以换成 最大和  最大值 最小值 等 其他信息</span></span><br><span class="line">            s = <span class="number">1</span> + left_res[<span class="number">0</span>] + right_res[<span class="number">0</span>]</span><br><span class="line">            self.res = max(self.res,s)</span><br><span class="line">            <span class="keyword">return</span> (s,min(left_res[<span class="number">1</span>],root.val), max(right_res[<span class="number">2</span>],root.val))</span><br><span class="line"><span class="comment">#  跟空节点截然相反，如果一个根不可以是BST，那么返回这个根 左边是最小， 右边 最大 </span></span><br><span class="line">        <span class="comment">#  这样  回溯都上面任何一个包含此节点 根 都不可能为 BST</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, float(<span class="string">'-inf'</span>),float(<span class="string">'inf'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最大BST树&quot;&gt;&lt;a href=&quot;#最大BST树&quot; class=&quot;headerlink&quot; title=&quot;最大BST树&quot;&gt;&lt;/a&gt;最大BST树&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，其中最大指的是子树节点数最多的。&lt;/p&gt;
&lt;p&gt;注意
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-300-最长上升子序列</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode/leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode/leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-14T16:05:04.000Z</published>
    <updated>2020-03-14T16:17:06.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>复习要点：</p><p>dp 理解dp所表示的含义：以当前作为结尾的最长上升子序列的长度</p></blockquote><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h4><p>建立一个dp数组，来保存最长上升子序列的长度。<code>dp[i]</code> 表示的就是<code>第i个</code>数作为最长上升子序列的结尾时，对应的长度。那么dp[i]的更新依赖于前面所有<code>nums[j]&lt;nums[i]</code>的值更新 $dp[i] = max\{dp[0],dp[1]…dp[i-1]\} + 1$</p><p>实际含义就是，前面所有比nums[i]小的数，都是以nums[i]为结尾的最长上升子序列的一部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>]* len(nums)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt; len(nums):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; cur:</span><br><span class="line">                <span class="keyword">if</span> nums[cur] &gt; nums[j]:</span><br><span class="line">                    dp[cur] = max(dp[cur],dp[j]+<span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            res = max(res,dp[cur])</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>相当于两次遍历，时间复杂度为$o(n^2)$， 空间复杂度为 <code>o(n)</code></p><h3 id="进阶思路"><a href="#进阶思路" class="headerlink" title="进阶思路"></a>进阶思路</h3><h4 id="dp-二分查找"><a href="#dp-二分查找" class="headerlink" title="dp+二分查找"></a>dp+二分查找</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;复习要点：&lt;/p&gt;
&lt;p&gt;dp 理解dp所表示的含义：以当前作为结尾的最长上升子序列的长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最长上升子序列&quot;&gt;&lt;a href=&quot;#最长上升子序列&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1073-字符串的最大公因子</title>
    <link href="http://yoursite.com/2020/03/12/Leetcode/leetcode-1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/"/>
    <id>http://yoursite.com/2020/03/12/Leetcode/leetcode-1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</id>
    <published>2020-03-12T13:13:00.000Z</published>
    <updated>2020-03-12T13:55:28.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串的最大公因子"><a href="#字符串的最大公因子" class="headerlink" title="字符串的最大公因子"></a>字符串的最大公因子</h2><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p>示例 1：</p><p>输入：str1 = “ABCABC”, str2 = “ABC”<br>输出：”ABC”<br>示例 2：</p><p>输入：str1 = “ABABAB”, str2 = “ABAB”<br>输出：”AB”<br>示例 3：</p><p>输入：str1 = “LEET”, str2 = “CODE”<br>输出：””</p><p>提示：</p><p>1 &lt;= str1.length &lt;= 1000<br>1 &lt;= str2.length &lt;= 1000<br>str1[i] 和 str2[i] 为大写英文字母</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-common-divisor-of-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>自己的思路就是暴力穷举，如果存在这样字符串X，那一定是众多可行的解中最长的。所以考虑从后向前遍历，如果有满足的直接返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        n = min(len(str1),len(str2))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> (len(str1)%i)==<span class="number">0</span> <span class="keyword">and</span> (len(str2)%i)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> str1[:i]*(len(str1)//i) == str1 <span class="keyword">and</span> str1[:i]*(len(str2)//i) == str2:</span><br><span class="line">                    <span class="keyword">return</span> str1[:i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><h3 id="更好的思路"><a href="#更好的思路" class="headerlink" title="更好的思路"></a>更好的思路</h3><p>对于上面的暴力方法，我们可以发现<code>len(str1)%i==0 and len(str2)%i==0</code>实际上就是在找最大公约数的过程，那我们可以直接求出来一个最大公约数，然后直接check 能不能成立。 这里面存在着该问题正确性的证明。<br>详细证明可以参考 <a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/zi-fu-chuan-de-zui-da-gong-yin-zi-by-leetcode-solu/" target="_blank" rel="noopener"> 官方题解</a></p><p>证明的大概思路就是子问题套娃，如果存在一个x前缀串成立，那么就必然存在x’ 是最大公约数使问题成立。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        candidate_len = math.gcd(len(str1), len(str2))</span><br><span class="line">        candidate = str1[: candidate_len]</span><br><span class="line">        <span class="keyword">if</span> candidate * (len(str1) // candidate_len) == str1 <span class="keyword">and</span> candidate * (len(str2) // candidate_len) == str2:</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><h3 id="最优思路"><a href="#最优思路" class="headerlink" title="最优思路"></a>最优思路</h3><p>既然存在一个字符串x能同时呗str1 和str2进行整除，那str1和str2肯定有且仅包含字符串x。那么<code>str1+str2</code>的字符串和肯定也是只有x的。<code>str1+str2 == str2+str1</code>不管前后顺序，他们都是只有字符串x的。所以如果这个条件成立，那么肯定存在这样的解，如果不成立，那肯定不存在，直接返回空。</p><p>成立的话，根据前面解法的分析，直接返回最大公因数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        candidate_len = math.gcd(len(str1), len(str2))</span><br><span class="line">        candidate = str1[: candidate_len]</span><br><span class="line">        <span class="keyword">if</span> str1 + str2 == str2 + str1:</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串的最大公因子&quot;&gt;&lt;a href=&quot;#字符串的最大公因子&quot; class=&quot;headerlink&quot; title=&quot;字符串的最大公因子&quot;&gt;&lt;/a&gt;字符串的最大公因子&lt;/h2&gt;&lt;p&gt;对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-1013-将数组分成和相等的三个部分</title>
    <link href="http://yoursite.com/2020/03/11/Leetcode/leetcode-1013-%E5%88%86%E6%88%903%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E9%83%A8%E5%88%86/"/>
    <id>http://yoursite.com/2020/03/11/Leetcode/leetcode-1013-%E5%88%86%E6%88%903%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E9%83%A8%E5%88%86/</id>
    <published>2020-03-11T01:21:53.000Z</published>
    <updated>2020-03-18T16:52:40.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将数组分成和相等的三个部分"><a href="#将数组分成和相等的三个部分" class="headerlink" title="将数组分成和相等的三个部分"></a>将数组分成和相等的三个部分</h2><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p><p>形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。</p><p>示例 1：</p><p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]<br>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1<br>示例 2：</p><p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]<br>输出：false<br>示例 3：</p><p>输入：[3,3,6,5,-2,2,5,1,-9,4]<br>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p><p>提示：</p><p>3 &lt;= A.length &lt;= 50000<br>-10^4 &lt;= A[i] &lt;= 10^4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;将数组分成和相等的三个部分&quot;&gt;&lt;a href=&quot;#将数组分成和相等的三个部分&quot; class=&quot;headerlink&quot; title=&quot;将数组分成和相等的三个部分&quot;&gt;&lt;/a&gt;将数组分成和相等的三个部分&lt;/h2&gt;&lt;p&gt;给你一个整数数组 A，只有可以将其划分为三个和相等的
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 装饰器</title>
    <link href="http://yoursite.com/2020/03/09/python/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2020/03/09/python/%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2020-03-09T14:43:04.925Z</published>
    <updated>2020-03-09T15:32:09.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>这个东西看起来高大上，实际上就是函数套娃。:weary:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am doing some boring work before executing a_func()"</span>)</span><br><span class="line"> </span><br><span class="line">        a_func()</span><br><span class="line"> </span><br><span class="line">        print(<span class="string">"I am doing some boring work after executing a_func()"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to remove my foul smell"</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: "I am the function which needs some decoration to remove my foul smell"</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure><p>上面的例子虽然简单(两层套娃)，但是基本就是<strong>装饰器</strong>的使用流程。那么我们将其改变成装饰器来看下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Hey you! Decorate me!"""</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to "</span></span><br><span class="line">          <span class="string">"remove my foul smell"</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#the @a_new_decorator is just a short way of saying:</span></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br></pre></td></tr></table></figure><p>这里面还是有几个需要注意的点：</p><ul><li>装饰器函数里面还有一个wrapTheFunction()，这个内置函数的存在是方便在真正调用被装饰函数之前和之后也可以进行一些操作，同时让装饰器函数能够返回一个\<function\></li><li>分清楚返回的是函数<code>f</code>还是函数结果<code>f()</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h2&gt;&lt;p&gt;这个东西看起来高大上，实际上就是函数套娃。:weary:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode/leetcode-322-零钱兑换</title>
    <link href="http://yoursite.com/2020/03/08/Leetcode/leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/03/08/Leetcode/leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2020-03-08T15:39:23.000Z</published>
    <updated>2020-03-18T17:04:42.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>示例 1:</p><p>输入: coins = [1, 2, 5], amount = 11<br>输出: 3<br>解释: 11 = 5 + 5 + 1<br>示例 2:</p><p>输入: coins = [2], amount = 3<br>输出: -1<br>说明:<br>你可以认为每种硬币的数量是无限的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一：自顶向下搜索回溯（超时）"><a href="#方法一：自顶向下搜索回溯（超时）" class="headerlink" title="方法一：自顶向下搜索回溯（超时）"></a>方法一：自顶向下搜索回溯（超时）</h4><p>暴力搜索，时间复杂度较高</p><p>时间复杂度：<br>O(S^n)，在最坏的情况下，复杂度是硬币数量的指数 ，是因为每个硬币面值<code>c</code>有$\frac{s}{c}$个方案。</p><p>因此，可能的组合数为：</p><script type="math/tex; mode=display">\frac{s}{c_1}*\frac{s}{c_2}*\frac{s}{c_3}</script><p>空间复杂度为O(n)，只要来自递归调用栈的深度。</p><blockquote><p> eg：coins = [1, 2, 5], amount = 11</p><p> 基本思路就是<br> f(11) = min({f(11-1)},{f(11-2)},{f(11-5)})=min(f(10),f(9),f(6))</p><p> 然后再递归去计算<code>f(10),f(9),f(9)</code>如果画出来递归树，可以看到有非常多的重复计算。</p></blockquote><h4 id="方法二：记忆化搜索（拿缓存来存储已经计算过的数）"><a href="#方法二：记忆化搜索（拿缓存来存储已经计算过的数）" class="headerlink" title="方法二：记忆化搜索（拿缓存来存储已经计算过的数）"></a>方法二：记忆化搜索（拿缓存来存储已经计算过的数）</h4><p>经典的记忆化方法就是拿一个数组来存储，数组大小为总金额，如果某些地方计算过，则直接查表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始查表方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.mem = [<span class="number">0</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.helper(coins,amount)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,coins,rem)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> rem &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> rem == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先查表，如果已经计算过则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> self.mem[rem] != <span class="number">0</span>: <span class="keyword">return</span> self.mem[rem]</span><br><span class="line"><span class="comment"># 当前没有被计算过，则需要计算当前rem钱数所需要的最小硬币数</span></span><br><span class="line">        tmp_min = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="comment"># 尝试每种硬币数方案</span></span><br><span class="line">            res = self.helper(coins,rem-coin)</span><br><span class="line">            <span class="comment"># 取硬币数最少方案</span></span><br><span class="line">            <span class="keyword">if</span> res &gt;=<span class="number">0</span> <span class="keyword">and</span> res &lt; tmp_min:</span><br><span class="line">                tmp_min = <span class="number">1</span>+res</span><br><span class="line">        <span class="comment"># 有解 则返回min  无解返回-1</span></span><br><span class="line">        self.mem[rem] = <span class="number">-1</span> <span class="keyword">if</span> tmp_min == float(<span class="string">'inf'</span>) <span class="keyword">else</span> tmp_min</span><br><span class="line">        <span class="keyword">return</span> self.mem[rem]</span><br></pre></td></tr></table></figure><p><strong>！！！！</strong></p><p>讨论区，看到的使用python屌炸的记忆化操作 <code>functools.lru_cache(amount)</code></p><p>使用一个装饰器，来实现高效缓存。</p><blockquote><p>functools.lru_cache的作用主要是用来做缓存，他能把相对耗时的函数结果进行保存，避免传入相同的参数重复计算。同时，缓存并不会无限增长，不用的缓存会被释放。 <a href="https://blog.csdn.net/wzqnls/article/details/78506022" target="_blank" rel="noopener">来源</a></p><p>functools.lru_cache(maxsize=128, typed=False)有两个可选参数，我们来看看他们分别代表的意义。</p><ul><li><p>maxsize代表缓存的内存占用值，超过这个值之后，就的结果就会被释放，然后将新的计算结果进行缓存,其值应当设为2的幂次</p></li><li><p>typed若为True，则会把不同的参数类型得到的结果分开保存 *</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line"><span class="meta">        @functools.lru_cache(amount)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(rem)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> rem &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> rem == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            mini = int(<span class="number">1e9</span>)</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> self.coins:</span><br><span class="line">                res = dp(rem - coin)</span><br><span class="line">                <span class="keyword">if</span> res &gt;= <span class="number">0</span> <span class="keyword">and</span> res &lt; mini:</span><br><span class="line">                    mini = res + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> mini <span class="keyword">if</span> mini &lt; int(<span class="number">1e9</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        self.coins = coins</span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>这里有个知识点就是<strong>装饰器</strong></p><p>装饰器说白了就是方便进行函数嵌套使用，不用真的去嵌套着写，需要嵌套的话用<code>@fun</code>来装饰即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        dp = [<span class="number">0</span>]+[float(<span class="string">'inf'</span>)]*amount</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(coin,amount+<span class="number">1</span>):</span><br><span class="line">                dp[i] = min(dp[i],dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount]!=float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;零钱兑换&quot;&gt;&lt;a href=&quot;#零钱兑换&quot; class=&quot;headerlink&quot; title=&quot;零钱兑换&quot;&gt;&lt;/a&gt;零钱兑换&lt;/h2&gt;&lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-239-滑动窗口的最大值</title>
    <link href="http://yoursite.com/2020/03/07/Leetcode/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2020/03/07/Leetcode/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2020-03-07T13:29:49.000Z</published>
    <updated>2020-03-10T13:29:39.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>示例:</p><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p><p>  滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p><p>提示：</p><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>暴力方法</strong>：</p><p>每次移动到一个新的窗口都计算一次本窗口内的最大值，如果窗口大小是K，一共N个数，时间复杂度为<code>o(kn)</code></p><p><strong>管理下标+双端队列</strong></p><ul><li><p>管理下标</p><p>因为该方法(窗口里面)处理的并不是实际的值，而是值所在的下标，这样的好处在于可以判断出当某个值已经出了窗口的时候，可以及时对窗口内的最大值进行更新</p></li><li><p>双端队列（可以看做滑动窗口）</p><p>使用的是双端队列，好处在于新的值可以从后侧入队，已经失效的最大值，则可以从前出队，这样队列内仍然保持了是滑动窗口的最大值</p></li></ul><p><strong>关键操作</strong>：</p><p>队列并不是每一个数都会进队的，待进队的元素依次跟队内的其他元素进行比较，如果待进队元素大于队列中某一个元素，则说明该元素不会是滑动窗口的最大值，将该元素从<strong>后侧出队</strong>。直到队列内没有比待进队元素小的元素，或者队列为空了，则将待进队元素的<code>下标</code>从<strong>后侧入队</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">    <span class="keyword">while</span> maxQ <span class="keyword">and</span> nums[i] &gt;= nums[maxQ[<span class="number">-1</span>]]:</span><br><span class="line">        maxQ.pop()</span><br><span class="line">    maxQ.append(i)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><blockquote><p>nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</p><ol><li>i=0，此时maxQ 为空，则将下标0加入队列：  maxQ = [0]</li><li>i=1，由于3&gt;1，则将队列内元素出队： maxQ= []   此时为空  然后再将i=1入队</li><li>i=2，由于-1&lt;3，-1是不可能成为窗口最大值的，但是有可能成为后面窗口的最大值，所以仍然将其从后侧入队</li></ol><p>…基本的处理流程就是上面这样，这样每次滑动一次的时候，队列内的头元素都是上一个窗口的最大值</p><p>而且这样也保证了队列内的元素是基本有序且是降序。</p></blockquote><p>详细介绍看注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        maxQ = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> maxQ <span class="keyword">and</span> nums[i] &gt;= nums[maxQ[<span class="number">-1</span>]]:</span><br><span class="line">                maxQ.pop()</span><br><span class="line">            maxQ.append(i)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 右侧的数依次加入  i的含义是 每次加入的数的下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n):  </span><br><span class="line">            <span class="comment"># 先将上一个窗口最大值放入结果集</span></span><br><span class="line">            res.append(nums[maxQ[<span class="number">0</span>]])</span><br><span class="line">            <span class="comment"># 考虑待入队元素，下标为i的数</span></span><br><span class="line">            <span class="keyword">while</span> maxQ <span class="keyword">and</span> nums[i] &gt;= nums[maxQ[<span class="number">-1</span>]]:</span><br><span class="line">                maxQ.pop()</span><br><span class="line">            <span class="comment"># 当前最大值是否应该出队，如果失效 则应出队</span></span><br><span class="line">            <span class="keyword">if</span> maxQ <span class="keyword">and</span> i-maxQ[<span class="number">0</span>] == k:</span><br><span class="line">                maxQ.pop(<span class="number">0</span>)</span><br><span class="line">            maxQ.append(i)</span><br><span class="line">        <span class="comment"># 别忘了，每次都是添加上一个窗口的最大值，循环退出时，结果集加上一次窗口的最大值</span></span><br><span class="line">        res.append(nums[maxQ[<span class="number">0</span>]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="相似题目-队列的最大值"><a href="#相似题目-队列的最大值" class="headerlink" title="相似题目 队列的最大值"></a>相似题目 队列的最大值</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p>示例 1：</p><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p><p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p><p>限制：</p><p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>关键操作跟上面是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> self.deque <span class="keyword">and</span> self.deque[<span class="number">-1</span>] &lt; value:</span><br><span class="line">    self.deque.pop()</span><br></pre></td></tr></table></figure><p>MaxQueue这个数据结构，主要操作是<code>push_back</code>和<code>pop_front</code></p><ul><li><code>push_back</code>：也就是每次加入一个新的元素时候，需要进行的操作。如果待入队元素比之前队列内任何一个元素都大，那么直接将其他元素从deque中出队即可。只留下  一个最大元素</li><li><code>pop_front</code>：从前面出队的时候，只需要考虑出去的元素跟最大元素是不是相等就好了，如果相等那么最大队列里面的元素也需要进行出队。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.deque = queue.deque()</span><br><span class="line">        self.queue = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.deque[<span class="number">0</span>] <span class="keyword">if</span> self.deque <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.deque <span class="keyword">and</span> self.deque[<span class="number">-1</span>] &lt; value:</span><br><span class="line">            self.deque.pop()</span><br><span class="line">        self.deque.append(value)</span><br><span class="line">        self.queue.put(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.deque:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        ans = self.queue.get()</span><br><span class="line">        <span class="keyword">if</span> ans == self.deque[<span class="number">0</span>]:</span><br><span class="line">            self.deque.popleft()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MaxQueue()</span></span><br><span class="line"><span class="comment"># param_1 = obj.max_value()</span></span><br><span class="line"><span class="comment"># obj.push_back(value)</span></span><br><span class="line"><span class="comment"># param_3 = obj.pop_front()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;滑动窗口的最大值&quot;&gt;&lt;a href=&quot;#滑动窗口的最大值&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口的最大值&quot;&gt;&lt;/a&gt;滑动窗口的最大值&lt;/h2&gt;&lt;p&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-489-扫地机器人</title>
    <link href="http://yoursite.com/2020/03/06/Leetcode/leetcode-489-%E6%89%AB%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>http://yoursite.com/2020/03/06/Leetcode/leetcode-489-%E6%89%AB%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2020-03-05T17:50:47.000Z</published>
    <updated>2020-03-06T15:55:42.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扫地机器人"><a href="#扫地机器人" class="headerlink" title="扫地机器人"></a>扫地机器人</h2><p>房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。</p><p>扫地机器人提供4个API，可以向前进，向左转或者向右转。每次转弯90度。</p><p>当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。</p><p>请利用提供的4个API编写让机器人清理整个房间的算法。</p><blockquote><p>interface Robot {<br>  // 若下一个方格为空，则返回true，并移动至该方格<br>  // 若下一个方格为障碍物，则返回false，并停留在原地<br>  boolean move();</p><p> // 在调用turnLeft/turnRight后机器人会停留在原位置<br>  // 每次转弯90度<br>  void turnLeft();<br>  void turnRight();</p><p> // 清理所在方格<br> void clean();<br>}</p></blockquote><p>示例:</p><p>输入:</p><blockquote><p>room = [<br>  [1,1,1,1,1,0,1,1],<br>  [1,1,1,1,1,0,1,1],<br>  [1,0,1,1,1,1,1,1],<br>  [0,0,0,1,0,0,0,0],<br>  [1,1,1,1,1,1,1,1]<br>],<br>row = 1,<br>col = 3</p></blockquote><p>解析:<br>房间格栅用0或1填充。0表示障碍物，1表示可以通过。<br>机器人从row=1，col=3的初始位置出发。在左上角的一行以下，三列以右。<br>注意:</p><p>输入只用于初始化房间和机器人的位置。你需要“盲解”这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用4个给出的API解决问题。<br>扫地机器人的初始位置一定是空地。<br>扫地机器人的初始方向向上。<br>所有可抵达的格子都是相连的，亦即所有标记为1的格子机器人都可以抵达。<br>可以假定格栅的四周都被墙包围。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/robot-room-cleaner" target="_blank" rel="noopener">https://leetcode-cn.com/problems/robot-room-cleaner</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先都会想到用DFS+回溯，只不过这里额外多了个机器人接口，除了进行搜索操作外，还应该及时操作机器人，对应上搜索操作。</p><p>首先看普通的dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.visited = set()</span><br><span class="line">    <span class="comment"># 上 右 下 左</span></span><br><span class="line">    self.rd = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    self.cd = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,robot,i=<span class="number">0</span>,j=<span class="number">0</span>,d=<span class="number">0</span>)</span>:</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 标记遍历</span></span><br><span class="line">    self.visited.add((i,j))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"> <span class="comment"># 四个方向选一个继续dfs</span></span><br><span class="line">        newr,newc = i + self.rd[k], j+self.cd[k]</span><br><span class="line">        <span class="comment"># 如果没有遍历过就进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (newr,newc) <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</span><br><span class="line">            <span class="comment"># 继续进行dfs</span></span><br><span class="line">            self.dfs(robot,newr,newc)</span><br></pre></td></tr></table></figure><p>对应本题，还需要考虑机器人的情况：</p><ul><li>机器人可以运动的方向有四个（上，下，左，右），不可能上一次考虑完<code>上</code>，下一次就去考虑<code>下</code>，机器人旋转需要按照顺时针（或逆时针方向）。</li><li>如果该遍历的地方已经进行了遍历，需要回退，在图上就简单的坐标操作就完成了回退，这里对于机器人还需要进行额外的回退操作。</li><li>机器人方向的一致性：即从当前点，进入到下一个点的时候，机器人的朝向应该是一致的，而返回时候方向恰好相反</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment"># This is the robot's control interface.</span></span><br><span class="line"><span class="comment"># You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment">#class Robot:</span></span><br><span class="line"><span class="comment">#    def move(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Returns true if the cell in front is open and robot moves into the cell.</span></span><br><span class="line"><span class="comment">#        Returns false if the cell in front is blocked and robot stays in the current cell.</span></span><br><span class="line"><span class="comment">#        :rtype bool</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def turnLeft(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Robot will stay in the same cell after calling turnLeft/turnRight.</span></span><br><span class="line"><span class="comment">#        Each turn will be 90 degrees.</span></span><br><span class="line"><span class="comment">#        :rtype void</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def turnRight(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Robot will stay in the same cell after calling turnLeft/turnRight.</span></span><br><span class="line"><span class="comment">#        Each turn will be 90 degrees.</span></span><br><span class="line"><span class="comment">#        :rtype void</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def clean(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Clean the current cell.</span></span><br><span class="line"><span class="comment">#        :rtype void</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.visited = set()</span><br><span class="line">        <span class="comment"># 上 右 下 左    顺时针方向！！！</span></span><br><span class="line">        self.rd = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">        self.cd = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cleanRoom</span><span class="params">(self, robot)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type robot: Robot</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.dfs(robot)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,robot,i=<span class="number">0</span>,j=<span class="number">0</span>,d=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.visited.add((i,j))</span><br><span class="line">        robot.clean()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            new_d = (d+k) % <span class="number">4</span> <span class="comment"># 机器人方向的一致性</span></span><br><span class="line">            newr,newc = i + self.rd[new_d], j+self.cd[new_d]</span><br><span class="line">            <span class="keyword">if</span> (newr,newc) <span class="keyword">not</span> <span class="keyword">in</span> self.visited <span class="keyword">and</span> robot.move():</span><br><span class="line">                <span class="comment"># 内层 dfs 死掉 需要 回头</span></span><br><span class="line">                self.dfs(robot,newr,newc,new_d)</span><br><span class="line">                <span class="comment"># dfs跳出表示遍历完，机器人需要进行回退操作</span></span><br><span class="line">                self.back(robot)</span><br><span class="line">            robot.turnRight() <span class="comment"># 下一个位置  注意跟 newr,newc对应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 专门的回退操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self,robot)</span>:</span></span><br><span class="line">        <span class="comment"># 掉头</span></span><br><span class="line">        robot.turnRight()</span><br><span class="line">        robot.turnRight()</span><br><span class="line">        <span class="comment"># 回退</span></span><br><span class="line">        robot.move()</span><br><span class="line">        <span class="comment"># 重置方向 跟之前一样</span></span><br><span class="line">        robot.turnRight()</span><br><span class="line">        robot.turnRight()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;扫地机器人&quot;&gt;&lt;a href=&quot;#扫地机器人&quot; class=&quot;headerlink&quot; title=&quot;扫地机器人&quot;&gt;&lt;/a&gt;扫地机器人&lt;/h2&gt;&lt;p&gt;房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。&lt;/p&gt;
&lt;p&gt;扫地机器人提供4个AP
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-1103-分糖果II</title>
    <link href="http://yoursite.com/2020/03/05/Leetcode/leetcode-1103-%E5%88%86%E7%B3%96%E6%9E%9CII/"/>
    <id>http://yoursite.com/2020/03/05/Leetcode/leetcode-1103-%E5%88%86%E7%B3%96%E6%9E%9CII/</id>
    <published>2020-03-04T17:13:13.000Z</published>
    <updated>2020-03-14T16:18:17.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分糖果II"><a href="#分糖果II" class="headerlink" title="分糖果II"></a>分糖果II</h2><p>排排坐，分糖果。</p><p>我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p><p>示例 1：</p><p>输入：candies = 7, num_people = 4<br>输出：[1,2,3,1]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3,0]。<br>第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。<br>示例 2：</p><p>输入：candies = 10, num_people = 3<br>输出：[5,2,3]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3]。<br>第四次，ans[0] += 4，最终数组变为 [5,2,3]。</p><p>提示：</p><p>1 &lt;= candies &lt;= 10^9<br>1 &lt;= num_people &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/distribute-candies-to-people" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distribute-candies-to-people</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先看到10^9限制，可能暴力不可行，但是想了下，由于每次分的糖果都是递增的，所以并不是严格的10^9</p><blockquote><p>$等差数列求和 \frac{n(n+1)}{2}&lt;=candies$，这样解出来的n 应该是$\sqrt{candies}$级别的，同时需要初始化时候$O(N)$</p><p>则最终的时间复杂度为$O(max(\sqrt{G},N))$，其中G为糖果数，N为人数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, num_people: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> num_people &lt;=<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> candies &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]*num_people</span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        res = [<span class="number">0</span>]*num_people</span><br><span class="line">        <span class="keyword">while</span> candies &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num_people):</span><br><span class="line">                <span class="keyword">if</span> candies-num &gt;= <span class="number">0</span>:</span><br><span class="line">                    res[i] += num</span><br><span class="line">                    candies -= num</span><br><span class="line">                    num+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res[i] += candies</span><br><span class="line">                    candies = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>更加简短的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, num_people: int)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">0</span>] * num_people</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 巧妙的利用%  因为是在 num_people中循环</span></span><br><span class="line">        <span class="keyword">while</span> candies != <span class="number">0</span>:</span><br><span class="line">            ans[i % num_people] += min(i + <span class="number">1</span>, candies)</span><br><span class="line">            candies -= min(i + <span class="number">1</span>, candies)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="拓展解法"><a href="#拓展解法" class="headerlink" title="拓展解法"></a>拓展解法</h3><p><strong>该解法来自leetcode讨论区：官方提供的解法</strong></p><p>思路是先给第一个小朋友分配好所有他应得的，然后再给第二个。。。以此类推</p><p>那么怎么计算就是个数学问题了</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcierp42qlj30yy0rejup.jpg" alt="数学推导"></p><p>通过上面的操作可以得到<code>p</code>也就是会分配的次数，最后一次由于达不到p+1个糖果，所以最后一次就会被分配剩下所有的。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcievkri7bj31ai0lwgo7.jpg" alt="以C=29为例"></p><p>接下来就是计算如何分配，</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcif0hztaaj31aa0lugp3.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcj96el9buj311w0nmn07.jpg" alt="具体算法"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, num_people: int)</span> -&gt; List[int]:</span></span><br><span class="line">        n = num_people</span><br><span class="line">        <span class="comment"># how many people received complete gifts</span></span><br><span class="line">        p = int((<span class="number">2</span> * candies + <span class="number">0.25</span>)**<span class="number">0.5</span> - <span class="number">0.5</span>) </span><br><span class="line">        remaining = int(candies - (p + <span class="number">1</span>) * p * <span class="number">0.5</span>)</span><br><span class="line">        rows, cols = p // n, p % n</span><br><span class="line">        </span><br><span class="line">        d = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># complete rows</span></span><br><span class="line">            d[i] = (i + <span class="number">1</span>) * rows + int(rows * (rows - <span class="number">1</span>) * <span class="number">0.5</span>) * n</span><br><span class="line">            <span class="comment"># cols in the last row</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; cols:</span><br><span class="line">                d[i] += i + <span class="number">1</span> + rows * n</span><br><span class="line">        <span class="comment"># remaining candies        </span></span><br><span class="line">        d[cols] += remaining</span><br><span class="line">        <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分糖果II&quot;&gt;&lt;a href=&quot;#分糖果II&quot; class=&quot;headerlink&quot; title=&quot;分糖果II&quot;&gt;&lt;/a&gt;分糖果II&lt;/h2&gt;&lt;p&gt;排排坐，分糖果。&lt;/p&gt;
&lt;p&gt;我们买了一些糖果 candies，打算把它们分给排好队的 n = num_peopl
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-286-墙与门</title>
    <link href="http://yoursite.com/2020/03/04/Leetcode/leetcode-286-%E5%A2%99%E4%B8%8E%E9%97%A8/"/>
    <id>http://yoursite.com/2020/03/04/Leetcode/leetcode-286-%E5%A2%99%E4%B8%8E%E9%97%A8/</id>
    <published>2020-03-03T17:59:24.000Z</published>
    <updated>2020-03-03T18:06:47.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="墙与门"><a href="#墙与门" class="headerlink" title="墙与门"></a>墙与门</h2><p>你被给定一个 m × n 的二维网格，网格中有以下三种可能的初始化值：</p><p>-1 表示墙或是障碍物<br>0 表示一扇门<br>INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。<br>你要给每个空房间位上填上该房间到 最近 门的距离，如果无法到达门，则填 INF 即可。</p><p>示例：</p><p>给定二维网格：</p><p>INF  -1  0  INF<br>INF INF INF  -1<br>INF  -1 INF  -1<br>  0  -1 INF INF<br>运行完你的函数后，该网格应该变成：</p><p>  3  -1   0   1<br>  2   2   1  -1<br>  1  -1   2  -1<br>  0  -1   3   4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/walls-and-gates" target="_blank" rel="noopener">https://leetcode-cn.com/problems/walls-and-gates</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首选是BFS，因为这个跟距离门的远近有关，如果都跟门直接相连，那么距离就是1，所以确定基本思路是BFS</p><p>其次，使用<code>多源BFS</code>，意思也就是几个起点同时开始BFS，其实也不是完全严格意义的BFS，如果把他们看成树的话，他们是在同一层的，然后由这一层同时向下遍历。</p><p>这里有一个隐藏的思考点，在于多源同时BFS，那么距离某一个源最近的点肯定会先被修改值为距离，后面的源再遍历到这里的时候就已经有值了，而且再遍历到这个点时候的距离肯定大于等于该点已有的距离值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rooms:</span><br><span class="line">            <span class="keyword">return</span> rooms</span><br><span class="line">        dr = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        dc = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        m = len(rooms)</span><br><span class="line">        n = len(rooms[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 先把有门的地方都放进来，定义有门的地方path距离是0</span></span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> rooms[i][j] == <span class="number">0</span>:</span><br><span class="line">                    q.append((i,j,<span class="number">0</span>))</span><br><span class="line">        <span class="comment"># 多源同时进行BFS</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r,c,path = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                newr,newc = r+dr[i],c+dc[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=newr&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=newc&lt;n <span class="keyword">and</span> <span class="number">2147483647</span> == rooms[newr][newc]:</span><br><span class="line">                    rooms[newr][newc] = path+<span class="number">1</span></span><br><span class="line">                    q.append((newr,newc,path+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;墙与门&quot;&gt;&lt;a href=&quot;#墙与门&quot; class=&quot;headerlink&quot; title=&quot;墙与门&quot;&gt;&lt;/a&gt;墙与门&lt;/h2&gt;&lt;p&gt;你被给定一个 m × n 的二维网格，网格中有以下三种可能的初始化值：&lt;/p&gt;
&lt;p&gt;-1 表示墙或是障碍物&lt;br&gt;0 表示一扇门&lt;
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-994-腐烂的橘子</title>
    <link href="http://yoursite.com/2020/03/04/Leetcode/leetcode-994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>http://yoursite.com/2020/03/04/Leetcode/leetcode-994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</id>
    <published>2020-03-03T17:22:17.000Z</published>
    <updated>2020-03-14T16:19:26.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>复习要点：</p><p>宽度优先遍历（或 多源BFS）：先将所有符合条件的点加入队列，然后再执行BFS</p></blockquote><h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><p>示例 1：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gch90mxfttj310a07njs9.jpg" alt="img"></p><p>输入：[[2,1,1],[1,1,0],[0,1,1]]<br>输出：4<br>示例 2：</p><p>输入：[[2,1,1],[0,1,1],[1,0,1]]<br>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。<br>示例 3：</p><p>输入：[[0,2]]<br>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p><p>提示：</p><p>1 &lt;= grid.length &lt;= 10<br>1 &lt;= grid[0].length &lt;= 10<br>grid[i][j] 仅为 0、1 或 2</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotting-oranges" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看到提示的数据大小，基本可以判定暴力bfs可以求解的。说下暴力BFS的思路。</p><p>首先为什么要用BFS呢？ 一个烂橘子先感染周边橘子，然后周边橘子再向下感染。这个过程就是BFS的遍历过程呀，而BFS的迭代深度，就是腐烂需要的天数。</p><p>为什么叫暴力呢？因为不可能仅有一个腐烂橘子，可能一开始全局有多个腐烂的橘子，那就需要分别从多个腐烂橘子处进行一次BFS，这时候需要维护一个变量来存储状态<code>stats[i][j],i,j表示第几行第几列，某个数值来表示可能腐烂的天数，初始化为Inf</code>，每从某一个腐烂源进行BFS时候，都更新下stats的状态，让stats记录<code>最小值</code>，最终还需要再遍历一次stats，找到最大的天数，即为最终的腐烂天数。如果最终仍然有橘子的腐烂天数为<code>inf</code></p><h3 id="优秀的解题思路：多源BFS"><a href="#优秀的解题思路：多源BFS" class="headerlink" title="优秀的解题思路：多源BFS"></a>优秀的解题思路：多源BFS</h3><p>为什么叫多源呢？因为前面分析了，开局不可能只有一个烂橘子，所以需要找到最开始的所有烂橘子，然后同时从这些烂橘子开始进行BFS。</p><p>如何保证同时进行BFS呢？其实也不是严格意义的同时，只是这些乱橘子在同一层（同一天），我们把开局的时候算作第0天，那么先将所有烂橘子入队，也就是表示了第0天的烂橘子，当这些烂橘子都出队完成一次更新时候，新进来的烂橘子就都是第1天的。同理….一直到所有橘子都烂掉。</p><p>这里需要维持一个cnt变量，即新鲜橘子有多少个，当cnt为0时候可以跳出，返回结果，如果不为0则返回-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orangesRotting</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 定义4个方向</span></span><br><span class="line">        dr = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        dc = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 先把烂橘子都入队</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 定义一个双端队列</span></span><br><span class="line">        q = deque()</span><br><span class="line">        cnt = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">                    q.append((i,j,<span class="number">0</span>))</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        m_dep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r,c,depth = q.popleft()</span><br><span class="line">            m_dep = max(m_dep,depth)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                newr,newc = r+dr[i],c+dc[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=newr&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=newc&lt;n <span class="keyword">and</span> grid[newr][newc]==<span class="number">1</span>:</span><br><span class="line">                    cnt-=<span class="number">1</span></span><br><span class="line">                    grid[newr][newc] = <span class="number">2</span></span><br><span class="line">                    q.append((newr,newc,depth+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> cnt != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> cnt == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> m_dep</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;复习要点：&lt;/p&gt;
&lt;p&gt;宽度优先遍历（或 多源BFS）：先将所有符合条件的点加入队列，然后再执行BFS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;腐烂的橘子&quot;&gt;&lt;a href=&quot;#腐烂的橘子&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
</feed>
