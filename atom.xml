<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Mereder</title>
  
  <subtitle>珍惜现在，感谢所有，不悔将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-22T11:41:25.710Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meng Di</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-周赛-181场</title>
    <link href="http://yoursite.com/2020/03/22/Leetcode/leetcode%E5%91%A8%E8%B5%9B181%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/22/Leetcode/leetcode%E5%91%A8%E8%B5%9B181%E5%9C%BA/</id>
    <published>2020-03-22T11:41:07.000Z</published>
    <updated>2020-03-22T11:41:25.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛181场"><a href="#周赛181场" class="headerlink" title="周赛181场"></a>周赛181场</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛181场&quot;&gt;&lt;a href=&quot;#周赛181场&quot; class=&quot;headerlink&quot; title=&quot;周赛181场&quot;&gt;&lt;/a&gt;周赛181场&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-双周赛-22场</title>
    <link href="http://yoursite.com/2020/03/22/Leetcode/leetcode%E5%91%A8%E8%B5%9B-%E5%8F%8C22%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/22/Leetcode/leetcode%E5%91%A8%E8%B5%9B-%E5%8F%8C22%E5%9C%BA/</id>
    <published>2020-03-22T01:10:05.000Z</published>
    <updated>2020-03-22T15:17:05.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双周赛22场"><a href="#双周赛22场" class="headerlink" title="双周赛22场"></a>双周赛22场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/find-the-distance-value-between-two-arrays/" target="_blank" rel="noopener">两个数组间的距离值</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/cinema-seat-allocation/" target="_blank" rel="noopener">安排电影院座位</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/sort-integers-by-the-power-value/" target="_blank" rel="noopener">将整数按权重排序</a><br><code>7 分</code> - <a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/" target="_blank" rel="noopener">3n 块披萨</a></p><p>:crossed_fingers:   第一次在规定时间内做出来3个题，纪念下！！！:stuck_out_tongue_winking_eye:</p><h3 id="两个数组间的距离值"><a href="#两个数组间的距离值" class="headerlink" title="两个数组间的距离值"></a>两个数组间的距离值</h3><p>根据题意，双循环实现即可，由于数据范围不是很大，暴力方法。时间复杂度<code>O(N^2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheDistanceValue</span><span class="params">(self, arr1: List[int], arr2: List[int], d: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr1)):</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr2)):</span><br><span class="line">                <span class="keyword">if</span> abs(arr1[i]-arr2[j]) &lt;= d:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="T2-安排电影院座位"><a href="#T2-安排电影院座位" class="headerlink" title="T2:安排电影院座位"></a>T2:安排电影院座位</h3><p>上来就开了一个辅助矩阵帮助判断，但是数据量太大了，内存直接爆掉了。</p><p>根据给的数据提示：</p><blockquote><ul><li><code>1 &lt;= n &lt;= 10^9</code></li><li><code>1 &lt;= reservedSeats.length &lt;= min(10*n, 10^4)</code>  这里！！！ </li><li><code>reservedSeats[i].length == 2</code></li><li><code>1 &lt;= reservedSeats[i][0] &lt;= n</code></li><li><code>1 &lt;= reservedSeats[i][1] &lt;= 10</code></li><li>所有 <code>reservedSeats[i]</code> 都是互不相同的。</li></ul></blockquote><p>预定座位数组内元素的个数最大就是<code>10^4</code>所以从这个数组下手。这个数组给的是预定了座位，整个电影院可以最多坐下的4人家庭数量为<code>n*2,n为行数</code>，去掉被预定出去导致不能4人连坐的位置，剩余的值就是解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfFamilies</span><span class="params">(self, n: int, reservedSeats: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 每行都是只需要判断三个位置即可 2-5   4-7  6-9</span></span><br><span class="line">        seats = sorted(reservedSeats,key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        res = <span class="number">2</span>*n</span><br><span class="line">        one_line = [<span class="number">0</span>]*<span class="number">11</span></span><br><span class="line">        <span class="keyword">for</span> seat <span class="keyword">in</span> seats:</span><br><span class="line">            x,y = seat[<span class="number">0</span>],seat[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> x == row:</span><br><span class="line">                one_line[y] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> row != <span class="number">0</span>:</span><br><span class="line">                    res -= self.cal(one_line)</span><br><span class="line">                one_line = [<span class="number">0</span>]*<span class="number">11</span></span><br><span class="line">                row = x</span><br><span class="line">                one_line[y] = <span class="number">1</span></span><br><span class="line">        res -= self.cal(one_line)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(self,one)</span>:</span></span><br><span class="line">        <span class="comment"># 2,3,.....9 这8个位置 如果都没有被预定 则不用减</span></span><br><span class="line">        <span class="keyword">if</span> sum(one[<span class="number">2</span>:<span class="number">10</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 中间可以坐的位置 有3种方案，其中某一个方案可行，都会导致该行 只能坐一种方案</span></span><br><span class="line">        <span class="keyword">elif</span> sum(one[<span class="number">2</span>:<span class="number">6</span>]) == <span class="number">0</span> <span class="keyword">or</span> sum(one[<span class="number">4</span>:<span class="number">8</span>]) == <span class="number">0</span> <span class="keyword">or</span> sum(one[<span class="number">6</span>:<span class="number">10</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>时间复杂度分析：之前有个排序算法，<code>O(NlogN)</code> 后面有个遍历过程<code>O(N)</code>,总的时间复杂度是<code>O(NlogN)</code></p><p>其实可以优化到<code>O(N)</code>，看其他人的解法里面使用了<code>dict</code> ，先遍历加入<code>dict</code>，确保同行的都在一个key里面， 再遍历dict 进行使用。</p><h3 id="T3-将整数按照权重排序"><a href="#T3-将整数按照权重排序" class="headerlink" title="T3:将整数按照权重排序"></a>T3:将整数按照权重排序</h3><p>求权重的方法就是带备忘录的dfs，不方便直接用dp的原因是不知道这个数组具体有多大，下一个值是否存在。所以用了<code>字典</code>来存储已经计算过的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKth</span><span class="params">(self, lo: int, hi: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        self.mem = &#123;&#125;</span><br><span class="line">        self.mem[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        self.mem[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        self.mem[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        self.mem[<span class="number">3</span>] = <span class="number">7</span></span><br><span class="line">        </span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lo,hi+<span class="number">1</span>):</span><br><span class="line">            steps = self.countSteps(i)</span><br><span class="line">            arr.append([steps,i])</span><br><span class="line">        </span><br><span class="line">        arr = sorted(arr,key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> arr[k<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSteps</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> self.mem:</span><br><span class="line">            <span class="keyword">return</span> self.mem[num]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">                self.mem[num] = self.countSteps(num//<span class="number">2</span>)+<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> self.mem[num]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.mem[num] = self.countSteps(num*<span class="number">3</span>+<span class="number">1</span>)+<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> self.mem[num]</span><br></pre></td></tr></table></figure><h3 id="T4-3n-块披萨"><a href="#T4-3n-块披萨" class="headerlink" title="T4:3n 块披萨"></a>T4:3n 块披萨</h3><p>自己的思路就是暴力dfs，模拟自己选披萨任何一块的可能情况，对应自己选完一次也帮Alice和Bob进行选择，选择好的披萨进行标记已经遍历。<strong>超时</strong>（实际上case 才过了 15/69）  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSizeSlices</span><span class="params">(self, slices: List[int])</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        self.mx = <span class="number">0</span></span><br><span class="line">        mine = []</span><br><span class="line">        visited = [<span class="number">0</span>]*len(slices)</span><br><span class="line">        self.dfs(slices,visited,mine)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.mx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,slices,visited,mine)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sum(visited) == len(slices):</span><br><span class="line">            self.mx = max(self.mx,sum(mine))</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(slices)):</span><br><span class="line">            <span class="keyword">if</span> visited[idx] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 遍历标记</span></span><br><span class="line">                mine.append(slices[idx])</span><br><span class="line">                visited[idx] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 顺时针的下一个</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(idx+<span class="number">1</span>,idx+len(slices)):</span><br><span class="line">                    <span class="keyword">if</span> visited[k%len(slices)] == <span class="number">0</span>:</span><br><span class="line">                        visited[k%len(slices)] = <span class="number">1</span></span><br><span class="line">                        Alice = k%len(slices)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 逆时针</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(idx+len(slices)<span class="number">-1</span>,idx<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> visited[k%len(slices)] == <span class="number">0</span>:</span><br><span class="line">                        visited[k%len(slices)] = <span class="number">1</span></span><br><span class="line">                        Bob = k%len(slices)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                self.dfs(slices,visited,mine)</span><br><span class="line">                <span class="comment"># 回溯</span></span><br><span class="line">                mine.pop()</span><br><span class="line">                visited[idx] = <span class="number">0</span></span><br><span class="line">                visited[Alice] = <span class="number">0</span></span><br><span class="line">                visited[Bob] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>为什么会超时呢？</p><blockquote><p>暴力回溯的情况下，假如共有9块披萨 取 1 3 5 和 5 3 1 是属于同样的选择，原本我们只需要选最有益的，但是暴力回溯会依次遍历这两种情况，产生大量的冗余计算，时间复杂度过高 <code>O(N!)</code></p></blockquote><h4 id="进阶思路"><a href="#进阶思路" class="headerlink" title="进阶思路"></a>进阶思路</h4><p>！！！ <strong>转化为 非连续数列的最值问题  -&gt; 打家劫舍问题！！！</strong></p><p>虽然题目描述披萨是个圈，但是还是数列，只不过需要注意第一个元素和最后一个元素是互斥的就可以了。</p><p>那么问题就变成了：如果在这个数列里面我可以取一定次数的值，但是不可以连续取值，怎么取可以使我的取值最大。</p><ul><li>为什么是一定次数的：因为3n个披萨，你最多只能取 n//3 次</li><li>为什么是不连续的：因为有条件限制，你取了第i个那么i-1和i+1 都会被分掉</li></ul><p>还有一个问题，没有解决首位互斥的问题，这时候想到打家劫舍第三题，就是一个环啊。那我们只需要分两次来进行求值</p><ul><li>当首位置可以选的时候，去掉尾</li><li>当尾部可选的时候，去掉首部</li></ul><p>我们来看下，本题的状态是什么，然后如何转移的：</p><script type="math/tex; mode=display">d[i][j] = max\{d[i-1][0...j-2]\} + slices[j]</script><p>$d[i][j]$其中的i表示拿i次披萨，j表示第j块，即第i次拿起第j块披萨的最大值是多少。转移方程中有一个<code>0...j-2</code>表示取值为：0，1，2，3…j-2 。对于状态转移方程，举个例子来方便理解：</p><blockquote><p> 当i=2,j=5的时候，表示第2次取第5块披萨时，我们需要看一下</p><p>第1次取第0块披萨、第1块披萨、第j-2(5-2=3) 块披萨时候的最大值，在加上本次即将取得第5块披萨</p><p>即 $d[2][5] = max(d[1][0],d[1][1],d[1][2],d[1][3]) + slices[5]$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSizeSlices</span><span class="params">(self, slices: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.row = len(slices)//<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">        self.n  = len(slices) - <span class="number">1</span></span><br><span class="line">        one = self.getMax(slices,<span class="number">0</span>,self.n) <span class="comment"># 只看首部不看尾部</span></span><br><span class="line">        two = self.getMax(slices,<span class="number">1</span>,self.n+<span class="number">1</span>)  <span class="comment"># 只看尾部不看首部</span></span><br><span class="line">        <span class="keyword">return</span> max(one,two)  <span class="comment"># 取二者的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMax</span><span class="params">(self,slices,start,end)</span>:</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*self.n <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.row)]</span><br><span class="line">        tmp = slices[start:end]</span><br><span class="line">        cur_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,self.row):</span><br><span class="line">            pre_max = <span class="number">0</span> <span class="comment"># 上一次拿的时候最大的</span></span><br><span class="line">            <span class="keyword">for</span>  j <span class="keyword">in</span> range(self.n):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= <span class="number">2</span>:</span><br><span class="line">                  <span class="comment"># 这个pre_max相当于PK台,始终保留前面情况的最大值</span></span><br><span class="line">                    pre_max = max(dp[i<span class="number">-1</span>][j<span class="number">-2</span>],pre_max) </span><br><span class="line">                dp[i][j] = pre_max + tmp[j]</span><br><span class="line">                cur_max = max(dp[i][j], cur_max)</span><br><span class="line">        <span class="keyword">return</span> cur_max</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;双周赛22场&quot;&gt;&lt;a href=&quot;#双周赛22场&quot; class=&quot;headerlink&quot; title=&quot;双周赛22场&quot;&gt;&lt;/a&gt;双周赛22场&lt;/h2&gt;&lt;p&gt;&lt;code&gt;3 分&lt;/code&gt; - &lt;a href=&quot;https://leetcode-cn.com/pr
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-328-奇偶链表</title>
    <link href="http://yoursite.com/2020/03/21/Leetcode/leetcode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/03/21/Leetcode/leetcode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-21T11:36:06.000Z</published>
    <updated>2020-03-21T11:40:34.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br>示例 2:</p><p>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL<br>说明:</p><p>应当保持奇数节点和偶数节点的相对顺序。<br>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>真的是，以为很简单，想一遍写对真的太难了…还是自己太弱了</p><p>先说下自己的错误思路以及问题在哪</p><p>分别拿一个<code>dummy node</code>当奇偶链表的头结点，然后再把两个链表一拼接，就ok了</p><p>这样时间复杂度也是<code>o(N)</code>，空间复杂度是<code>o(1)</code>（额外使用了4个指针）</p><p>思路其实是没有问题的，但是进了链表的大坑——同一个链表分开操作。</p><p>直白讲就是，链表直接使用的就是引用，操作了就是操作了，那么后边再操作就不是最初的链表了</p><p>下面的<strong>错误</strong>解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        odd = ListNode(<span class="number">-1</span>)</span><br><span class="line">        even = ListNode(<span class="number">-2</span>)</span><br><span class="line">        odd.next = head</span><br><span class="line">        even.next = head.next</span><br><span class="line"><span class="comment"># 企图构建一个奇数链表</span></span><br><span class="line">        p_odd = odd.next</span><br><span class="line">        <span class="keyword">while</span> p_odd <span class="keyword">and</span> p_odd.next:</span><br><span class="line">            p_odd.next = p_odd.next.next</span><br><span class="line">            p_odd = p_odd.next</span><br><span class="line">        <span class="comment">#######！！！！！！！！！！！！！！#######</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        问题就在这，上边操作后，链表已经不是原来的head了，而我还当</span></span><br><span class="line"><span class="string">        原来的head再进行偶数链表构建。XXX</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"><span class="comment"># 企图构建一个偶数链表</span></span><br><span class="line">        p_even = even.next</span><br><span class="line">        <span class="keyword">while</span> p_even <span class="keyword">and</span> p_even.next:</span><br><span class="line">            p_even.next = p_even.next.next</span><br><span class="line">            p_even = p_even.next</span><br><span class="line"></span><br><span class="line">        p_odd.next = even.next</span><br><span class="line">        <span class="keyword">return</span> odd</span><br></pre></td></tr></table></figure><h3 id="正确且简单解法"><a href="#正确且简单解法" class="headerlink" title="正确且简单解法"></a>正确且简单解法</h3><p>再链表上同时操作奇偶，需要注意的细节问题是：处理肯定先奇数再偶数，<code>p_even</code>指针始终靠后一点，所以循环的判断条件是判定，偶数或者偶数的下一个是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        even = head.next</span><br><span class="line">        p_even = even</span><br><span class="line">        p_odd = head</span><br><span class="line">        <span class="comment"># 一次同时来操作两个节点，最后的判断就是 even 因为even 后操作</span></span><br><span class="line">        <span class="keyword">while</span> p_even <span class="keyword">and</span> p_even.next:</span><br><span class="line">            p_odd.next = p_even.next</span><br><span class="line">            p_odd = p_odd.next</span><br><span class="line">            p_even.next = p_odd.next</span><br><span class="line">            p_even = p_even.next </span><br><span class="line">                    </span><br><span class="line">        p_odd.next = even</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;奇偶链表&quot;&gt;&lt;a href=&quot;#奇偶链表&quot; class=&quot;headerlink&quot; title=&quot;奇偶链表&quot;&gt;&lt;/a&gt;奇偶链表&lt;/h2&gt;&lt;p&gt;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>topK问题</title>
    <link href="http://yoursite.com/2020/03/21/SwordOffer/%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/21/SwordOffer/%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</id>
    <published>2020-03-21T11:07:54.000Z</published>
    <updated>2020-03-21T11:15:46.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li><li><code>0 &lt;= arr[i] &lt;= 10000</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>经典面试题目：主要利用快排的<code>partition</code> 以及 堆排两种方式来完成</p><h4 id="快排方案"><a href="#快排方案" class="headerlink" title="快排方案"></a>快排方案</h4><p>原理： 快排一次可以确定一个数的最终位置，那么根据位置和k进行比较则可以在不完全排序好整个数组的前提下，排好前k个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="keyword">if</span> n == k:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = self.partition(arr,left,right)</span><br><span class="line">            <span class="keyword">if</span> mid == k:</span><br><span class="line">                <span class="keyword">return</span> arr[:k]</span><br><span class="line">            <span class="keyword">elif</span> mid &lt; k :</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr,left,right)</span>:</span></span><br><span class="line">        pivot = arr[left]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right]&gt;= pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            arr[left],arr[right] = arr[right], arr[left]</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt; pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            arr[left],arr[right] = arr[right], arr[left]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>方案分析：每次<code>partition</code>操作都是<code>O(N)</code>的时间复杂度，最优情况就是一次partition恰好找到第k个位置，则前K个就是topk小。最坏的情况就是每一次选出来的位置，不是最大就是最小，界限始终在两侧递减1，这样最终需要遍历完整个数组才能找到K，时间复杂度为<code>O(N^2)</code>,平均的话 说不好，因为不是严格的快排序那种二分去找的。 </p><h3 id="堆排方案"><a href="#堆排方案" class="headerlink" title="堆排方案"></a>堆排方案</h3><p>维护一个大根堆，用来获取最小的前k个值，为什么用大根堆呢？</p><p>大根堆每次调整后，都将堆内最大的元素放到堆顶，如果新进来的元素比堆顶元素小，那么就把堆顶元素换成该元素，同时再进行一次从top到bottom的调整，这样最大的元素又一次被调整到堆顶，继续前面的过程。</p><p>最终堆内留下来的就是最小的K个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k ==<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        topk = [v <span class="keyword">for</span> v <span class="keyword">in</span> arr[:k]]</span><br><span class="line">        <span class="comment"># 使普通的二叉 成为 有序的 大根堆</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k//<span class="number">2</span><span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            self.heapAdjust(topk,i,k<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k,len(arr)):</span><br><span class="line">            <span class="comment"># 每次竞争掉堆顶</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt;= topk[<span class="number">0</span>]:</span><br><span class="line">                topk[<span class="number">0</span>] = arr[i]</span><br><span class="line">                self.heapAdjust(topk,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> topk</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapAdjust</span><span class="params">(self,heap,start,end)</span>:</span></span><br><span class="line">        root = start</span><br><span class="line">        child = root*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> child &lt;= end:</span><br><span class="line">            <span class="keyword">if</span> child+<span class="number">1</span> &lt;= end <span class="keyword">and</span> heap[child+<span class="number">1</span>] &gt; heap[child]:</span><br><span class="line">                child += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> heap[root] &lt; heap[child]:</span><br><span class="line">                heap[root],heap[child] = heap[child],heap[root]</span><br><span class="line">                root = child</span><br><span class="line">                child = root*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>时间复杂度分析：最坏情况就是<code>o(nlogn)</code> 对于数字需要进行完全的遍历<code>o(N)</code>，而每一次遍历都需要进行logN的操作。最优情况就是<code>O(N)</code>，也就是遍历过程不存在堆的调整，其实说白了就是最初加入堆的K个元素就是topK.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最小的K个数&quot;&gt;&lt;a href=&quot;#最小的K个数&quot; class=&quot;headerlink&quot; title=&quot;最小的K个数&quot;&gt;&lt;/a&gt;最小的K个数&lt;/h2&gt;&lt;p&gt;输入整数数组 &lt;code&gt;arr&lt;/code&gt; ，找出其中最小的 &lt;code&gt;k&lt;/code&gt; 个数。例如，
      
    
    </summary>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>顺指针打印矩阵</title>
    <link href="http://yoursite.com/2020/03/21/SwordOffer/%E9%A1%BA%E6%8C%87%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/03/21/SwordOffer/%E9%A1%BA%E6%8C%87%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</id>
    <published>2020-03-21T11:07:19.000Z</published>
    <updated>2020-03-21T11:13:50.778Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 划定边界</span></span><br><span class="line">        left,right,top,bottom = <span class="number">0</span>,len(matrix[<span class="number">0</span>])<span class="number">-1</span>,<span class="number">0</span>,len(matrix)<span class="number">-1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 从左至右遍历到头 (top 收缩)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 从上到下进行遍历 （右侧收缩）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(top,bottom+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 从右向左进行遍历 （bottom 收缩）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(right,left<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> bottom &lt; top: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 从下到上进行遍历 （左侧收缩）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(bottom,top<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right: <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-365-水壶问题</title>
    <link href="http://yoursite.com/2020/03/21/Leetcode/leetcode-365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/21/Leetcode/leetcode-365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-21T03:53:53.000Z</published>
    <updated>2020-03-21T05:13:51.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水壶问题（智力题）"><a href="#水壶问题（智力题）" class="headerlink" title="水壶问题（智力题）"></a>水壶问题（智力题）</h2><p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><p><strong>示例 1:</strong> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg" target="_blank" rel="noopener"><em>“Die Hard”</em> example</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 3, y = 5, z = 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 2, y = 6, z = 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>作为程序员的思路，遍历所有可能的情况，看这些情况是否可能成立</p><p>对于这个题主要是看x桶和y桶这两个桶的状态，以及对应的操作</p><p>对于每次进行操作，我们都有以下几种操作方式</p><ol><li>把 x 桶 装满</li><li>把 y 桶装满</li><li>把 x 桶清空</li><li>把 y 桶清空</li><li>把 x桶的水倒入y桶，<strong>直到x倒空  or y 被倒满</strong></li><li>把 y 桶的水倒入x桶，<strong>直到y倒空 or x 被倒满</strong></li></ol><p>起始状态就是 x=0,y=0。对于每个状态，我们都可以进行如上的6种操作进行状态改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span><span class="params">(self, x: int, y: int, z: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x + y &lt; z:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        seen = set([])</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            r_x,r_y = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> r_x == z <span class="keyword">or</span> r_y ==z <span class="keyword">or</span> r_x+r_y == z:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 如果已经出现过这种组合了，且没有return True 那说明这个状态没用，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (r_x,r_y) <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            seen.add((r_x,r_y))</span><br><span class="line">            <span class="comment"># 1. 把 x 桶倒满</span></span><br><span class="line">            stack.append((x,r_y))</span><br><span class="line">            <span class="comment"># 2. 把 y 桶倒满</span></span><br><span class="line">            stack.append((r_x,y))</span><br><span class="line">            <span class="comment"># 3. 把 x 清空</span></span><br><span class="line">            stack.append((<span class="number">0</span>,r_y))</span><br><span class="line">            <span class="comment"># 4. 把 y 清空</span></span><br><span class="line">            stack.append((r_x,<span class="number">0</span>)) </span><br><span class="line">            <span class="comment"># 5 把 x 倒入 y中 直到 x倒空 或者 y倒满  y-r_y 表示剩余可以倒入的</span></span><br><span class="line">            stack.append((r_x-min(r_x,y-r_y),r_y+min(r_x, y-r_y)))</span><br><span class="line">            <span class="comment"># 6 把 y 倒入 x 中，直到 y 倒空 或者 x 倒满</span></span><br><span class="line">            stack.append((r_x+min(x-r_x,r_y),r_y-min(x-r_x,r_y)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h3><p>而贝祖定理告诉我们，$ax+by=z$  有解当且仅当 <code>z</code> 是 <code>x</code>,<code>y</code> 的最大公约数的倍数。因此我们只需要找到 <code>x</code>,<code>y</code>的最大公约数并判断 <code>z</code> 是否是它的倍数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span><span class="params">(self, x: int, y: int, z: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x + y &lt; z:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> y == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> z == <span class="number">0</span> <span class="keyword">or</span> x + y == z</span><br><span class="line">        <span class="keyword">return</span> z % math.gcd(x, y) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>记下答案吧…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;水壶问题（智力题）&quot;&gt;&lt;a href=&quot;#水壶问题（智力题）&quot; class=&quot;headerlink&quot; title=&quot;水壶问题（智力题）&quot;&gt;&lt;/a&gt;水壶问题（智力题）&lt;/h2&gt;&lt;p&gt;有两个容量分别为 &lt;em&gt;x&lt;/em&gt;升 和 &lt;em&gt;y&lt;/em&gt;升 的水壶以及无限
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-223-矩形面积</title>
    <link href="http://yoursite.com/2020/03/19/Leetcode/leetcode-223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/03/19/Leetcode/leetcode-223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-03-18T16:34:38.000Z</published>
    <updated>2020-03-18T16:47:31.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩形面积"><a href="#矩形面积" class="headerlink" title="矩形面积"></a>矩形面积</h2><p>在<strong>二维</strong>平面上计算出两个<strong>由直线构成的</strong>矩形重叠后形成的总面积。</p><p>每个矩形由其左下顶点和右上顶点坐标表示，如图所示。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcyk5314sij30f208g0sm.jpg" alt="Rectangle Area"></p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -3, 0, 3, 4, 0, -1, 9, 2</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 假设矩形面积不会超出 <strong>int</strong> 的范围。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是计算交集部分的面积，然后让两个矩形面积相加再减去交集面积即可。</p><p>重点是交集部分如何进行计算。</p><p>如果有交集，那么交集矩形的左  边，肯定是两个矩形左  边  最大的那条边，交集矩形的右 边 ，肯定是两个矩形的右 边 最小的那条边。同理可以得到交集矩形的上下  边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">computeArea</span><span class="params">(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int)</span> -&gt; int:</span></span><br><span class="line">        rectangle_a = (C-A)*(D-B)  <span class="comment"># 求 矩形1</span></span><br><span class="line">        rectangle_b = (G-E)*(H-F)  <span class="comment"># 求 矩形2</span></span><br><span class="line">        <span class="comment"># 一定用max(0,xxx) 是因为不想交的话 会出现负值 </span></span><br><span class="line">        width = max(<span class="number">0</span>,min(C,G)-max(A,E))  <span class="comment"># 根据左右边  求 宽度</span></span><br><span class="line">        height = max(<span class="number">0</span>,min(D,H)-max(B,F)) <span class="comment"># 根据上下边  求 高度</span></span><br><span class="line">        <span class="keyword">return</span> rectangle_a+rectangle_b-width*height</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;矩形面积&quot;&gt;&lt;a href=&quot;#矩形面积&quot; class=&quot;headerlink&quot; title=&quot;矩形面积&quot;&gt;&lt;/a&gt;矩形面积&lt;/h2&gt;&lt;p&gt;在&lt;strong&gt;二维&lt;/strong&gt;平面上计算出两个&lt;strong&gt;由直线构成的&lt;/strong&gt;矩形重叠后形成的总面积
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-836-矩形重叠</title>
    <link href="http://yoursite.com/2020/03/18/Leetcode/leetcode-836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
    <id>http://yoursite.com/2020/03/18/Leetcode/leetcode-836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</id>
    <published>2020-03-18T15:26:23.000Z</published>
    <updated>2020-03-18T15:48:20.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a>矩形重叠</h2><p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>两个矩形 <code>rec1</code> 和 <code>rec2</code> 都以含有四个整数的列表的形式给出。</li><li>矩形中的所有坐标都处于 <code>-10^9</code> 和 <code>10^9</code> 之间。</li><li><code>x</code> 轴默认指向右，<code>y</code> 轴默认指向上。</li><li>你可以仅考虑矩形是正放的情况。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单题，在于题目给的条件太多了。矩形正放置，不会出现倾斜的情况。</p><p>只需要考虑四个情况即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                  <span class="comment">###############</span></span><br><span class="line">                  <span class="comment">#     上      #</span></span><br><span class="line">                  <span class="comment">###############</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############    ###############   ###################</span></span><br><span class="line"><span class="comment">#      左    #    #             #   #       右         # </span></span><br><span class="line"><span class="comment">##############    ##############    ###################</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">##############</span></span><br><span class="line">                  <span class="comment">#      下    #</span></span><br><span class="line">                  <span class="comment">##############</span></span><br></pre></td></tr></table></figure><p>根据这四个情况进行四种判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isRectangleOverlap</span><span class="params">(self, rec1: List[int], rec2: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 以2作为中心矩形</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>]         <span class="comment">#  1 在 2 上</span></span><br><span class="line">                    <span class="keyword">or</span> rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>]      <span class="comment">#  1 在 2  右</span></span><br><span class="line">                    <span class="keyword">or</span> rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>]      <span class="comment">#  1 在 2 下</span></span><br><span class="line">                    <span class="keyword">or</span> rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>])     <span class="comment">#  1 在 2 左</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;矩形重叠&quot;&gt;&lt;a href=&quot;#矩形重叠&quot; class=&quot;headerlink&quot; title=&quot;矩形重叠&quot;&gt;&lt;/a&gt;矩形重叠&lt;/h2&gt;&lt;p&gt;矩形以列表 &lt;code&gt;[x1, y1, x2, y2]&lt;/code&gt; 的形式表示，其中 &lt;code&gt;(x1, y1)&lt;/c
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>排序模块的Reranker</title>
    <link href="http://yoursite.com/2020/03/18/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/Rerank/"/>
    <id>http://yoursite.com/2020/03/18/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/Rerank/</id>
    <published>2020-03-18T11:14:43.000Z</published>
    <updated>2020-03-18T16:52:13.924Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="项目经历" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-灯泡开关问题总结</title>
    <link href="http://yoursite.com/2020/03/17/%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/17/%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-17T14:31:49.000Z</published>
    <updated>2020-03-17T14:33:10.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="灯泡开关问题1"><a href="#灯泡开关问题1" class="headerlink" title="灯泡开关问题1"></a>灯泡开关问题1</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;灯泡开关问题1&quot;&gt;&lt;a href=&quot;#灯泡开关问题1&quot; class=&quot;headerlink&quot; title=&quot;灯泡开关问题1&quot;&gt;&lt;/a&gt;灯泡开关问题1&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-周赛-179场</title>
    <link href="http://yoursite.com/2020/03/17/Leetcode/leetcode%E5%91%A8%E8%B5%9B179%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/17/Leetcode/leetcode%E5%91%A8%E8%B5%9B179%E5%9C%BA/</id>
    <published>2020-03-17T14:23:16.000Z</published>
    <updated>2020-03-21T11:21:23.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛179场"><a href="#周赛179场" class="headerlink" title="周赛179场"></a>周赛179场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener">生成每种字符都是奇数个的字符串</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/bulb-switcher-iii/" target="_blank" rel="noopener">灯泡开关 III</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/" target="_blank" rel="noopener">通知所有员工所需的时间</a><br><code>6 分</code> - <a href="https://leetcode-cn.com/problems/frog-position-after-t-seconds/" target="_blank" rel="noopener">T 秒后青蛙的位置</a></p><h3 id="T1：-生成每种字符都是奇数个的字符串"><a href="#T1：-生成每种字符都是奇数个的字符串" class="headerlink" title="T1： 生成每种字符都是奇数个的字符串"></a>T1： 生成每种字符都是奇数个的字符串</h3><p>思路就是：奇数的话返回 奇数个’a’，偶数的话返回n-1个’b’，加一个’a‘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTheString</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'a'</span>*(n<span class="number">-1</span>)+<span class="string">'b'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'a'</span>*n</span><br></pre></td></tr></table></figure><h3 id="T2-灯泡开关"><a href="#T2-灯泡开关" class="headerlink" title="T2:灯泡开关"></a>T2:灯泡开关</h3><p>灯泡开关系列问题 :<a href="">灯泡开关</a></p><h3 id="T3：-通知所有员工的时间"><a href="#T3：-通知所有员工的时间" class="headerlink" title="T3：  通知所有员工的时间"></a>T3：  通知所有员工的时间</h3><p>上来就想dfs的，写完之后超时了。发现问题在于，每次我的dfs搜索空间都是所有员工，其实只需要搜索自己的下属就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfMinutes</span><span class="params">(self, n: int, headID: int, manager: List[int], informTime: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.nxt = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># 需要先将每个人的下属放进来</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> manager[i] == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            self.nxt[manager[i]].append(i)</span><br><span class="line">        res = self.helper(headID,manager,informTime)+informTime[headID]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,headID,manager,informTime)</span>:</span></span><br><span class="line">        cur_time = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每次搜索自己的下属就可以了</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> self.nxt[headID]:</span><br><span class="line">            t = self.helper(child,manager,informTime)+informTime[child]</span><br><span class="line">            cur_time = max(cur_time,t)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur_time</span><br></pre></td></tr></table></figure><p>BFS思路差不多，主要也是每次入队的时候，</p><p>还有就是从下向上进行的操作，只需要找到最底层的员工，从他们开始一直追溯到boss，所需的时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) &#123;</span><br><span class="line">        //最终结果</span><br><span class="line">        int res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i =<span class="number">0</span>;i&lt;manager.length;i++)&#123;</span><br><span class="line">            //判断是否为结束点，剪枝</span><br><span class="line">            <span class="keyword">if</span>(informTime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                //临时值</span><br><span class="line">                int temp = <span class="number">0</span>;</span><br><span class="line">                int index=i;</span><br><span class="line">                //向上遍历</span><br><span class="line">                <span class="keyword">while</span>(index!=<span class="number">-1</span>)&#123;</span><br><span class="line">                    temp+=informTime[index];</span><br><span class="line">                    index=manager[index];</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛179场&quot;&gt;&lt;a href=&quot;#周赛179场&quot; class=&quot;headerlink&quot; title=&quot;周赛179场&quot;&gt;&lt;/a&gt;周赛179场&lt;/h2&gt;&lt;p&gt;&lt;code&gt;3 分&lt;/code&gt; - &lt;a href=&quot;https://leetcode-cn.com/pr
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>字符串的排列</title>
    <link href="http://yoursite.com/2020/03/15/SwordOffer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/03/15/SwordOffer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2020-03-15T15:00:55.000Z</published>
    <updated>2020-03-15T15:03:33.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。 </p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>限制：</p><p>1 &lt;= s 的长度 &lt;= 8</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯算法的基本case例题</p><p>注意细节问题：如果存在重复元素，那么就会存在重复的排列情况，这里比较简单的使用<code>set</code>进行了去重，如果不使用<code>set</code>的话，需要对字符串排序，然后再在遍历过程中进行控制，如果相同则跳过的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res = set([])</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="comment"># s = sorted(s)</span></span><br><span class="line">        visited = [<span class="literal">False</span>]*len(s)</span><br><span class="line">        self.dfs(res,stack,visited,s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,res,stack,visited,s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(stack) == len(s):</span><br><span class="line">            res.add(<span class="string">''</span>.join(stack))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="comment"># if i &gt;0 and s[i] == s[i-1] and not visited[i]:</span></span><br><span class="line">            <span class="comment">#     continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">                stack.append(s[i])</span><br><span class="line"></span><br><span class="line">                self.dfs(res,stack,visited,s)</span><br><span class="line"></span><br><span class="line">                visited[i] = <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串的排列&quot;&gt;&lt;a href=&quot;#字符串的排列&quot; class=&quot;headerlink&quot; title=&quot;字符串的排列&quot;&gt;&lt;/a&gt;字符串的排列&lt;/h2&gt;&lt;p&gt;输入一个字符串，打印出该字符串中字符的所有排列。 &lt;/p&gt;
&lt;p&gt;你可以以任意顺序返回这个字符串数组，但里面
      
    
    </summary>
    
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>数组中的逆序对数</title>
    <link href="http://yoursite.com/2020/03/15/SwordOffer/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/15/SwordOffer/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/</id>
    <published>2020-03-15T13:11:43.000Z</published>
    <updated>2020-03-15T14:01:56.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组中的逆序对数"><a href="#数组中的逆序对数" class="headerlink" title="数组中的逆序对数"></a>数组中的逆序对数</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p> 示例 1:</p><p>输入: [7,5,6,4]<br>输出: 5</p><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 50000</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较经典的题目，之前一直记得总体解决方案是通过 归并排序来实现的。</p><p>但是自己python 盲写了一遍并没有成功AC…</p><p>还是细节地方没有考虑好：</p><ul><li>遍历顺序：<code>从大到小进行遍历比较</code></li><li>cnt 计数 每次加上的值是<code>right-mid</code>的个数</li><li>！！！ 每次merger 操作之后记得将  新数组的值赋给原来的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        arr = nums.copy()</span><br><span class="line">        res = self.split(nums,arr,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(self,nums,arr,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            arr[left] = nums[left]</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        left_res = self.split(nums,arr,left,mid)</span><br><span class="line">        right_res = self.split(nums,arr,mid+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历顺序： 都是从 左侧  和 右侧 的 尾部开始</span></span><br><span class="line">        l = mid</span><br><span class="line">        r = right</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        j = right</span><br><span class="line">        <span class="keyword">while</span> l &gt;= left <span class="keyword">and</span> r &gt;= mid+<span class="number">1</span>:  <span class="comment">## 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] &gt; nums[r]:</span><br><span class="line">                arr[j] = nums[l]</span><br><span class="line">                cnt += r-mid  <span class="comment">#### 加上的个数</span></span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr[j] = nums[r]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= left:</span><br><span class="line">            arr[j] = nums[l]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &gt;= mid+<span class="number">1</span>:</span><br><span class="line">            arr[j] = nums[r]</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="comment">####  重置数组啊！！！</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">            nums[k] = arr[k]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left_res+right_res+cnt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组中的逆序对数&quot;&gt;&lt;a href=&quot;#数组中的逆序对数&quot; class=&quot;headerlink&quot; title=&quot;数组中的逆序对数&quot;&gt;&lt;/a&gt;数组中的逆序对数&lt;/h2&gt;&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组
      
    
    </summary>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-695-岛屿的最大面积</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode/leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode/leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-03-15T09:22:50.000Z</published>
    <updated>2020-03-18T16:52:29.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p><p>示例 1:</p><p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p><p>示例 2:</p><p>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没啥好说的，直接dfs 遍历有<code>1</code>相连接的区域，优化的点在于，统计过的岛屿可以直接置为<code>0</code> 避免重复统计同一片岛屿</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    tmp = self.dfs(grid,i,j,m,n)</span><br><span class="line">                    mx = max(tmp,mx)    </span><br><span class="line">        <span class="keyword">return</span> mx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">dfs</span><span class="params">(self,grid,i,j,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> j &lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;= m <span class="keyword">or</span> j &gt;=n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        cnt += self.dfs(grid,i<span class="number">-1</span>,j,m,n)</span><br><span class="line">        cnt += self.dfs(grid,i+<span class="number">1</span>,j,m,n)</span><br><span class="line">        cnt += self.dfs(grid,i,j<span class="number">-1</span>,m,n)</span><br><span class="line">        cnt += self.dfs(grid,i,j+<span class="number">1</span>,m,n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p>时间复杂度是 $O(M*N)$，其中的M表示网格图的行数，N表示网格图的列数。 实际表示的含义就是每个点都遍历了一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;岛屿的最大面积&quot;&gt;&lt;a href=&quot;#岛屿的最大面积&quot; class=&quot;headerlink&quot; title=&quot;岛屿的最大面积&quot;&gt;&lt;/a&gt;岛屿的最大面积&lt;/h2&gt;&lt;p&gt;给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直)
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-周赛-180场</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode/leetcode%E5%91%A8%E8%B5%9B180%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode/leetcode%E5%91%A8%E8%B5%9B180%E5%9C%BA/</id>
    <published>2020-03-15T09:18:12.000Z</published>
    <updated>2020-03-15T14:29:42.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛"><a href="#周赛" class="headerlink" title="周赛"></a>周赛</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/" target="_blank" rel="noopener">矩阵中的幸运数</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener">设计一个支持增量操作的栈</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" target="_blank" rel="noopener">将二叉搜索树变平衡</a><br><code>6 分</code> - <a href="https://leetcode-cn.com/problems/maximum-performance-of-a-team/" target="_blank" rel="noopener">最大的团队表现值</a></p><h3 id="矩阵中的幸运数"><a href="#矩阵中的幸运数" class="headerlink" title="矩阵中的幸运数"></a>矩阵中的幸运数</h3><p>暴力破解，给的条件限制不大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">luckyNumbers</span> <span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                val = matrix[i][j]</span><br><span class="line">                <span class="keyword">if</span> self.isLucky(val,i,j,m,n,matrix):</span><br><span class="line">                    res.append(val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLucky</span><span class="params">(self,val,i,j,m,n,matrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val == min(matrix[i]): <span class="comment"># 一行的最小值</span></span><br><span class="line">            mx = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> range(m):</span><br><span class="line">                mx = max(matrix[row][j],mx)</span><br><span class="line">            <span class="keyword">if</span> mx == val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>时间复杂度….严格来讲这个有<code>O(N^3)</code>之多…</p><h3 id="设计一个支持增量操作的栈"><a href="#设计一个支持增量操作的栈" class="headerlink" title="设计一个支持增量操作的栈"></a>设计一个支持增量操作的栈</h3><p>模拟题， 注意下实现细节就好啦</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxSize: int)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        self.capacity = maxSize</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.cnt &lt; self.capacity:</span><br><span class="line">            self.stack.append(x)</span><br><span class="line">            self.cnt+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.cnt &lt;= <span class="number">0</span>:</span><br><span class="line">            rt =  <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rt = self.stack.pop()</span><br><span class="line">            self.cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rt</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, k: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt;= self.cnt:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                self.stack[i] += val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.cnt):</span><br><span class="line">                self.stack[i] += val</span><br><span class="line"><span class="comment"># Your CustomStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CustomStack(maxSize)</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># obj.increment(k,val)</span></span><br></pre></td></tr></table></figure><p>分析下时间复杂度：</p><p><code>pop</code>：时间复杂度为<code>o(1)</code></p><p><code>push</code>：时间复杂度<code>o(1)</code></p><h3 id="将二叉树变平衡"><a href="#将二叉树变平衡" class="headerlink" title="将二叉树变平衡"></a>将二叉树变平衡</h3><p>想到了当时平衡二叉搜索树的调整过程，但是印象中那个操作太难了。。。</p><p>本题：二叉树搜索树的中序遍历就是有序数组，根据有序数组构建平衡搜索二叉树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balanceBST</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 中序遍历的结果是 有序的</span></span><br><span class="line">        <span class="comment"># 平衡建树 就是让左右两部分尽量个数均匀</span></span><br><span class="line">        self.nums = []</span><br><span class="line">        self.visitBST(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(self.nums)<span class="number">-1</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(self.nums[mid])</span><br><span class="line">        root.left = self.buildBST(root,left,mid<span class="number">-1</span>)</span><br><span class="line">        root.right = self.buildBST(root,mid+<span class="number">1</span>,right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildBST</span><span class="params">(self,root,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        node = TreeNode(self.nums[mid])</span><br><span class="line">        node.left = self.buildBST(node,left,mid<span class="number">-1</span>)</span><br><span class="line">        node.right = self.buildBST(node,mid+<span class="number">1</span>,right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visitBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        self.visitBST(root.left)</span><br><span class="line">        self.nums.append(root.val)</span><br><span class="line">        self.visitBST(root.right)</span><br></pre></td></tr></table></figure><h3 id="最大的团队表现值"><a href="#最大的团队表现值" class="headerlink" title="最大的团队表现值"></a>最大的团队表现值</h3><p>先将efficiency按照降序排列，然后从前向后遍历，每次都计算并更新res的值</p><p>使用<code>优先队列</code>可以再遍历过程中，如果speed小于队首，则跳过，否则将speed 最小的先出队，再加入一个新的speed。</p><p>（主要的思想是贪心，但是为啥这样是有效的需要证明….）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPerformance</span><span class="params">(self, n: int, speed: List[int], efficiency: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        cls = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            cls.append((efficiency[i],speed[i]))</span><br><span class="line">        </span><br><span class="line">        cls = sorted(cls,key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        q = []</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &lt; k:</span><br><span class="line">                heapq.heappush(q,cls[i][<span class="number">1</span>])</span><br><span class="line">                s += cls[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q[<span class="number">0</span>] &lt; cls[i][<span class="number">1</span>]:</span><br><span class="line">                    s -= heapq.heappop(q)</span><br><span class="line">                    s += cls[i][<span class="number">1</span>]</span><br><span class="line">                    heapq.heappush(q,cls[i][<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># heapq.heappush(q,cls[i][1])</span></span><br><span class="line">            <span class="comment"># s += cls[i][1]</span></span><br><span class="line">            <span class="comment"># if len(q) &gt; k:</span></span><br><span class="line">            <span class="comment">#     s -= heapq.heappop(q)</span></span><br><span class="line">            res = max(res, s*cls[i][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛&quot;&gt;&lt;a href=&quot;#周赛&quot; class=&quot;headerlink&quot; title=&quot;周赛&quot;&gt;&lt;/a&gt;周赛&lt;/h2&gt;&lt;p&gt;&lt;code&gt;3 分&lt;/code&gt; - &lt;a href=&quot;https://leetcode-cn.com/problems/lucky-num
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-333-最大BST树</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode/leetcode-333-%E6%9C%80%E5%A4%A7BST%E6%A0%91/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode/leetcode-333-%E6%9C%80%E5%A4%A7BST%E6%A0%91/</id>
    <published>2020-03-15T02:16:57.000Z</published>
    <updated>2020-03-21T11:35:42.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最大BST树"><a href="#最大BST树" class="headerlink" title="最大BST树"></a>最大BST树</h2><p>给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，其中最大指的是子树节点数最多的。</p><p>注意:<br>子树必须包含其所有后代。</p><p>示例:</p><p>输入: [10,5,15,1,8,null,7]</p><p>   10<br>   / \<br>  5  15<br> / \   \<br>1   8   7</p><p>输出: 3<br>解释: 高亮部分为最大的 BST 子树。<br>     返回值 3 在这个样例中为子树大小。<br>进阶:<br>你能想出用 O(n) 的时间复杂度解决这个问题吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/largest-bst-subtree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-bst-subtree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>见到这个题的时候，瞬间想到了之前做过的一次双周赛的题目：<a href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/" target="_blank" rel="noopener">1373. 二叉搜索子树的最大键值和</a></p><p>本质思想都是 树节点的回溯以及判断 是否是BST的过程。</p><p>以往判断一棵树是不是BST返回的信息只需要是True or False</p><p>这里每次返回的信息只告诉你（info，left_boundary，right_boundary），如果满足BST会对 <code>info</code>字段进行更新，如果不满足则会返回 <strong>(info,  minInt,  maxInt)</strong> 来表示只要包含此节点的树都不可能成为BST。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestBSTSubtree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        final = self.isBST(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBST</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        return (info, left_boundary, right_boundary)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="comment"># 对于空节点，是可以任意节点的子节点的  所以 让左边最大，右边界最小</span></span><br><span class="line">            <span class="comment"># 可以 满足 下面 对BST的判断</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>))</span><br><span class="line">        </span><br><span class="line">        left_res = self.isBST(root.left)</span><br><span class="line">        right_res = self.isBST(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断左子树的最大值 小于 根； 右子树的最小值  大于 根  则为BST</span></span><br><span class="line">        <span class="keyword">if</span> left_res[<span class="number">2</span>] &lt; root.val  <span class="keyword">and</span>  root.val &lt; right_res[<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 本题 info: 最大个数，当然这里可以换成 最大和  最大值 最小值 等 其他信息</span></span><br><span class="line">            s = <span class="number">1</span> + left_res[<span class="number">0</span>] + right_res[<span class="number">0</span>]</span><br><span class="line">            self.res = max(self.res,s)</span><br><span class="line">            <span class="keyword">return</span> (s,min(left_res[<span class="number">1</span>],root.val), max(right_res[<span class="number">2</span>],root.val))</span><br><span class="line"><span class="comment">#  跟空节点截然相反，如果一个根不可以是BST，那么返回这个根 左边是最小， 右边 最大 </span></span><br><span class="line">        <span class="comment">#  这样  回溯都上面任何一个包含此节点 根 都不可能为 BST</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, float(<span class="string">'-inf'</span>),float(<span class="string">'inf'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最大BST树&quot;&gt;&lt;a href=&quot;#最大BST树&quot; class=&quot;headerlink&quot; title=&quot;最大BST树&quot;&gt;&lt;/a&gt;最大BST树&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，其中最大指的是子树节点数最多的。&lt;/p&gt;
&lt;p&gt;注意
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-300-最长上升子序列</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode/leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode/leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-14T16:05:04.000Z</published>
    <updated>2020-03-14T16:17:06.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>复习要点：</p><p>dp 理解dp所表示的含义：以当前作为结尾的最长上升子序列的长度</p></blockquote><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h4><p>建立一个dp数组，来保存最长上升子序列的长度。<code>dp[i]</code> 表示的就是<code>第i个</code>数作为最长上升子序列的结尾时，对应的长度。那么dp[i]的更新依赖于前面所有<code>nums[j]&lt;nums[i]</code>的值更新 $dp[i] = max\{dp[0],dp[1]…dp[i-1]\} + 1$</p><p>实际含义就是，前面所有比nums[i]小的数，都是以nums[i]为结尾的最长上升子序列的一部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>]* len(nums)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt; len(nums):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; cur:</span><br><span class="line">                <span class="keyword">if</span> nums[cur] &gt; nums[j]:</span><br><span class="line">                    dp[cur] = max(dp[cur],dp[j]+<span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            res = max(res,dp[cur])</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>相当于两次遍历，时间复杂度为$o(n^2)$， 空间复杂度为 <code>o(n)</code></p><h3 id="进阶思路"><a href="#进阶思路" class="headerlink" title="进阶思路"></a>进阶思路</h3><h4 id="dp-二分查找"><a href="#dp-二分查找" class="headerlink" title="dp+二分查找"></a>dp+二分查找</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;复习要点：&lt;/p&gt;
&lt;p&gt;dp 理解dp所表示的含义：以当前作为结尾的最长上升子序列的长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最长上升子序列&quot;&gt;&lt;a href=&quot;#最长上升子序列&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1073-字符串的最大公因子</title>
    <link href="http://yoursite.com/2020/03/12/Leetcode/leetcode-1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/"/>
    <id>http://yoursite.com/2020/03/12/Leetcode/leetcode-1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</id>
    <published>2020-03-12T13:13:00.000Z</published>
    <updated>2020-03-12T13:55:28.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串的最大公因子"><a href="#字符串的最大公因子" class="headerlink" title="字符串的最大公因子"></a>字符串的最大公因子</h2><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p>示例 1：</p><p>输入：str1 = “ABCABC”, str2 = “ABC”<br>输出：”ABC”<br>示例 2：</p><p>输入：str1 = “ABABAB”, str2 = “ABAB”<br>输出：”AB”<br>示例 3：</p><p>输入：str1 = “LEET”, str2 = “CODE”<br>输出：””</p><p>提示：</p><p>1 &lt;= str1.length &lt;= 1000<br>1 &lt;= str2.length &lt;= 1000<br>str1[i] 和 str2[i] 为大写英文字母</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-common-divisor-of-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>自己的思路就是暴力穷举，如果存在这样字符串X，那一定是众多可行的解中最长的。所以考虑从后向前遍历，如果有满足的直接返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        n = min(len(str1),len(str2))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> (len(str1)%i)==<span class="number">0</span> <span class="keyword">and</span> (len(str2)%i)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> str1[:i]*(len(str1)//i) == str1 <span class="keyword">and</span> str1[:i]*(len(str2)//i) == str2:</span><br><span class="line">                    <span class="keyword">return</span> str1[:i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><h3 id="更好的思路"><a href="#更好的思路" class="headerlink" title="更好的思路"></a>更好的思路</h3><p>对于上面的暴力方法，我们可以发现<code>len(str1)%i==0 and len(str2)%i==0</code>实际上就是在找最大公约数的过程，那我们可以直接求出来一个最大公约数，然后直接check 能不能成立。 这里面存在着该问题正确性的证明。<br>详细证明可以参考 <a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/zi-fu-chuan-de-zui-da-gong-yin-zi-by-leetcode-solu/" target="_blank" rel="noopener"> 官方题解</a></p><p>证明的大概思路就是子问题套娃，如果存在一个x前缀串成立，那么就必然存在x’ 是最大公约数使问题成立。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        candidate_len = math.gcd(len(str1), len(str2))</span><br><span class="line">        candidate = str1[: candidate_len]</span><br><span class="line">        <span class="keyword">if</span> candidate * (len(str1) // candidate_len) == str1 <span class="keyword">and</span> candidate * (len(str2) // candidate_len) == str2:</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><h3 id="最优思路"><a href="#最优思路" class="headerlink" title="最优思路"></a>最优思路</h3><p>既然存在一个字符串x能同时呗str1 和str2进行整除，那str1和str2肯定有且仅包含字符串x。那么<code>str1+str2</code>的字符串和肯定也是只有x的。<code>str1+str2 == str2+str1</code>不管前后顺序，他们都是只有字符串x的。所以如果这个条件成立，那么肯定存在这样的解，如果不成立，那肯定不存在，直接返回空。</p><p>成立的话，根据前面解法的分析，直接返回最大公因数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        candidate_len = math.gcd(len(str1), len(str2))</span><br><span class="line">        candidate = str1[: candidate_len]</span><br><span class="line">        <span class="keyword">if</span> str1 + str2 == str2 + str1:</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串的最大公因子&quot;&gt;&lt;a href=&quot;#字符串的最大公因子&quot; class=&quot;headerlink&quot; title=&quot;字符串的最大公因子&quot;&gt;&lt;/a&gt;字符串的最大公因子&lt;/h2&gt;&lt;p&gt;对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-1013-将数组分成和相等的三个部分</title>
    <link href="http://yoursite.com/2020/03/11/Leetcode/leetcode-1013-%E5%88%86%E6%88%903%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E9%83%A8%E5%88%86/"/>
    <id>http://yoursite.com/2020/03/11/Leetcode/leetcode-1013-%E5%88%86%E6%88%903%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E9%83%A8%E5%88%86/</id>
    <published>2020-03-11T01:21:53.000Z</published>
    <updated>2020-03-18T16:52:40.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将数组分成和相等的三个部分"><a href="#将数组分成和相等的三个部分" class="headerlink" title="将数组分成和相等的三个部分"></a>将数组分成和相等的三个部分</h2><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p><p>形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。</p><p>示例 1：</p><p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]<br>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1<br>示例 2：</p><p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]<br>输出：false<br>示例 3：</p><p>输入：[3,3,6,5,-2,2,5,1,-9,4]<br>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p><p>提示：</p><p>3 &lt;= A.length &lt;= 50000<br>-10^4 &lt;= A[i] &lt;= 10^4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;将数组分成和相等的三个部分&quot;&gt;&lt;a href=&quot;#将数组分成和相等的三个部分&quot; class=&quot;headerlink&quot; title=&quot;将数组分成和相等的三个部分&quot;&gt;&lt;/a&gt;将数组分成和相等的三个部分&lt;/h2&gt;&lt;p&gt;给你一个整数数组 A，只有可以将其划分为三个和相等的
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 装饰器</title>
    <link href="http://yoursite.com/2020/03/09/python/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2020/03/09/python/%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2020-03-09T14:43:04.925Z</published>
    <updated>2020-03-09T15:32:09.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>这个东西看起来高大上，实际上就是函数套娃。:weary:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am doing some boring work before executing a_func()"</span>)</span><br><span class="line"> </span><br><span class="line">        a_func()</span><br><span class="line"> </span><br><span class="line">        print(<span class="string">"I am doing some boring work after executing a_func()"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to remove my foul smell"</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: "I am the function which needs some decoration to remove my foul smell"</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure><p>上面的例子虽然简单(两层套娃)，但是基本就是<strong>装饰器</strong>的使用流程。那么我们将其改变成装饰器来看下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Hey you! Decorate me!"""</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to "</span></span><br><span class="line">          <span class="string">"remove my foul smell"</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#the @a_new_decorator is just a short way of saying:</span></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br></pre></td></tr></table></figure><p>这里面还是有几个需要注意的点：</p><ul><li>装饰器函数里面还有一个wrapTheFunction()，这个内置函数的存在是方便在真正调用被装饰函数之前和之后也可以进行一些操作，同时让装饰器函数能够返回一个\<function\></li><li>分清楚返回的是函数<code>f</code>还是函数结果<code>f()</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h2&gt;&lt;p&gt;这个东西看起来高大上，实际上就是函数套娃。:weary:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
