<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Mereder</title>
  
  <subtitle>珍惜现在，感谢所有，不悔将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-08T15:39:58.069Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meng Di</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-322-零钱兑换</title>
    <link href="http://yoursite.com/2020/03/08/leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/03/08/leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2020-03-08T15:39:23.000Z</published>
    <updated>2020-03-08T15:39:58.069Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-239-滑动窗口的最大值</title>
    <link href="http://yoursite.com/2020/03/07/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2020/03/07/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2020-03-07T13:29:49.000Z</published>
    <updated>2020-03-08T14:03:04.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>示例:</p><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p><p>  滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p><p>提示：</p><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>暴力方法</strong>：</p><p>每次移动到一个新的窗口都计算一次本窗口内的最大值，如果窗口大小是K，一共N个数，时间复杂度为<code>o(kn)</code></p><p><strong>管理下标+双端队列</strong></p><ul><li><p>管理下标</p><p>因为该方法(窗口里面)处理的并不是实际的值，而是值所在的下标，这样的好处在于可以判断出当某个值已经出了窗口的时候，可以及时对窗口内的最大值进行更新</p></li><li><p>双端队列（可以看做滑动窗口）</p><p>使用的是双端队列，好处在于新的值可以从后侧入队，已经失效的最大值，则可以从前出队，这样队列内仍然保持了是滑动窗口的最大值</p></li></ul><p><strong>关键操作</strong>：</p><p>队列并不是每一个数都会进队的，待进队的元素依次跟队内的其他元素进行比较，如果待进队元素大于队列中某一个元素，则说明该元素不会是滑动窗口的最大值，将该元素从<strong>后侧出队</strong>。直到队列内没有比待进队元素小的元素，或者队列为空了，则将待进队元素的<code>下标</code>从<strong>后侧入队</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">    <span class="keyword">while</span> maxQ <span class="keyword">and</span> nums[i] &gt;= nums[maxQ[<span class="number">-1</span>]]:</span><br><span class="line">        maxQ.pop()</span><br><span class="line">    maxQ.append(i)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><blockquote><p>nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</p><ol><li>i=0，此时maxQ 为空，则将下标0加入队列：  maxQ = [0]</li><li>i=1，由于3&gt;1，则将队列内元素出队： maxQ= []   此时为空  然后再将i=1入队</li><li>i=2，由于-1&lt;3，-1是不可能成为窗口最大值的，但是有可能成为后面窗口的最大值，所以仍然将其从后侧入队</li></ol><p>…基本的处理流程就是上面这样，这样每次滑动一次的时候，队列内的头元素都是上一个窗口的最大值</p><p>而且这样也保证了队列内的元素是基本有序且是降序。</p></blockquote><p>详细介绍看注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        maxQ = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> maxQ <span class="keyword">and</span> nums[i] &gt;= nums[maxQ[<span class="number">-1</span>]]:</span><br><span class="line">                maxQ.pop()</span><br><span class="line">            maxQ.append(i)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 右侧的数依次加入  i的含义是 每次加入的数的下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n):  </span><br><span class="line">            <span class="comment"># 先将上一个窗口最大值放入结果集</span></span><br><span class="line">            res.append(nums[maxQ[<span class="number">0</span>]])</span><br><span class="line">            <span class="comment"># 考虑待入队元素，下标为i的数</span></span><br><span class="line">            <span class="keyword">while</span> maxQ <span class="keyword">and</span> nums[i] &gt;= nums[maxQ[<span class="number">-1</span>]]:</span><br><span class="line">                maxQ.pop()</span><br><span class="line">            <span class="comment"># 当前最大值是否应该出队，如果失效 则应出队</span></span><br><span class="line">            <span class="keyword">if</span> maxQ <span class="keyword">and</span> i-maxQ[<span class="number">0</span>] == k:</span><br><span class="line">                maxQ.pop(<span class="number">0</span>)</span><br><span class="line">            maxQ.append(i)</span><br><span class="line">        <span class="comment"># 别忘了，每次都是添加上一个窗口的最大值，循环退出时，结果集加上一次窗口的最大值</span></span><br><span class="line">        res.append(nums[maxQ[<span class="number">0</span>]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p>示例 1：</p><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p><p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p><p>限制：</p><p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>关键操作跟上面是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> self.deque <span class="keyword">and</span> self.deque[<span class="number">-1</span>] &lt; value:</span><br><span class="line">    self.deque.pop()</span><br></pre></td></tr></table></figure><p>MaxQueue这个数据结构，主要操作是<code>push_back</code>和<code>pop_front</code></p><ul><li><code>push_back</code>：也就是每次加入一个新的元素时候，需要进行的操作。如果待入队元素比之前队列内任何一个元素都大，那么直接将其他元素从deque中出队即可。只留下  一个最大元素</li><li><code>pop_front</code>：从前面出队的时候，只需要考虑出去的元素跟最大元素是不是相等就好了，如果相等那么最大队列里面的元素也需要进行出队。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.deque = queue.deque()</span><br><span class="line">        self.queue = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.deque[<span class="number">0</span>] <span class="keyword">if</span> self.deque <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.deque <span class="keyword">and</span> self.deque[<span class="number">-1</span>] &lt; value:</span><br><span class="line">            self.deque.pop()</span><br><span class="line">        self.deque.append(value)</span><br><span class="line">        self.queue.put(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.deque:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        ans = self.queue.get()</span><br><span class="line">        <span class="keyword">if</span> ans == self.deque[<span class="number">0</span>]:</span><br><span class="line">            self.deque.popleft()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MaxQueue()</span></span><br><span class="line"><span class="comment"># param_1 = obj.max_value()</span></span><br><span class="line"><span class="comment"># obj.push_back(value)</span></span><br><span class="line"><span class="comment"># param_3 = obj.pop_front()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;滑动窗口的最大值&quot;&gt;&lt;a href=&quot;#滑动窗口的最大值&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口的最大值&quot;&gt;&lt;/a&gt;滑动窗口的最大值&lt;/h2&gt;&lt;p&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-489-扫地机器人</title>
    <link href="http://yoursite.com/2020/03/06/leetcode-489-%E6%89%AB%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>http://yoursite.com/2020/03/06/leetcode-489-%E6%89%AB%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2020-03-05T17:50:47.000Z</published>
    <updated>2020-03-06T15:55:42.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扫地机器人"><a href="#扫地机器人" class="headerlink" title="扫地机器人"></a>扫地机器人</h2><p>房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。</p><p>扫地机器人提供4个API，可以向前进，向左转或者向右转。每次转弯90度。</p><p>当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。</p><p>请利用提供的4个API编写让机器人清理整个房间的算法。</p><blockquote><p>interface Robot {<br>  // 若下一个方格为空，则返回true，并移动至该方格<br>  // 若下一个方格为障碍物，则返回false，并停留在原地<br>  boolean move();</p><p> // 在调用turnLeft/turnRight后机器人会停留在原位置<br>  // 每次转弯90度<br>  void turnLeft();<br>  void turnRight();</p><p> // 清理所在方格<br> void clean();<br>}</p></blockquote><p>示例:</p><p>输入:</p><blockquote><p>room = [<br>  [1,1,1,1,1,0,1,1],<br>  [1,1,1,1,1,0,1,1],<br>  [1,0,1,1,1,1,1,1],<br>  [0,0,0,1,0,0,0,0],<br>  [1,1,1,1,1,1,1,1]<br>],<br>row = 1,<br>col = 3</p></blockquote><p>解析:<br>房间格栅用0或1填充。0表示障碍物，1表示可以通过。<br>机器人从row=1，col=3的初始位置出发。在左上角的一行以下，三列以右。<br>注意:</p><p>输入只用于初始化房间和机器人的位置。你需要“盲解”这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用4个给出的API解决问题。<br>扫地机器人的初始位置一定是空地。<br>扫地机器人的初始方向向上。<br>所有可抵达的格子都是相连的，亦即所有标记为1的格子机器人都可以抵达。<br>可以假定格栅的四周都被墙包围。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/robot-room-cleaner" target="_blank" rel="noopener">https://leetcode-cn.com/problems/robot-room-cleaner</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先都会想到用DFS+回溯，只不过这里额外多了个机器人接口，除了进行搜索操作外，还应该及时操作机器人，对应上搜索操作。</p><p>首先看普通的dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.visited = set()</span><br><span class="line">    <span class="comment"># 上 右 下 左</span></span><br><span class="line">    self.rd = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    self.cd = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,robot,i=<span class="number">0</span>,j=<span class="number">0</span>,d=<span class="number">0</span>)</span>:</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 标记遍历</span></span><br><span class="line">    self.visited.add((i,j))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"> <span class="comment"># 四个方向选一个继续dfs</span></span><br><span class="line">        newr,newc = i + self.rd[k], j+self.cd[k]</span><br><span class="line">        <span class="comment"># 如果没有遍历过就进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (newr,newc) <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</span><br><span class="line">            <span class="comment"># 继续进行dfs</span></span><br><span class="line">            self.dfs(robot,newr,newc)</span><br></pre></td></tr></table></figure><p>对应本题，还需要考虑机器人的情况：</p><ul><li>机器人可以运动的方向有四个（上，下，左，右），不可能上一次考虑完<code>上</code>，下一次就去考虑<code>下</code>，机器人旋转需要按照顺时针（或逆时针方向）。</li><li>如果该遍历的地方已经进行了遍历，需要回退，在图上就简单的坐标操作就完成了回退，这里对于机器人还需要进行额外的回退操作。</li><li>机器人方向的一致性：即从当前点，进入到下一个点的时候，机器人的朝向应该是一致的，而返回时候方向恰好相反</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment"># This is the robot's control interface.</span></span><br><span class="line"><span class="comment"># You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment">#class Robot:</span></span><br><span class="line"><span class="comment">#    def move(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Returns true if the cell in front is open and robot moves into the cell.</span></span><br><span class="line"><span class="comment">#        Returns false if the cell in front is blocked and robot stays in the current cell.</span></span><br><span class="line"><span class="comment">#        :rtype bool</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def turnLeft(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Robot will stay in the same cell after calling turnLeft/turnRight.</span></span><br><span class="line"><span class="comment">#        Each turn will be 90 degrees.</span></span><br><span class="line"><span class="comment">#        :rtype void</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def turnRight(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Robot will stay in the same cell after calling turnLeft/turnRight.</span></span><br><span class="line"><span class="comment">#        Each turn will be 90 degrees.</span></span><br><span class="line"><span class="comment">#        :rtype void</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def clean(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Clean the current cell.</span></span><br><span class="line"><span class="comment">#        :rtype void</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.visited = set()</span><br><span class="line">        <span class="comment"># 上 右 下 左    顺时针方向！！！</span></span><br><span class="line">        self.rd = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">        self.cd = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cleanRoom</span><span class="params">(self, robot)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type robot: Robot</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.dfs(robot)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,robot,i=<span class="number">0</span>,j=<span class="number">0</span>,d=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.visited.add((i,j))</span><br><span class="line">        robot.clean()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            new_d = (d+k) % <span class="number">4</span> <span class="comment"># 机器人方向的一致性</span></span><br><span class="line">            newr,newc = i + self.rd[new_d], j+self.cd[new_d]</span><br><span class="line">            <span class="keyword">if</span> (newr,newc) <span class="keyword">not</span> <span class="keyword">in</span> self.visited <span class="keyword">and</span> robot.move():</span><br><span class="line">                <span class="comment"># 内层 dfs 死掉 需要 回头</span></span><br><span class="line">                self.dfs(robot,newr,newc,new_d)</span><br><span class="line">                <span class="comment"># dfs跳出表示遍历完，机器人需要进行回退操作</span></span><br><span class="line">                self.back(robot)</span><br><span class="line">            robot.turnRight() <span class="comment"># 下一个位置  注意跟 newr,newc对应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 专门的回退操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self,robot)</span>:</span></span><br><span class="line">        <span class="comment"># 掉头</span></span><br><span class="line">        robot.turnRight()</span><br><span class="line">        robot.turnRight()</span><br><span class="line">        <span class="comment"># 回退</span></span><br><span class="line">        robot.move()</span><br><span class="line">        <span class="comment"># 重置方向 跟之前一样</span></span><br><span class="line">        robot.turnRight()</span><br><span class="line">        robot.turnRight()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;扫地机器人&quot;&gt;&lt;a href=&quot;#扫地机器人&quot; class=&quot;headerlink&quot; title=&quot;扫地机器人&quot;&gt;&lt;/a&gt;扫地机器人&lt;/h2&gt;&lt;p&gt;房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。&lt;/p&gt;
&lt;p&gt;扫地机器人提供4个AP
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-1103-分糖果II</title>
    <link href="http://yoursite.com/2020/03/05/leetcode-1103-%E5%88%86%E7%B3%96%E6%9E%9CII/"/>
    <id>http://yoursite.com/2020/03/05/leetcode-1103-%E5%88%86%E7%B3%96%E6%9E%9CII/</id>
    <published>2020-03-04T17:13:13.000Z</published>
    <updated>2020-03-05T11:01:46.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分糖果II"><a href="#分糖果II" class="headerlink" title="分糖果II"></a>分糖果II</h2><p>排排坐，分糖果。</p><p>我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p><p>示例 1：</p><p>输入：candies = 7, num_people = 4<br>输出：[1,2,3,1]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3,0]。<br>第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。<br>示例 2：</p><p>输入：candies = 10, num_people = 3<br>输出：[5,2,3]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3]。<br>第四次，ans[0] += 4，最终数组变为 [5,2,3]。</p><p>提示：</p><p>1 &lt;= candies &lt;= 10^9<br>1 &lt;= num_people &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/distribute-candies-to-people" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distribute-candies-to-people</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先看到10^9限制，可能暴力不可行，但是想了下，由于每次分的糖果都是递增的，所以并不是严格的10^9</p><blockquote><p>$等差数列求和 \frac{n(n+1)}{2}&lt;=candies$，这样解出来的n 应该是$\sqrt{candies}$级别的，同时需要初始化时候$O(N)$</p><p>则最终的时间复杂度为$O(max(\sqrt{G},N))$，其中G为糖果数，N为人数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, num_people: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> num_people &lt;=<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> candies &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]*num_people</span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        res = [<span class="number">0</span>]*num_people</span><br><span class="line">        <span class="keyword">while</span> candies &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num_people):</span><br><span class="line">                <span class="keyword">if</span> candies-num &gt;= <span class="number">0</span>:</span><br><span class="line">                    res[i] += num</span><br><span class="line">                    candies -= num</span><br><span class="line">                    num+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res[i] += candies</span><br><span class="line">                    candies = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>更加简短的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, num_people: int)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">0</span>] * num_people</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 巧妙的利用%  因为实在 num_people中循环</span></span><br><span class="line">        <span class="keyword">while</span> candies != <span class="number">0</span>:</span><br><span class="line">            ans[i % num_people] += min(i + <span class="number">1</span>, candies)</span><br><span class="line">            candies -= min(i + <span class="number">1</span>, candies)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="拓展解法"><a href="#拓展解法" class="headerlink" title="拓展解法"></a>拓展解法</h3><p><strong>该解法来自leetcode讨论区：官方提供的解法</strong></p><p>思路是先给第一个小朋友分配好所有他应得的，然后再给第二个。。。以此类推</p><p>那么怎么计算就是个数学问题了</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcierp42qlj30yy0rejup.jpg" alt="数学推导"></p><p>通过上面的操作可以得到<code>p</code>也就是会分配的次数，最后一次由于达不到p+1个糖果，所以最后一次就会被分配剩下所有的。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcievkri7bj31ai0lwgo7.jpg" alt="以C=29为例"></p><p>接下来就是计算如何分配，</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcif0hztaaj31aa0lugp3.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcj96el9buj311w0nmn07.jpg" alt="具体算法"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, num_people: int)</span> -&gt; List[int]:</span></span><br><span class="line">        n = num_people</span><br><span class="line">        <span class="comment"># how many people received complete gifts</span></span><br><span class="line">        p = int((<span class="number">2</span> * candies + <span class="number">0.25</span>)**<span class="number">0.5</span> - <span class="number">0.5</span>) </span><br><span class="line">        remaining = int(candies - (p + <span class="number">1</span>) * p * <span class="number">0.5</span>)</span><br><span class="line">        rows, cols = p // n, p % n</span><br><span class="line">        </span><br><span class="line">        d = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># complete rows</span></span><br><span class="line">            d[i] = (i + <span class="number">1</span>) * rows + int(rows * (rows - <span class="number">1</span>) * <span class="number">0.5</span>) * n</span><br><span class="line">            <span class="comment"># cols in the last row</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; cols:</span><br><span class="line">                d[i] += i + <span class="number">1</span> + rows * n</span><br><span class="line">        <span class="comment"># remaining candies        </span></span><br><span class="line">        d[cols] += remaining</span><br><span class="line">        <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分糖果II&quot;&gt;&lt;a href=&quot;#分糖果II&quot; class=&quot;headerlink&quot; title=&quot;分糖果II&quot;&gt;&lt;/a&gt;分糖果II&lt;/h2&gt;&lt;p&gt;排排坐，分糖果。&lt;/p&gt;
&lt;p&gt;我们买了一些糖果 candies，打算把它们分给排好队的 n = num_peopl
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-286-墙与门</title>
    <link href="http://yoursite.com/2020/03/04/leetcode-286-%E5%A2%99%E4%B8%8E%E9%97%A8/"/>
    <id>http://yoursite.com/2020/03/04/leetcode-286-%E5%A2%99%E4%B8%8E%E9%97%A8/</id>
    <published>2020-03-03T17:59:24.000Z</published>
    <updated>2020-03-03T18:06:47.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="墙与门"><a href="#墙与门" class="headerlink" title="墙与门"></a>墙与门</h2><p>你被给定一个 m × n 的二维网格，网格中有以下三种可能的初始化值：</p><p>-1 表示墙或是障碍物<br>0 表示一扇门<br>INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。<br>你要给每个空房间位上填上该房间到 最近 门的距离，如果无法到达门，则填 INF 即可。</p><p>示例：</p><p>给定二维网格：</p><p>INF  -1  0  INF<br>INF INF INF  -1<br>INF  -1 INF  -1<br>  0  -1 INF INF<br>运行完你的函数后，该网格应该变成：</p><p>  3  -1   0   1<br>  2   2   1  -1<br>  1  -1   2  -1<br>  0  -1   3   4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/walls-and-gates" target="_blank" rel="noopener">https://leetcode-cn.com/problems/walls-and-gates</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首选是BFS，因为这个跟距离门的远近有关，如果都跟门直接相连，那么距离就是1，所以确定基本思路是BFS</p><p>其次，使用<code>多源BFS</code>，意思也就是几个起点同时开始BFS，其实也不是完全严格意义的BFS，如果把他们看成树的话，他们是在同一层的，然后由这一层同时向下遍历。</p><p>这里有一个隐藏的思考点，在于多源同时BFS，那么距离某一个源最近的点肯定会先被修改值为距离，后面的源再遍历到这里的时候就已经有值了，而且再遍历到这个点时候的距离肯定大于等于该点已有的距离值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rooms:</span><br><span class="line">            <span class="keyword">return</span> rooms</span><br><span class="line">        dr = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        dc = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        m = len(rooms)</span><br><span class="line">        n = len(rooms[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 先把有门的地方都放进来，定义有门的地方path距离是0</span></span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> rooms[i][j] == <span class="number">0</span>:</span><br><span class="line">                    q.append((i,j,<span class="number">0</span>))</span><br><span class="line">        <span class="comment"># 多源同时进行BFS</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r,c,path = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                newr,newc = r+dr[i],c+dc[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=newr&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=newc&lt;n <span class="keyword">and</span> <span class="number">2147483647</span> == rooms[newr][newc]:</span><br><span class="line">                    rooms[newr][newc] = path+<span class="number">1</span></span><br><span class="line">                    q.append((newr,newc,path+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;墙与门&quot;&gt;&lt;a href=&quot;#墙与门&quot; class=&quot;headerlink&quot; title=&quot;墙与门&quot;&gt;&lt;/a&gt;墙与门&lt;/h2&gt;&lt;p&gt;你被给定一个 m × n 的二维网格，网格中有以下三种可能的初始化值：&lt;/p&gt;
&lt;p&gt;-1 表示墙或是障碍物&lt;br&gt;0 表示一扇门&lt;
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-994-腐烂的橘子</title>
    <link href="http://yoursite.com/2020/03/04/leetcode-994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>http://yoursite.com/2020/03/04/leetcode-994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</id>
    <published>2020-03-03T17:22:17.000Z</published>
    <updated>2020-03-03T17:41:17.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><p>示例 1：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gch90mxfttj310a07njs9.jpg" alt="img"></p><p>输入：[[2,1,1],[1,1,0],[0,1,1]]<br>输出：4<br>示例 2：</p><p>输入：[[2,1,1],[0,1,1],[1,0,1]]<br>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。<br>示例 3：</p><p>输入：[[0,2]]<br>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p><p>提示：</p><p>1 &lt;= grid.length &lt;= 10<br>1 &lt;= grid[0].length &lt;= 10<br>grid[i][j] 仅为 0、1 或 2</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotting-oranges" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看到提示的数据大小，基本可以判定暴力bfs可以求解的。说下暴力BFS的思路。</p><p>首先为什么要用BFS呢？ 一个烂橘子先感染周边橘子，然后周边橘子再向下感染。这个过程就是BFS的遍历过程呀，而BFS的迭代深度，就是腐烂需要的天数。</p><p>为什么叫暴力呢？因为不可能仅有一个腐烂橘子，可能一开始全局有多个腐烂的橘子，那就需要分别从多个腐烂橘子处进行一次BFS，这时候需要维护一个变量来存储状态<code>stats[i][j],i,j表示第几行第几列，某个数值来表示可能腐烂的天数，初始化为Inf</code>，每从某一个腐烂源进行BFS时候，都更新下stats的状态，让stats记录<code>最小值</code>，最终还需要再遍历一次stats，找到最大的天数，即为最终的腐烂天数。如果最终仍然有橘子的腐烂天数为<code>inf</code></p><h3 id="优秀的解题思路：多源BFS"><a href="#优秀的解题思路：多源BFS" class="headerlink" title="优秀的解题思路：多源BFS"></a>优秀的解题思路：多源BFS</h3><p>为什么叫多源呢？因为前面分析了，开局不可能只有一个烂橘子，所以需要找到最开始的所有烂橘子，然后同时从这些烂橘子开始进行BFS。</p><p>如何保证同时进行BFS呢？其实也不是严格意义的同时，只是这些乱橘子在同一层（同一天），我们把开局的时候算作第0天，那么先将所有烂橘子入队，也就是表示了第0天的烂橘子，当这些烂橘子都出队完成一次更新时候，新进来的烂橘子就都是第1天的。同理….一直到所有橘子都烂掉。</p><p>这里需要维持一个cnt变量，即新鲜橘子有多少个，当cnt为0时候可以跳出，返回结果，如果不为0则返回-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orangesRotting</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 定义4个方向</span></span><br><span class="line">        dr = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        dc = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 先把烂橘子都入队</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 定义一个双端队列</span></span><br><span class="line">        q = deque()</span><br><span class="line">        cnt = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">                    q.append((i,j,<span class="number">0</span>))</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        m_dep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r,c,depth = q.popleft()</span><br><span class="line">            m_dep = max(m_dep,depth)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                newr,newc = r+dr[i],c+dc[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=newr&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=newc&lt;n <span class="keyword">and</span> grid[newr][newc]==<span class="number">1</span>:</span><br><span class="line">                    cnt-=<span class="number">1</span></span><br><span class="line">                    grid[newr][newc] = <span class="number">2</span></span><br><span class="line">                    q.append((newr,newc,depth+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> cnt != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> cnt == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> m_dep</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;腐烂的橘子&quot;&gt;&lt;a href=&quot;#腐烂的橘子&quot; class=&quot;headerlink&quot; title=&quot;腐烂的橘子&quot;&gt;&lt;/a&gt;腐烂的橘子&lt;/h2&gt;&lt;p&gt;在给定的网格中，每个单元格可以有以下三个值之一：&lt;/p&gt;
&lt;p&gt;值 0 代表空单元格；&lt;br&gt;值 1 代表新鲜橘子；
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-986-区间列表的交集</title>
    <link href="http://yoursite.com/2020/03/03/leetcode-986-%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/03/03/leetcode-986-%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-03-02T16:36:04.162Z</published>
    <updated>2020-03-02T16:45:46.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区间列表的交集"><a href="#区间列表的交集" class="headerlink" title="区间列表的交集"></a>区间列表的交集</h2><p>给定两个由一些闭区间组成的列表，每个区间列表都是成对不相交的，并且已经排序。</p><p>返回这两个区间列表的交集。</p><p>（形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。）</p><p>示例：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcg246xnt1j31as0cymxq.jpg" alt="img"></p><blockquote><p>输入：A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]<br>输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]<br>注意：输入和所需的输出都是区间对象组成的列表，而不是数组或列表。</p></blockquote><p>提示：</p><blockquote><p>0 &lt;= A.length &lt; 1000<br>0 &lt;= B.length &lt; 1000<br>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/interval-list-intersections" target="_blank" rel="noopener">https://leetcode-cn.com/problems/interval-list-intersections</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次都要找到两个区间重合的地方：</p><blockquote><p>重合地方的判定：重合部分的起点是两个区间中起点的较大值，重合部分的终点是两个区间终点的较小值#，如果重合部分起点&lt;= 终点，存在重合 加入结果集</p></blockquote><p>找到重合地方之后需要进行移动，移动哪个的标准就是 之前相融合的两个区间，哪个区间终点小，就去掉</p><p>因为我们已经找到一个重合区间或者不存在重合，那么之后还需要再继续重复前面的工作，较小的区间永远都不会再跟后边有交集了 直接去掉较小的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intervalIntersection</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> j &lt; len(B):</span><br><span class="line"><span class="comment"># 重合地方的判定 起点是两个区间起点的最大值，终点是两个区间的最小值</span></span><br><span class="line">            lo = max(A[i][<span class="number">0</span>],B[j][<span class="number">0</span>])</span><br><span class="line">            hi = min(A[i][<span class="number">1</span>],B[j][<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 重合部分起点&lt;= 终点，存在重合 加入结果集</span></span><br><span class="line">            <span class="keyword">if</span> lo &lt;= hi:</span><br><span class="line">                res.append([lo,hi])</span><br><span class="line">            <span class="comment"># 决定哪个区间进行移动</span></span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区间列表的交集&quot;&gt;&lt;a href=&quot;#区间列表的交集&quot; class=&quot;headerlink&quot; title=&quot;区间列表的交集&quot;&gt;&lt;/a&gt;区间列表的交集&lt;/h2&gt;&lt;p&gt;给定两个由一些闭区间组成的列表，每个区间列表都是成对不相交的，并且已经排序。&lt;/p&gt;
&lt;p&gt;返回这两
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-382-链表随机节点</title>
    <link href="http://yoursite.com/2020/03/02/leetcode-382-%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/03/02/leetcode-382-%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9/</id>
    <published>2020-03-01T17:49:44.000Z</published>
    <updated>2020-03-02T14:47:12.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表随机节点"><a href="#链表随机节点" class="headerlink" title="链表随机节点"></a>链表随机节点</h2><p>给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。</p><p>进阶:<br>如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？</p><p>示例:</p><blockquote><p> // 初始化一个单链表 [1,2,3].<br>ListNode head = new ListNode(1);<br>head.next = new ListNode(2);<br>head.next.next = new ListNode(3);<br>Solution solution = new Solution(head);</p><p> // getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。<br>solution.getRandom();</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-random-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-random-node</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把整个单链表看成是一个数据流，从数据流中进行采样</p><p><strong>蓄水池采样</strong>的核心是：</p><blockquote><p>假设当前正要读取第n个数据，则我们以1/n的概率留下该数据，否则留下前n-1个数据中的一个。</p><p>等概率证明：</p><p>对于只有一个数，概率就是1</p><p>对于2个数，则第一个先取到的概率为1，当第二个数来时，选择以1/2的概率保留，则总的来讲，取第一个数的概率为1*1/2，对于第二个数来讲，概率为1/2</p><p>…</p><p>对于n个数，有</p><p>第一个数：$1<em>\frac{1}{2}</em>\frac{2}{3} … *\frac{n-1}{n} = \frac{1}{n}$</p><p>第二个数：$\frac{1}{2}<em>\frac{2}{3} … </em>\frac{n-1}{n} = \frac{1}{n}$</p><p>…</p><p>第n个数：$\frac{1}{n}$</p><p>所以对于这n个数来说是等概率的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, head: ListNode)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @param head The linked list's head.</span></span><br><span class="line"><span class="string">        Note that the head is guaranteed to be not null, so it contains at least one node.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.linkedList = head</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns a random node's value.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 首元素被选中概率为1</span></span><br><span class="line">        r_data = self.linkedList.val</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        p = self.linkedList.next</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 决定是否随机替换掉</span></span><br><span class="line">            <span class="keyword">if</span> rd.randint(<span class="number">1</span>,cnt) == cnt:</span><br><span class="line">                r_data = p.val</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(head)</span></span><br><span class="line"><span class="comment"># param_1 = obj.getRandom()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表随机节点&quot;&gt;&lt;a href=&quot;#链表随机节点&quot; class=&quot;headerlink&quot; title=&quot;链表随机节点&quot;&gt;&lt;/a&gt;链表随机节点&lt;/h2&gt;&lt;p&gt;给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。&lt;/p&gt;
&lt;p&gt;进阶
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
      <category term="蓄水池采样" scheme="http://yoursite.com/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-398-随机数索引（蓄水池采样）</title>
    <link href="http://yoursite.com/2020/03/02/leetcode-398-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2020/03/02/leetcode-398-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/</id>
    <published>2020-03-01T17:34:15.000Z</published>
    <updated>2020-03-01T17:43:04.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机数索引（蓄水池采样）"><a href="#随机数索引（蓄水池采样）" class="headerlink" title="随机数索引（蓄水池采样）"></a>随机数索引（蓄水池采样）</h2><p>给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。</p><p>注意：<br>数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。</p><p>示例:</p><p>int[] nums = new int[] {1,2,3,3,3};<br>Solution solution = new Solution(nums);</p><p>// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。<br>solution.pick(3);</p><p>// pick(1) 应该返回 0。因为只有nums[0]等于1。<br>solution.pick(1);</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/random-pick-index" target="_blank" rel="noopener">https://leetcode-cn.com/problems/random-pick-index</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>限制了不可以开辟额外空间，而且数字大小很大的话，最好是O（N）遍历</p><p><strong>蓄水池采样</strong>的核心是：</p><blockquote><p>假设当前正要读取第n个数据，则我们以1/n的概率留下该数据，否则留下前n-1个数据中的一个。</p><p>等概率证明：</p><p>对于只有一个数，概率就是1</p><p>对于2个数，则第一个先取到的概率为1，当第二个数来时，选择以1/2的概率保留，则总的来讲，取第一个数的概率为1*1/2，对于第二个数来讲，概率为1/2</p><p>…</p><p>对于n个数，有</p><p>第一个数：$1<em>\frac{1}{2}</em>\frac{2}{3} … *\frac{n-1}{n} = \frac{1}{n}$</p><p>第二个数：$\frac{1}{2}<em>\frac{2}{3} … </em>\frac{n-1}{n} = \frac{1}{n}$</p><p>…</p><p>第n个数：$\frac{1}{n}$</p><p>所以对于这n个数来说是等概率的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.nums)):</span><br><span class="line">            <span class="keyword">if</span> self.nums[i] == target:</span><br><span class="line">                <span class="comment"># 第一次遇到 概率就是 1嘛</span></span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    index = i</span><br><span class="line">                <span class="comment"># </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># random.randint 返回闭区间 [a,b]</span></span><br><span class="line">                    <span class="comment"># 选到cnt的概率为  1/cnt</span></span><br><span class="line">                    <span class="keyword">if</span> rd.randint(<span class="number">1</span>,cnt) == cnt:</span><br><span class="line">                        index = i</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.pick(target)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;随机数索引（蓄水池采样）&quot;&gt;&lt;a href=&quot;#随机数索引（蓄水池采样）&quot; class=&quot;headerlink&quot; title=&quot;随机数索引（蓄水池采样）&quot;&gt;&lt;/a&gt;随机数索引（蓄水池采样）&lt;/h2&gt;&lt;p&gt;给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
      <category term="蓄水池采样" scheme="http://yoursite.com/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-周赛-178场</title>
    <link href="http://yoursite.com/2020/03/01/leetcode%E5%91%A8%E8%B5%9B178%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/01/leetcode%E5%91%A8%E8%B5%9B178%E5%9C%BA/</id>
    <published>2020-03-01T07:12:08.000Z</published>
    <updated>2020-03-04T11:40:42.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛——176场"><a href="#周赛——176场" class="headerlink" title="周赛——176场"></a>周赛——176场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">有多少小于当前数字的数字</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/rank-teams-by-votes/" target="_blank" rel="noopener">通过投票对团队排名</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/" target="_blank" rel="noopener">二叉树中的列表</a><br><code>7 分</code> - <a href="https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/" target="_blank" rel="noopener">使网格图至少有一条有效路径的最小代价</a></p><h3 id="T1-有多少小于当前数字的数字"><a href="#T1-有多少小于当前数字的数字" class="headerlink" title="T1 有多少小于当前数字的数字"></a>T1 有多少小于当前数字的数字</h3><p>看了下题目的数字限制</p><blockquote><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><p>直接暴力求解了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m = len(nums)</span><br><span class="line">        res = [<span class="number">0</span>]*m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            res[i] = cnt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="T2-通过投票对团队进行排名"><a href="#T2-通过投票对团队进行排名" class="headerlink" title="T2 通过投票对团队进行排名"></a>T2 通过投票对团队进行排名</h3><p>模拟就好了，先对每个人的投票情况进行计数，这个地方考虑一个存储结构，我用的是字典</p><blockquote><p>每个key对应的value是一个list，list的长度取决于共有多少个团队</p><p>votes = [“ABC”,”ACB”,”ABC”,”ACB”,”ACB”]</p><p>dict = {</p><p>​    ‘A’:[5,0,0],</p><p>​    ‘B’:[0,2,3],</p><p>​    ‘C:[0,3,2]’</p><p>}</p></blockquote><p>统计好投票情况之后，再进行插排即可，插入排序的比较方法需要自己定义一下：</p><p>即按照约定的大小方法，如果得票较靠前则按票数排序，如果票一样则按照字典序排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rankTeams</span><span class="params">(self, votes: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="comment">#先统计 再 插排</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> votes <span class="keyword">or</span> len(votes[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        n = len(votes)</span><br><span class="line">        m = len(votes[<span class="number">0</span>])</span><br><span class="line">        d_cnt = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 完成统计</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                ch = votes[i][j]</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> d_cnt:</span><br><span class="line">                    d_cnt[ch][j] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> ch <span class="keyword">not</span> <span class="keyword">in</span> d_cnt:</span><br><span class="line">                    d_cnt[ch] = [<span class="number">0</span>]*m</span><br><span class="line">                    d_cnt[ch][j] = <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> ch,value <span class="keyword">in</span> d_cnt.items():</span><br><span class="line">            index = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">                res.append(ch)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># insert 插入在前面插入</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">                    tmp = res[i]</span><br><span class="line">                    <span class="keyword">if</span> self.less(tmp,ch,m,d_cnt):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        index = i</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">                res.append(ch)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.insert(index,ch)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">less</span><span class="params">(self,a,b,m,d_cnt)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> d_cnt[a][i] &gt; d_cnt[b][i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> d_cnt[a][i] == d_cnt[b][i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b &gt; a</span><br></pre></td></tr></table></figure><h3 id="T3-二叉树中的列表"><a href="#T3-二叉树中的列表" class="headerlink" title="T3 二叉树中的列表"></a>T3 二叉树中的列表</h3><p>思路很简单，先找到链表头结点对应的树中节点，然后再进行DFS进行匹配即可。</p><ul><li><p>链表头结点对应的树中节点</p><p>我用的bfs，如果当前节点值与链表头结点一样 则开始进入dfs</p></li><li><p>dfs进行匹配</p><p>限制一些规则，分别进行匹配即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubPath</span><span class="params">(self, head: ListNode, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        p = head</span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">while</span> p :</span><br><span class="line">            lst.append(p.val)</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        q = []</span><br><span class="line">        q.append(root)</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span>  q:</span><br><span class="line">            node = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.val == lst[<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># print(node)</span></span><br><span class="line">                flag = self.dfs_check(node,lst,<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_check</span><span class="params">(self,node,lst,index)</span>:</span></span><br><span class="line">        <span class="comment"># print(index)</span></span><br><span class="line">        <span class="keyword">if</span> index == len(lst):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.val != lst[index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.val == lst[index]:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        left = self.dfs_check(node.left,lst,index)</span><br><span class="line">        right = self.dfs_check(node.right,lst,index)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure><h3 id="T4-使网格图至少有一条有效路径的最小代价"><a href="#T4-使网格图至少有一条有效路径的最小代价" class="headerlink" title="T4 使网格图至少有一条有效路径的最小代价"></a>T4 使网格图至少有一条有效路径的最小代价</h3><p>比赛时候都没有来得及看，自己看完题目的第一想法是</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛——176场&quot;&gt;&lt;a href=&quot;#周赛——176场&quot; class=&quot;headerlink&quot; title=&quot;周赛——176场&quot;&gt;&lt;/a&gt;周赛——176场&lt;/h2&gt;&lt;p&gt;&lt;code&gt;3 分&lt;/code&gt; - &lt;a href=&quot;https://leetcode-c
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="http://yoursite.com/2020/03/01/leetcode%E5%91%A8%E8%B5%9B177%E5%9C%BA/"/>
    <id>http://yoursite.com/2020/03/01/leetcode%E5%91%A8%E8%B5%9B177%E5%9C%BA/</id>
    <published>2020-03-01T04:26:56.628Z</published>
    <updated>2020-03-01T07:12:41.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周赛——177场"><a href="#周赛——177场" class="headerlink" title="周赛——177场"></a>周赛——177场</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;周赛——177场&quot;&gt;&lt;a href=&quot;#周赛——177场&quot; class=&quot;headerlink&quot; title=&quot;周赛——177场&quot;&gt;&lt;/a&gt;周赛——177场&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode周赛" scheme="http://yoursite.com/tags/Leetcode%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-13-罗马数字转整数</title>
    <link href="http://yoursite.com/2020/02/29/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/29/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</id>
    <published>2020-02-29T07:32:17.000Z</published>
    <updated>2020-02-29T07:43:31.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><p>输入: “III”<br>输出: 3<br>示例 2:</p><p>输入: “IV”<br>输出: 4<br>示例 3:</p><p>输入: “IX”<br>输出: 9<br>示例 4:</p><p>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.<br>示例 5:</p><p>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/roman-to-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本上思路就是 模拟</p><p>一个字符一个字符的置换成对应的数，如果较小的出现在较大的前面，则进行减法，其余进行加法操作。</p><p>这样就产生了前一个和当前字符的概念，需要使用两个指针来记录前一个 和后一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        table = &#123;<span class="string">'M'</span>:<span class="number">1000</span>, </span><br><span class="line">                 <span class="string">'D'</span>:<span class="number">500</span>,</span><br><span class="line">                 <span class="string">'C'</span>:<span class="number">100</span>,</span><br><span class="line">                 <span class="string">'L'</span>:<span class="number">50</span>,</span><br><span class="line">                 <span class="string">'X'</span>:<span class="number">10</span>,</span><br><span class="line">                 <span class="string">'V'</span>:<span class="number">5</span>,</span><br><span class="line">                 <span class="string">'I'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre = table[s[<span class="number">0</span>]]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            cur = table[s[i]]</span><br><span class="line">            <span class="keyword">if</span> pre &lt; cur:</span><br><span class="line">                res -= pre</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += pre</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="comment"># 退出时候，最后一个 赋值为 pre 直接加</span></span><br><span class="line">        res += pre</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;罗马数字转整数&quot;&gt;&lt;a href=&quot;#罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;罗马数字转整数&quot;&gt;&lt;/a&gt;罗马数字转整数&lt;/h2&gt;&lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;p&gt;字符       
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>娇娇实验要点</title>
    <link href="http://yoursite.com/2020/02/29/%E5%A8%87%E5%A8%87%E5%AE%9E%E9%AA%8C%E8%A6%81%E7%82%B9/"/>
    <id>http://yoursite.com/2020/02/29/%E5%A8%87%E5%A8%87%E5%AE%9E%E9%AA%8C%E8%A6%81%E7%82%B9/</id>
    <published>2020-02-28T18:16:44.886Z</published>
    <updated>2020-02-28T18:16:44.886Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-28-实现strStr</title>
    <link href="http://yoursite.com/2020/02/27/leetcode-28-%E5%AE%9E%E7%8E%B0strStr/"/>
    <id>http://yoursite.com/2020/02/27/leetcode-28-%E5%AE%9E%E7%8E%B0strStr/</id>
    <published>2020-02-26T17:25:56.000Z</published>
    <updated>2020-03-08T13:06:42.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr"></a>实现strStr</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        kmp = KMP(needle)</span><br><span class="line">        <span class="keyword">return</span> kmp.search(haystack)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pat)</span>:</span></span><br><span class="line">        self.p_len = len(pat)</span><br><span class="line">        self.dp = [[<span class="number">0</span>]*<span class="number">128</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.p_len)]</span><br><span class="line">        self.pat = pat</span><br><span class="line"><span class="comment"># 这段太经典了，尝试用 状态机的 形式来理解这段</span></span><br><span class="line">        <span class="comment"># i 所代表的 不要第一时间理解为下标，这个地方更好的理解是状态</span></span><br><span class="line">        x=<span class="number">0</span></span><br><span class="line">        self.dp[<span class="number">0</span>][ord(self.pat[<span class="number">0</span>])] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,self.p_len):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">128</span>):</span><br><span class="line">                <span class="keyword">if</span> ord(self.pat[i]) == j:</span><br><span class="line">                    <span class="comment"># 遇到符合标准的字符串</span></span><br><span class="line">                    self.dp[i][j] = i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.dp[i][j] = self.dp[x][j]</span><br><span class="line">            </span><br><span class="line">            x = self.dp[x][ord(self.pat[i])]</span><br><span class="line">        print(self.dp)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, tat)</span>:</span></span><br><span class="line">        m = len(tat)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            j = self.dp[j][ord(tat[i])]</span><br><span class="line">            <span class="keyword">if</span> j == self.p_len:</span><br><span class="line">                <span class="keyword">return</span> i-self.p_len+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现strStr&quot;&gt;&lt;a href=&quot;#实现strStr&quot; class=&quot;headerlink&quot; title=&quot;实现strStr&quot;&gt;&lt;/a&gt;实现strStr&lt;/h2&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-12-整数转罗马数字</title>
    <link href="http://yoursite.com/2020/02/26/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/02/26/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-26T14:15:31.000Z</published>
    <updated>2020-02-26T14:19:12.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:</p><p>输入: 3<br>输出: “III”<br>示例 2:</p><p>输入: 4<br>输出: “IV”<br>示例 3:</p><p>输入: 9<br>输出: “IX”<br>示例 4:</p><p>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.<br>示例 5:</p><p>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>主要的思路就是 查表+贪心</p><p>查表体现在：我们尽可能将核心组成数组 用一个dict 存储起来</p><p>贪心体现在：每次我们都是先用一个尽可能大的 表中数字去进行处理，优先使用大的符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        table = &#123;<span class="string">'M'</span>:<span class="number">1000</span>, </span><br><span class="line">                 <span class="string">'CM'</span>:<span class="number">900</span>,</span><br><span class="line">                 <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">                 <span class="string">'CD'</span>:<span class="number">400</span>,</span><br><span class="line">                 <span class="string">'C'</span>:<span class="number">100</span>,</span><br><span class="line">                 <span class="string">'XC'</span>:<span class="number">90</span>,</span><br><span class="line">                 <span class="string">'L'</span>:<span class="number">50</span>,</span><br><span class="line">                 <span class="string">'XL'</span>:<span class="number">40</span>,</span><br><span class="line">                 <span class="string">'X'</span>:<span class="number">10</span>,</span><br><span class="line">                 <span class="string">'IX'</span>:<span class="number">9</span>,</span><br><span class="line">                 <span class="string">'V'</span>:<span class="number">5</span>,</span><br><span class="line">                 <span class="string">'IV'</span>:<span class="number">4</span>,</span><br><span class="line">                 <span class="string">'I'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> table.keys(): <span class="comment"># 潜在的贪心过程，因为table 我是按从大到小写的，遍历过程也会按照从大到小进行</span></span><br><span class="line">            cnt = num // table[key]</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            res += cnt * key</span><br><span class="line">            num -= cnt * table[key]</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整数转罗马数字&quot;&gt;&lt;a href=&quot;#整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;整数转罗马数字&quot;&gt;&lt;/a&gt;整数转罗马数字&lt;/h2&gt;&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;p&gt;字符       
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-25-K个一组翻转链表</title>
    <link href="http://yoursite.com/2020/02/26/leetcode-25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/26/leetcode-25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-25T17:42:42.000Z</published>
    <updated>2020-03-03T18:16:28.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例 :</p><p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>说明 :</p><p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解题方式很简单，就是K个翻转一次，比较难理解的地方在于需要维护多个变量，来实现这个方法</p><blockquote><ul><li>start指针：待翻转链表的头结点，翻转后变成尾结点</li><li>end指针：待翻转链表的尾节点，翻转后变成头结点</li><li>pre指针：待翻转链表的前面部分（可以理解为 已经完成操作的节点的尾部）</li><li>nxt指针：未进行操作的链表头部</li></ul></blockquote><p>下图来自LeetCode讨论区：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/" target="_blank" rel="noopener">王小二</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc96g7ia6nj30lx10stax.jpg" alt="k个一组翻转链表.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pre = dummy</span><br><span class="line">        end = dummy</span><br><span class="line">        dummy.next = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> end:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                end = end.next <span class="keyword">if</span> end <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> end:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            nxt = end.next</span><br><span class="line">            end.next = <span class="literal">None</span></span><br><span class="line">            start = pre.next</span><br><span class="line">            pre.next = self.reverse(start)</span><br><span class="line">            start.next = nxt <span class="comment">### start 跑到尾部了</span></span><br><span class="line">            pre = start</span><br><span class="line">            end = start</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            nxt = p.next</span><br><span class="line">            p.next = pre</span><br><span class="line">            pre = p</span><br><span class="line">            p = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;K个一组翻转链表&quot;&gt;&lt;a href=&quot;#K个一组翻转链表&quot; class=&quot;headerlink&quot; title=&quot;K个一组翻转链表&quot;&gt;&lt;/a&gt;K个一组翻转链表&lt;/h2&gt;&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-138-复制带随机指针的链表</title>
    <link href="http://yoursite.com/2020/02/26/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/26/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-25T16:48:37.000Z</published>
    <updated>2020-02-25T17:45:35.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h2><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的 深拷贝。 </p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</p><p>示例 1：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc94qezsp7j31gs0aq0u5.jpg" alt="img"></p><blockquote><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p></blockquote><p>更多示例 <a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">原题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用的是剑指里面的解题思路。先把链表的每一个节点都copy一遍，并且追加到该节点之后</p><blockquote><p>即: 1-2-3-4 -&gt;  1-1’-2-2’-3-3’-4-4’</p></blockquote><p>然后再将随机指针按照原来的形式，追加到各个复制节点上</p><blockquote><p>即 若原来有一个 1——4的随机指针，那么复制的节点 也应该有 1’——4’这样一个随机指针</p></blockquote><p>然后再重新遍历整个链表，将链表拆开，返回深拷贝的链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 1.复制一遍链表</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            tmp = Node(p.val,p.next)</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = tmp.next</span><br><span class="line">        <span class="comment"># 2.复制random 指针</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p :</span><br><span class="line">            q = p.next</span><br><span class="line">            q.random = p.random.next <span class="keyword">if</span> p.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p = q.next</span><br><span class="line">        <span class="comment"># 3.从头遍历，拆出来指针</span></span><br><span class="line">        p = head</span><br><span class="line">        dummy = head.next</span><br><span class="line">        q = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q.random = p.random.next <span class="keyword">if</span> p.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p = q.next</span><br><span class="line">            q.next = p.next <span class="keyword">if</span> p <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            q = q.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;复制带随机指针的链表&quot;&gt;&lt;a href=&quot;#复制带随机指针的链表&quot; class=&quot;headerlink&quot; title=&quot;复制带随机指针的链表&quot;&gt;&lt;/a&gt;复制带随机指针的链表&lt;/h2&gt;&lt;p&gt;给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何
      
    
    </summary>
    
    
      <category term="算法刷题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2020/02/22/SwordOffer/test/"/>
    <id>http://yoursite.com/2020/02/22/SwordOffer/test/</id>
    <published>2020-02-22T13:20:09.000Z</published>
    <updated>2020-02-22T13:20:38.084Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>SwordOffer/Untitled</title>
    <link href="http://yoursite.com/2020/02/22/SwordOffer/Untitled/"/>
    <id>http://yoursite.com/2020/02/22/SwordOffer/Untitled/</id>
    <published>2020-02-22T13:19:51.649Z</published>
    <updated>2020-02-22T13:19:51.649Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Union-Find</title>
    <link href="http://yoursite.com/2020/02/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/02/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2020-02-22T08:23:41.000Z</published>
    <updated>2020-02-22T08:25:05.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Union-find"><a href="#Union-find" class="headerlink" title="Union-find"></a>Union-find</h2><p>并查集，主要用来解决再一个集合中查找是否存在另一个元素，或者合并两个集合。</p><p>涉及到的主要操作就是Union和Find</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Union-find&quot;&gt;&lt;a href=&quot;#Union-find&quot; class=&quot;headerlink&quot; title=&quot;Union-find&quot;&gt;&lt;/a&gt;Union-find&lt;/h2&gt;&lt;p&gt;并查集，主要用来解决再一个集合中查找是否存在另一个元素，或者合并两个集合。&lt;
      
    
    </summary>
    
    
      <category term="算法基础" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
