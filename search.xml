<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BeautifulSoup 4 部分使用笔记</title>
    <url>/2019/12/27/BeautifulSoup4/</url>
    <content><![CDATA[<h1 id="BeautifulSoup-4-使用理解"><a href="#BeautifulSoup-4-使用理解" class="headerlink" title="BeautifulSoup 4  使用理解"></a>BeautifulSoup 4  使用理解</h1><p><strong>核心</strong>：Beautiful Soup将复杂HTML文档转换成一个复杂的<strong>树形结构</strong>,每个节点都是Python对象,所有对象可以归纳为4种: <code>Tag</code> , <code>NavigableString</code> , <code>BeautifulSoup</code> , <code>Comment</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全篇都是以这个例子进行展开</span></span><br><span class="line">html_doc = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html_doc)</span><br></pre></td></tr></table></figure>
<h2 id="基础节点类型"><a href="#基础节点类型" class="headerlink" title="基础节点类型"></a>基础节点类型</h2><ul>
<li><p>Tag：Tag节点也是最基本的节点类型。两个重要属性 name  attributes（类似字典包含id,class 等等）</p>
</li>
<li><p>NavigableString：包含在Tag中的字符串</p>
<p>tag中的字符串不能编辑，但是可以被替换成其他的字符串，用replace_with()</p>
</li>
<li><p>BeautifulSoup：</p>
<p>支持搜索文档树 和 遍历文档树的大部分方法</p>
</li>
<li><p><code>Comment</code> 对象是一个特殊类型的 <code>NavigableString</code> 对象，大部分使用用来表示注释部分</p>
</li>
</ul>
<p>Tag，NavigableString和BeautifulSoup基本上就可以表示html和XML中的所有内容了</p>
<h2 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h2><p>理解BeautifulSoup 将HTML文档解析成为DOM文档树，这个树的每个标签代表一个节点。一个Tag可能包含多个String或其他Tag，这些都是这个Tag的子节点，BeautifulSoup提供了许多操作和遍历子节点的属性</p>
<h3 id="contents-和-children"><a href="#contents-和-children" class="headerlink" title=".contents 和 .children"></a>.contents 和 .children</h3><p>遍历文档树的两个重要属性<code>.contents</code>和<code>.children</code></p>
<p>.contents 会将当前节点（TAG）的子节点以<strong>列表</strong>的形式输出</p>
<p><strong>一个节点其子节点可能有其他TAG 也可能有字符串String，string 是不可迭代的</strong></p>
<p>.children 产生<strong>生成器</strong>，可以对tag的子节点进行循环</p>
<h3 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h3><p><code>.descendants</code> 属性可以对所有tag的子孙节点进行<strong>递归循环</strong>遍历（<code>先序</code>遍历形式）：</p>
<h3 id="strings-和-stripped-strings"><a href="#strings-和-stripped-strings" class="headerlink" title=".strings 和 stripped_strings"></a>.strings 和 stripped_strings</h3><p>如果tag中包含多个字符串 ,可以使用 <code>.strings</code> 来循环获取:</p>
<blockquote>
<p>print(‘ ‘.join([string.strip() for string in soup.body.find_all(‘p’)[1].strings]))</p>
<p>soup 是BeautifulSoup对象，通过.body进入 body 标签下，进行find_all(‘p’)查找全部P标签</p>
<p>拿到[1]的p标签，然后进行strings，产生generator 通过join方式将 生成器的内容进行结合</p>
<p> 输出为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Once upon a time there were three little sisters; <span class="keyword">and</span> their names were Elsie , Lacie <span class="keyword">and</span> Tillie ;</span><br><span class="line"><span class="keyword">and</span> they lived at the bottom of a well.</span><br></pre></td></tr></table></figure>
</blockquote>
<p> <code>.stripped_strings</code> 可以去除多余空白内容(空格，空行)</p>
<h3 id="父节点-parent-和-parents"><a href="#父节点-parent-和-parents" class="headerlink" title="父节点.parent 和 .parents"></a>父节点.parent 和 .parents</h3><p>.parent 获取某个元素的父节点。</p>
<p>.parents 属性可以用递归得到元素的所有父辈节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">link = soup.a</span><br><span class="line">link</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> link.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(parent.name)</span><br><span class="line"><span class="comment"># p</span></span><br><span class="line"><span class="comment"># body</span></span><br><span class="line"><span class="comment"># html</span></span><br><span class="line"><span class="comment"># [document]</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<h3 id="兄弟节点-next-sibling-和-previous-sibling"><a href="#兄弟节点-next-sibling-和-previous-sibling" class="headerlink" title="兄弟节点.next_sibling 和 .previous_sibling"></a>兄弟节点.next_sibling 和 .previous_sibling</h3><p>同一层的标签，是兄弟节点，他们来自同一个 父节点</p>
<p>在文档树中,使用 <code>.next_sibling</code> 和 <code>.previous_sibling</code> 属性来查询兄弟节点</p>
<p>通过 <code>.next_siblings</code> 和 <code>.previous_siblings</code> 属性可以对当前节点的兄弟节点迭代输出</p>
<p>BeautifulSoup解决的思路就是：</p>
<p>先搜索String 找到可能 关键句，然后从关键句的地方进行判断进行删除</p>
<h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><p>心得：一般爬虫使用这个来爬取数据，正常都是用到的Bs4的搜索技巧，最近实习工作中，使用这个来对新闻进行修改（冗余优化），还需要使用<strong>修改</strong>技巧，修改嘛，无非就是（增删改）</p>
<p>对于增，用的比较少。（冗余优化 主要是删改）</p>
<p>对于删除，首先要定位到目标位置，需要观察一批数据的情况</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>beautifulsoup  官网中文</p>
<p><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id18" target="_blank" rel="noopener">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id18</a></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-35-搜索插入位置（一点都不easy）</title>
    <url>/2019/12/26/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p>
<p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p>
<p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>妈了个鸡，一点都不简单，二分这个坑。。。</p>
<p>原本的二分检索，如果检索不到target的话，跳出循环时候，会有left &gt;  right即left=right+1</p>
<p>这个时候对应两种情况:</p>
<ul>
<li>一种是由于<code>nums[mid]&lt;target</code>导致left=mid+1跳出，此时left-1&lt;target&lt;left</li>
<li>一种是由于 <code>nums[mid]&gt;target</code>导致right=mid-1跳出，此时 right&lt;target&lt;right+1 而left=right+1,即也是left-1&lt;target&lt;left</li>
</ul>
<p>即不论什么情况，只要没有检索到目标值，那么target一定介于<code>left-1</code>和<code>left</code>之间，对应插入位置就是left</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-313-超级丑数</title>
    <url>/2019/12/25/leetcode-313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="超级丑数"><a href="#超级丑数" class="headerlink" title="超级丑数"></a>超级丑数</h2><p>编写一段程序来查找第 n 个超级丑数。</p>
<p>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</p>
<p>示例:</p>
<p>输入: n = 12, primes = [2,7,13,19]<br>输出: 32<br>解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br>说明:</p>
<blockquote>
<p>1 是任何给定 primes 的超级丑数。</p>
<p>给定 primes 中的数字以升序排列。<br>0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。<br>第 n 个超级丑数确保在 32 位有符整数范围内。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>原本丑数就是质因数只有2，3，5的数字，这个题目扩展为丑数为一个list的质因数</p>
<p>思路都是一样的，只不过需要维护一个list的指针，以及一个丑数序列</p>
<p><code>p_list</code>是对应<code>primes</code>数组每个元素对应的指针数组，<code>p_list</code>中元素表示<code>primes</code>中质因数的指针</p>
<p><code>ugly</code>来记录超级丑数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span><span class="params">(self, n, primes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type primes: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> primes:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = len(primes)</span><br><span class="line">        p_list = [<span class="number">0</span>]*length</span><br><span class="line">        ugly = [<span class="number">0</span>]*n</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            min_value = <span class="number">2</span>**<span class="number">32</span></span><br><span class="line">            <span class="comment"># 找下一个丑数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length): <span class="comment"># 升序排列的</span></span><br><span class="line">                <span class="keyword">if</span> primes[j]*ugly[p_list[j]] &lt;= min_value:</span><br><span class="line">                    min_value = primes[j]*ugly[p_list[j]]</span><br><span class="line">            <span class="comment"># 满足条件的指针+1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length):</span><br><span class="line">                <span class="keyword">if</span> primes[j]*ugly[p_list[j]] == min_value:</span><br><span class="line">                    p_list[j] += <span class="number">1</span></span><br><span class="line">            ugly[i] = min_value</span><br><span class="line">        </span><br><span class="line">     		<span class="keyword">return</span> ugly[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-264-丑数II</title>
    <url>/2019/12/24/leetcode-264-%E4%B8%91%E6%95%B0II/</url>
    <content><![CDATA[<h2 id="丑数II"><a href="#丑数II" class="headerlink" title="丑数II"></a>丑数II</h2><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例:</p>
<p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p>
<blockquote>
<p>1 是丑数。<br>n 不超过1690。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据丑数的定义，某个数如果是丑数一定是2，3，5的公倍数，那我们可以根据这个规则将丑数逐一列举出来。</p>
<p>列举的基本想法就是：如果一个数已经是丑数了，那么这个数的2，3，5倍仍然是丑数。</p>
<p>我们可以记录之前产生的所有丑数，然后维护三个指针，<code>p2</code>,<code>p3</code>,<code>p5</code>这三个指针什么用处呢？</p>
<blockquote>
<p>三个指针分别表示下一个丑数可能产生的情况：p2*2  p3*3  p5*5</p>
<p>这三个数哪个最小，就是下一个丑数，以最开始为例，第一个丑数为1,那么p2,p3,p5都指向1</p>
<p>1的下一个丑数是什么呢？ min(1*2,1*3,1*5) 为2，那么下一个丑数就是2，同时p2指针向前挪动一个</p>
<p>比如此时丑数序列已经有了[1,2,3,4,5,6,8,9,10]，p2指向6，p3指向4，p5指向3，</p>
<p>10的下一个丑数就是min(mem[p2]*2,mem[p3]*3,mem[p5]*5)</p>
<p>则下一个丑数为12</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        mem = [<span class="number">0</span>]*n</span><br><span class="line">        mem[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        p3 = <span class="number">0</span></span><br><span class="line">        p5 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            mem[i] = min(mem[p2]*<span class="number">2</span>,mem[p3]*<span class="number">3</span>,mem[p5]*<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> mem[i] == mem[p2]*<span class="number">2</span>:</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mem[i] == mem[p3]*<span class="number">3</span>:</span><br><span class="line">                p3+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mem[i] == mem[p5]*<span class="number">5</span>:</span><br><span class="line">                p5+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mem[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>又一次写没写出来就是p2,p3,p5的含义搞混了</li>
<li>一定是在之前生成的丑数基础上进行操作</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-263-丑数</title>
    <url>/2019/12/23/leetcode-263-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例 1:</p>
<p>输入: 6<br>输出: true<br>解释: 6 = 2 × 3<br>示例 2:</p>
<p>输入: 8<br>输出: true<br>解释: 8 = 2 × 2 × 2<br>示例 3:</p>
<p>输入: 14<br>输出: false<br>解释: 14 不是丑数，因为它包含了另外一个质因数 7。<br>说明：</p>
<p>1 是丑数。<br>输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>丑数的定义已经说明白了，<code>只包含质因数2，3，5的正整数，1也是丑数</code></p>
<p>给我们一个数，只需要不断用丑数的质因数去除待测试的数即可，如果最后的结果是1则是丑数，否则不是</p>
<p>（0这个数十个坑，记得排除）</p>
<p>递归解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">3</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">5</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-23-合并K个排序链表</title>
    <url>/2019/12/23/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a>合并K个排序链表</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题目其实比较简单，因为其子问题就是合并两个排序链表，这个是比较简单的。如果已经能解决两个链表了，那么K个链表也好解决。这里我们采用的<strong>分治</strong>的策略。</p>
<p>对于k个链表，我们最终可以分别两两合并，然后再将合并的结果再两两合并…</p>
<p>这个过程不就是归并排序的过程嘛…</p>
<blockquote>
<p>我们回想下归并排序的过程</p>
<p>给定：[5,2,3,4,1,6]</p>
<p>[5] [2] [3] [4] [1] [6]  两两合并</p>
<p>[2,5],[3,4],[1,6] 再两两合并</p>
<p>[2,3,4,5],[1,6] 再两两合并</p>
<p>[1,2,3,4,5,6] </p>
</blockquote>
<p>归并排序我们操作的是两个元素比较大小然后决定谁在前谁在后，而本题我们解决的是链表，只需要把基本操作换成链表的合并即可。</p>
<p>模板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">()</span>:</span></span><br><span class="line">  	divide(全部)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">()</span>:</span></span><br><span class="line">    终止条件...</span><br><span class="line">    </span><br><span class="line">    中间 =  (左+右)/<span class="number">2</span></span><br><span class="line">    左结果 = divide 左边</span><br><span class="line">    有结果 = divide 右边</span><br><span class="line">  	合并 左结果，右结果</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">()</span>:</span></span><br><span class="line">  	进行合并操作</span><br></pre></td></tr></table></figure>
<p>根据上边的模板</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># divide 整个数组</span></span><br><span class="line">        <span class="keyword">return</span> self.divide(lists,<span class="number">0</span>,len(lists)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 划分操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, lists, left, right)</span>:</span></span><br><span class="line">      	<span class="comment"># 终止条件: 仅一个元素</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> lists[left]</span><br><span class="line">        <span class="comment"># 找中间</span></span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 左结果 = divide 左边</span></span><br><span class="line">        l1 = self.divide(lists, left, mid)</span><br><span class="line">				<span class="comment"># 右结果 = divide 右边</span></span><br><span class="line">        l2 = self.divide(lists, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="comment"># 合并（左结果，右结果）</span></span><br><span class="line">        <span class="keyword">return</span> self.merge2Lists(l1,l2)</span><br><span class="line">		<span class="comment"># 合并操作：本题的合并操作是 链表级别的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge2Lists</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        p1 = left</span><br><span class="line">        p2 = right</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val &lt; p2.val:</span><br><span class="line">                p.next = p1</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">elif</span> p1.val &gt;= p2.val:</span><br><span class="line">                p.next = p2</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> p1:</span><br><span class="line">            p.next = p1</span><br><span class="line">        <span class="keyword">if</span> p2:</span><br><span class="line">            p.next = p2</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-2-两数相加</title>
    <url>/2019/12/22/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<blockquote>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目不难，但是细节问题吧…还是坑不少的</p>
<p>下面这个解法的思路就是先对应位相加，需要进位的记录下，然后在下一位时候考虑进去。总的思路是循环加到某个链表为空，则跳出处理。那么只需要把不空的那个链表链接到结果链表后边就可以了。</p>
<p>但是少考虑这样会出现的问题。</p>
<blockquote>
<p>[1]</p>
<p>[9,9]</p>
<p>Result:[0,0,1]</p>
<p>但是我的返回结果是:[0,10]</p>
</blockquote>
<p>下面附上<strong>错误代码</strong></p>
<p>这个想要更正也可以，会边的if语句换成while，然后进行对应操作即可。但是这样实际上把问题变复杂了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">            tmp.val = (p1.val+p2.val+carry)%<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> p1.val + p2.val +carry &gt;=<span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">            p.next = p2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            p.next = p1</span><br><span class="line">        <span class="keyword">if</span> carry==<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> p.next:</span><br><span class="line">            a = ListNode(<span class="number">1</span>)</span><br><span class="line">            p.next = a</span><br><span class="line">        <span class="keyword">elif</span> carry==<span class="number">1</span> <span class="keyword">and</span> p.next:</span><br><span class="line">            p.next.val += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<p>正确思路：</p>
<p>不用提前结束为空的链表，实际过程，两个链表是同步走的，如果其中一个链表为空了，我们可认为这个部分的值<strong>为0</strong> 即可，其他操作都一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">or</span> p2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">                x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = p1.val</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">                y = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y = p2.val</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            </span><br><span class="line">            tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">            tmp.val = (x+y+carry)%<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> x+y+carry &gt;=<span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> carry==<span class="number">1</span>:</span><br><span class="line">            a = ListNode(<span class="number">1</span>)</span><br><span class="line">            p.next = a</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-16-最接近的三数之和</title>
    <url>/2019/12/22/leetcode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本还是<a href="https://mereder.github.io/2019/11/25/leetcode-15-三数之和/" target="_blank" rel="noopener">三数之和</a>的思路，但是不用考虑重复问题。毕竟是找最接近的，而不是完全命中。相对简单点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        min_error = <span class="number">2</span>**<span class="number">32</span><span class="number">-1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            right = n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[left] + nums[right] &lt; target:</span><br><span class="line">                    <span class="keyword">if</span> abs(nums[i] + nums[left] + nums[right] - target) &lt; min_error:</span><br><span class="line">                        min_error = abs(nums[i] + nums[left] + nums[right] - target)</span><br><span class="line">                        result = nums[i] + nums[left] + nums[right]</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[left] + nums[right] &gt;= target:</span><br><span class="line">                    <span class="keyword">if</span> abs(nums[i] + nums[left] + nums[right] - target) &lt; min_error:</span><br><span class="line">                        min_error = abs(nums[i] + nums[left] + nums[right] - target)</span><br><span class="line">                        result = nums[i] + nums[left] + nums[right]</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>HDFS 操作指令</title>
    <url>/2019/12/22/hadoop%20hdfs%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>其操作指令大部分跟linux下的命令差不多。</p>
<p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html</a></p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -test -e  file_path</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测路径是否存在</span></span><br><span class="line">其对应返回这可以同 shell $?  来捕捉</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-278-第一个错误的版本</title>
    <url>/2019/12/22/leetcode-278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<blockquote>
<p> 示例:</p>
<p>给定 n = 5，并且 version = 4 是第一个错误的版本。</p>
<p>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true</p>
<p>所以，4 是第一个错误的版本。 </p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是将二分法应用到实际的问题解决当中。</p>
<p>还有诸如类似什么两地之间的电线有一处坏了，如果你是一名电工如何最快的确定出问题的地方在哪。</p>
<p>题随不难，上代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = n+<span class="number">1</span>  <span class="comment"># 这个地方很诡异  right=n 和 right = n+1 都能过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+((right-left) &gt;&gt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>两个水桶的装水问题</title>
    <url>/2019/12/18/%E8%A3%85%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="装水问题"><a href="#装水问题" class="headerlink" title="装水问题"></a>装水问题</h2><p>一个和尚去河边挑水，带了两个桶，一个是能装4斤水，一个能装9斤水，问如何可以装一个6斤水的出来</p>
<p>（or 一个能装3斤水一个能装5斤水）</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>A桶4斤，B桶9斤</p>
<p>只能有几种操作：</p>
<blockquote>
<p>Fill A</p>
<p>Fill B</p>
<p>Empty A</p>
<p>Empty B</p>
<p>A-B</p>
<p>B-A</p>
</blockquote>
<p>我们的操作序列如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.fill B -&gt; A:0 B:9</span><br><span class="line">2.B-A 	 -&gt; A:4 B:5</span><br><span class="line">3.empty A-&gt; A:0 B:5</span><br><span class="line">4.B-A		 -&gt; A:4 B:1</span><br><span class="line">5.empty A-&gt; A:0 B:1</span><br><span class="line">6.B-A  	 -&gt; A:1 B:0</span><br><span class="line">7.fill B -&gt; A:1 B:9</span><br><span class="line">8.B-A  	 -&gt; A:4 B:6</span><br></pre></td></tr></table></figure>
<p>即此时B桶内为6斤水，完成目标</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>一个和尚去河边挑水，带了两个桶，一个是能装4斤水，一个能装9斤水</p>
<p>1),要求写出算法，目标是如何装出6斤水</p>
<p>2),假设两个桶容量任意，比如X斤和Y斤,目标是Z斤;要求写出算法</p>
]]></content>
      <categories>
        <category>智力题</category>
      </categories>
  </entry>
  <entry>
    <title>Hive 日常使用</title>
    <url>/2019/12/18/Hive/</url>
    <content><![CDATA[<h3 id="命令行执行hive操作"><a href="#命令行执行hive操作" class="headerlink" title="命令行执行hive操作"></a>命令行执行hive操作</h3><p>其中设置显示表头，<code>set hive.cli.print.header=True</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive -e "set hive.cli.print.header=True; select * from 表名 limit 2"</span><br></pre></td></tr></table></figure>
<h3 id="hive-建表"><a href="#hive-建表" class="headerlink" title="hive 建表"></a>hive 建表</h3><p>建表分为内部表和外部表，内部表的意思是指元数据和对应表都在内部，如果删除表之后，对应的元数据和表数据都会被删除。</p>
<p>外部表是通过<code>external</code> 来修饰的，其表的元数据也是存放在内部，但是对应数据是存储在hdfs上的，当删除表后，对应元数据会进行删除，而数据仍会保留在hdfs上。所以建表的时候需要指定好<code>location</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> table_name</span><br><span class="line">( <span class="keyword">query</span> <span class="keyword">string</span>,</span><br><span class="line"> 	<span class="keyword">id</span>		<span class="keyword">string</span>,</span><br><span class="line"> 	pvid 	<span class="keyword">string</span>,</span><br><span class="line"> 	logid <span class="keyword">string</span>,</span><br><span class="line">  wid	  <span class="built_in">bigint</span>,</span><br><span class="line">  pos   <span class="built_in">int</span>,</span><br><span class="line">  extras <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;,</span><br><span class="line"> 	label <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (dt <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>
<h3 id="hive-表的导入"><a href="#hive-表的导入" class="headerlink" title="hive 表的导入"></a>hive 表的导入</h3><h3 id="显示建表语句"><a href="#显示建表语句" class="headerlink" title="显示建表语句"></a>显示建表语句</h3><p>目的是为了获取创建表时候的相关信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure>
<h3 id="显示数据库的所有表"><a href="#显示数据库的所有表" class="headerlink" title="显示数据库的所有表"></a>显示数据库的所有表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">in</span> db_name</span><br></pre></td></tr></table></figure>
<h3 id="insert-用法问题"><a href="#insert-用法问题" class="headerlink" title="insert 用法问题"></a>insert 用法问题</h3><p>insert into 和 insert overwrite 只能用一种字段</p>
<p>其中 Insert into 是<strong>增量加入</strong>，新加入的数据会append 到表的后边</p>
<p>Insert overwrite 是表示<strong>覆盖</strong>，新加入的数据直接覆盖原数据表</p>
<h3 id="Drop-删除表-or-清空表"><a href="#Drop-删除表-or-清空表" class="headerlink" title="Drop 删除表 or 清空表"></a>Drop 删除表 or 清空表</h3><p>Drop 表示删除表，结构+数据都删除</p>
<p>truncate 表示清空表，会保留表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name </span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> table_name</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>
<h3 id="row-number的使用"><a href="#row-number的使用" class="headerlink" title="row_number的使用"></a>row_number的使用</h3><p>row_number()    是用来给 行进行编号的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *,row_number() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">rank</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>
<p>相当于查询原有表的基础上，再添加一列记录行号，这个行号如何统计呢？</p>
<p>就看<code>over</code>内的含义，按照partition by的字段(id)进行分组，然后按照<code>score</code>的大小进行排序，然后进行编号，并将编好的序号作为<code>rank</code>列进行返回，这个列的别名是可以修改的。</p>
<p>举个例子：</p>
<blockquote>
<p>Id, score,xxx</p>
<p>A1 , 10, xxx</p>
<p>A2 ,11,xxx</p>
<p>A1 ,9,xxx</p>
<p>A3 ,0,xxx</p>
<p>A2, 10,xxx</p>
</blockquote>
<p>操作之后的效果为</p>
<blockquote>
<p>Id, score,xxx,rank</p>
<p>A1 , 9, xxx,1</p>
<p>A1 ,10,xxx,2</p>
<p>A2 ,10,xxx,1</p>
<p>A2, 11,xxx,2</p>
<p>A3 ,0,xxx,1</p>
</blockquote>
<h3 id="CTAS：create-table-as-select"><a href="#CTAS：create-table-as-select" class="headerlink" title="CTAS：create table as select"></a>CTAS：create table as select</h3><p>重点操作，可以将select的结果存储到新建的表中。CTAS的操作是<strong>原子性</strong>的，也就是意味着这个新建的表直到所有的填充操作都做完之前是看不到的。</p>
<p><strong>注意</strong>：不能create external 表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- 基本操作</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name </span><br><span class="line">	<span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span></span><br><span class="line">	<span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\t'</span></span><br><span class="line">	<span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line">	<span class="keyword">store</span> <span class="keyword">as</span> textfile</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name ....</span><br></pre></td></tr></table></figure>
<h3 id="Group-by"><a href="#Group-by" class="headerlink" title="Group by"></a>Group by</h3><p>这个操作也很坑，select部分只能有 group by的字段以及，groupby字段的聚合函数</p>
<p>即hive中限制了 出现在select后边的列必须是出现在group by 后面的，即select列必须是作为分组依据的列。</p>
<p>下面这样的就会报错</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure>
<h3 id="列反向选择"><a href="#列反向选择" class="headerlink" title="列反向选择"></a>列反向选择</h3><p>如果我们的场景是：想选择除了某列外的其他所有列，原来的写法就只能把所有需要的列都一一列出来。</p>
<p>hive 提供了正则查询的方法，只需要把不需要查找的列排除在外就可以了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">`(name|dt)?+.+`</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>
<p>上述方法就是select了排除了 <code>name</code>,<code>dt</code>两列的其他所有列</p>
<p>这里有个问题需要注意， 上边使用的 是``符号，不是单引号，所以需要设定</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.support.quoted.identifiers=<span class="keyword">None</span>;</span><br><span class="line"><span class="keyword">select</span> ....</span><br></pre></td></tr></table></figure>
<h3 id="hive-分区表的问题"><a href="#hive-分区表的问题" class="headerlink" title="hive 分区表的问题"></a>hive 分区表的问题</h3><p>创建分区表的时候需要指定 <code>PARTITIONED BY (dt string)</code>相当于也定义了一列，这一列用来做分区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> table_name</span><br><span class="line">( <span class="keyword">query</span> <span class="keyword">string</span>,</span><br><span class="line"> 	<span class="keyword">id</span>		<span class="keyword">string</span>,</span><br><span class="line"> 	pvid 	<span class="keyword">string</span>,</span><br><span class="line"> 	logid <span class="keyword">string</span>,</span><br><span class="line">  wid	  <span class="built_in">bigint</span>,</span><br><span class="line">  pos   <span class="built_in">int</span>,</span><br><span class="line">  extras <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;,</span><br><span class="line"> 	label <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (dt <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">format</span> <span class="keyword">delimited</span></span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="string">'\n'</span></span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile</span><br><span class="line">location <span class="string">'app_path'</span></span><br></pre></td></tr></table></figure>
<p>同样在使用分区表的时候，插入会有同样的问题</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">table</span> table_name <span class="keyword">partition</span> (dt=<span class="string">'2019-12-08'</span>)</span><br><span class="line"><span class="keyword">select</span> *(除了dt以外的列) <span class="keyword">from</span> table_name2</span><br></pre></td></tr></table></figure>
<h3 id="Order-by排序"><a href="#Order-by排序" class="headerlink" title="Order by排序"></a>Order by排序</h3><p>标准用法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> col1,col2...  [<span class="keyword">asc</span>|<span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>
<p>相关问题：</p>
<ul>
<li>order by 为全局排序</li>
<li>order by 需要reducer操作，且只有一个reducer不能配置，因为多个reducer无法完成全局排序</li>
</ul>
<h3 id="collect-list-和-collect-set用法"><a href="#collect-list-和-collect-set用法" class="headerlink" title="collect_list 和 collect_set用法"></a>collect_list 和 collect_set用法</h3><p>都是将分组中的某列转为一个数组返回，不同的是，collect_list不去重，collect_set去重</p>
<p>按照group by的id方式聚合，然后对col列进行collect_list</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> collect_list(<span class="keyword">col</span>) <span class="keyword">from</span> table_name <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure>
<p>距离</p>
<h3 id="开启动态分区调整"><a href="#开启动态分区调整" class="headerlink" title="开启动态分区调整"></a>开启动态分区调整</h3><h3 id="array使用"><a href="#array使用" class="headerlink" title="array使用"></a>array使用</h3><p>业务场景需要将几列数据统一到一列作为特征。array可以直接使用，定义特征即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	<span class="keyword">id</span>,</span><br><span class="line">	collect_list(<span class="built_in">array</span>(gender,age,ect)) <span class="keyword">as</span> profile,</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">from</span> table_name</span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure>
<h3 id="case-when用法"><a href="#case-when用法" class="headerlink" title="case when用法"></a>case when用法</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">case when id &gt; 10 then 1 else 0 end</span><br></pre></td></tr></table></figure>
<p>上述实现的功能就是 将id大于10的变为1，否则变为0，主要写法，一定要记得<code>end</code></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>二分搜索真的那么简单吗？</title>
    <url>/2019/12/17/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>二分搜索可以认为是一种最简单，最常用的一种算法，这种搜索方法的前提是，数组<strong>有序</strong>。</p>
<p>有序并不是绝对意义上的有序，比如Leetcode中的搜索旋转数组，其基本思想也是通过二分来实现的，而那道题给的数组就是在有序的基础上进行了一次旋转</p>
<p>虽然整体的结构非常简单，但是其中很多细节问题，针对不同的场景就会需要不同的处理。而这些也是我们最头疼的，比如说，循环终止条件到底写<code>left&lt;right</code>还是<code>left&lt;=right</code>，缩小搜索范围的时候到底写<code>left=mid+1</code>还是写<code>left=mid</code>…等等问题</p>
<h3 id="基本二分搜索"><a href="#基本二分搜索" class="headerlink" title="基本二分搜索"></a>基本二分搜索</h3><p>基本的二分法是有框架的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">  	<span class="comment"># 初始化</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">      	mid = left + (right-left)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">          	<span class="comment"># 中间值 == target</span></span><br><span class="line">            <span class="keyword">return</span>  mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">          	<span class="comment"># 中间值小于target</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">          	<span class="comment"># 中间值大于target</span></span><br><span class="line">          	right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>这里有一个很重要的概念<strong>搜索区域</strong></p>
<p>我们初始化 <code>left=0,right=n-1</code>， 那么对应的搜索区域也就是<code>[0,n-1],左右闭区间</code>，当我们的nums[mid]不是target时，我们需要缩减搜索区域，缩减后的区域仍然是闭区间。<code>[mid+1,right]</code> or <code>[left,mid-1]</code>仍然都是闭区间的，这样我们就可以很好的理解二分的循环退出条件是 <code>left&gt;right,即left=right+1</code>,写成区间的形式就是 <code>[right + 1, right]</code>，可见这时候搜索区间为空，因为没有数字既大于等于 right+1位置的数，还要小于right位置的数，所以这时候 while 循环终止是正确的，退出循环。</p>
<p>while(left &lt; right) 的终止条件是 left == right，即left和right相同，写成区间的形式就是 [right, right]也就是nums[right]这个数，这时候搜索区间非空，但此时 while 循环终止了。也就是说这区间 num[right] 数本身被漏掉了，没有被搜索到，如果这时候直接返回 -1 就是错误的。</p>
<h3 id="寻找最左侧的二分查找"><a href="#寻找最左侧的二分查找" class="headerlink" title="寻找最左侧的二分查找"></a>寻找最左侧的二分查找</h3><p>这个的背景就是，我给出一个数组，我要查找的数在数组中是重复的，我需要返回最左侧的数组下标。即</p>
<blockquote>
<p>nums=[1,2,3,3,3,3,4],target=3,返回下标应该是2</p>
</blockquote>
<p><strong>注：感觉自己也不能说为啥这么做，感觉刚像是这么做了，然后进行解释</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findfirst</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">if</span> left == len(nums):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p>还是<strong>搜索区域</strong>的概念，先看下我们此时的搜索区域是个什么。left=0,right = n，那么搜索区域也就是<code>[left,right)</code>左闭右开区间，所以对应的循环跳出条件也就是<code>left==right</code>时候会跳出，此时搜索区域也就是<code>[right,right)</code>确实是空的。</p>
<p>然后我们要找的是target的左边界，所以会不断收缩右边界，那么也就有了，当<code>nums[mid]==target</code>时候，没有直接返回，而是<code>right=mid</code>。</p>
<p>再看下区间收缩过程，原本的为<code>[left,right)</code>，经过mid切分后，我们的缩小过程是<code>left=mid+1 or right = mid</code>，此时切分的区域为：<code>[left,mid)区域和[mid+1,right]区域</code>这样也确保了所切分区域跟之前不会发生重叠，且不会有遗漏。</p>
<p>最最最后！这样只是有target的时候是没问题的，但是如果数组中不含target，最终返回的</p>
<h3 id="寻找最右侧的二分查找"><a href="#寻找最右侧的二分查找" class="headerlink" title="寻找最右侧的二分查找"></a>寻找最右侧的二分查找</h3>]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>一些比较好的文章</title>
    <url>/2019/12/17/%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>&lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt;<br><!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! --></p>
<p><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"></p>
<p><TITLE>一些比较好的文章——算法工程师</TITLE></p>
<p><H1>Bookmarks</H1></p>
<p><DL><p>
    <DT><H3 ADD_DATE="0" LAST_MODIFIED="0" PERSONAL_TOOLBAR_FOLDER="true">收藏栏</H3>
        <DT><H3 ADD_DATE="1529200449" LAST_MODIFIED="1576590963">微信文章</H3>
        <DL><p>
            <DT><H3 ADD_DATE="1575196586" LAST_MODIFIED="1575215324">机器学习</H3>
            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU5Mjc4MjIzOA==&mid=2247487458&idx=2&sn=0821894f0873498965da3a3a7c804b61&chksm=fe1b3913c96cb00581b3936a5b529e1b89c67b03c780cec05946d7f48797bacf3baadafc4a87&mpshare=1&&srcid=&sharer_sharetime=1574656521699&sharer_shareid=fabaad189d906f15f7285708003fb5a1&from=timeline&scene=2&subscene=1&clicktime=1574657130&enterid=1574657130#rd" target="_blank" rel="noopener" ADD_DATE="1575207302" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深入理解网红算法XGBoost​</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&mid=2650411869&idx=3&sn=07f296eea77340fe9fe9e3414d89412f&chksm=becd950789ba1c1149fa4ad4248c199d067cbcf1b7a2fae0e46fe2b2d1168a1e2523e6eb153f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207431" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文详尽系列之K-means算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&mid=2650411867&idx=3&sn=5522d62b74a3ed6fb77b0e715e55c214&chksm=becd950189ba1c17509a8467ef24e7942f6ce1a9ee0f70e0c3e9bddbcc04e69d31015a23532e&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207445" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文详尽系列之EM算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247487550&idx=1&sn=2626998e443eb5c9052abc13fd3b8c7e&chksm=e870c173df0748654e149794d37e578fb7faa2e2ef9e9fc6528ea10c17d76d90083a44d48059&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207456" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文详尽系列之CatBoost</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247487494&idx=1&sn=01cc822880d5ded2a3685bf88d9fe25a&chksm=e870c14bdf07485ded9589fc0f0533e4bb0cc66cb0ed849a51a3c78df7439be6acfb6397216d&mpshare=1&scene=1&srcid=&sharer_sharetime=1574079741216&sharer_shareid=8724c7983f20914ec3c0c086bba89335#rd" target="_blank" rel="noopener" ADD_DATE="1575208599" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文详尽系列之逻辑回归</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU3OTQzNTU2OA==&mid=2247485640&idx=1&sn=e3582b64096c9a221db4ab0f4f630810&chksm=fd676597ca10ec8198aff93e776979b329d8745d863b49f440ed1466c6398cf875bdd916b8e8&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212311" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">30分钟学会LightGBM</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485568&idx=1&sn=af15a42e91f2d19bf3909a9ae3e8a9bf&chksm=e9d01841dea79157be56b13da422ca17ce702a1673a93928f8dc8d76ab5b1555ae18d938157d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212348" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">终于有人把XGBoost 和 LightGBM 讲明白了，项目中最主流的集成算法！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486130&idx=3&sn=877e4c3ae03cd08a1c08c51181b330ba&chksm=9704810ea073081818fe2de3dae5bbc1010a0eec0dec4b04252a71ae2ee81083c9217c9c7a92&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212360" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最常用的决策树算法（一）：ID3、C4.5、CART</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486130&idx=4&sn=d24c394dd54f0b6c031b777f2909313a&chksm=9704810ea0730818a3a1d21c3f389440eb1e47050520475afda1dc888b8d5039aa2e83bea6d2&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212379" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最常用的决策树算法（二）Random Forest、Adaboost、GBDT 算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486130&idx=5&sn=cc0665891f36544479b7884d098412b5&chksm=9704810ea07308180c56ea3b55481abcd99d270211ea5bc2e4566fa6be8b71a7541931a01f20&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212387" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最常用的决策树算法（三）：XGBoost 和 LightGBM</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486989&idx=2&sn=f582435c65a20e5c5c0978a68bc38a28&chksm=e870df40df0756563fa00bf776852bd2d635493a25a077a7e031c759639bbdd6cf6d6ae1f91b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212736" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">极端类别不平衡数据下的分类问题研究综述，终于有人讲全了！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247487642&idx=1&sn=fc54fe96e68791a9ef33626c4f12e518&chksm=fb39b591cc4e3c872a7e2abb77ffaaab831318f12e8146cdaddb820364a8cc5cd0b9f925bb29&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212756" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">干货 | 对数线性模型之 Logistic 回归、SoftMax 回归和最大熵模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486796&idx=1&sn=08add8f76894f4f39fa95d78876254fb&chksm=e870dc01df075517152e13d86312fcc25ed874669f3cddd6bded97eb1b4783114a792a90ee7f&mpshare=1&scene=1&srcid=&sharer_sharetime=1572786925811&sharer_shareid=8724c7983f20914ec3c0c086bba89335#rd" target="_blank" rel="noopener" ADD_DATE="1575212791" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最常见核心的决策树算法—ID3、C4.5、CART（非常详细）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485541&idx=1&sn=b914a4ba2250597a4bc48f45401b0c45&chksm=e9d018a4dea791b20ce2a6752a2f4bb2ce222713d7cade58a40974a3ddd78e78adc53a73ff86&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212814" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习中的 7 大损失函数实战总结（附Python演练）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU3OTQzNTU2OA==&mid=2247485589&idx=1&sn=1690aee572191e1af0364fcb0f71c07c&chksm=fd6765caca10ecdc15dd1c609c89c4f0e09d4a6d47ce7c074f9ec77506e1ce8163eea53a1208&mpshare=1&scene=1&srcid=&sharer_sharetime=1572176345349&sharer_shareid=808295d573831eb57288f1fc0ad3ac69#rd" target="_blank" rel="noopener" ADD_DATE="1575213372" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">20分钟学会DBSCAN聚类算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAxMDk0OTMwOA==&mid=2247483716&idx=2&sn=3526f0e5034d692aeddcafba12b43948&chksm=9b49c697ac3e4f817c96f47cac20c4c90f9426957c930bdfc84d50e391f8652585f2a4ea013c&mpshare=1&scene=1&srcid=&sharer_sharetime=1572149544623&sharer_shareid=7d8f204d5d176257ab84cbc58463d2f6#rd" target="_blank" rel="noopener" ADD_DATE="1575213384" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习算法之LR</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610691&idx=1&sn=cb086414137170b210a1374c9dcb323c&chksm=f1296aa4c65ee3b2ecc25b91e338370f51ce5a702d7d25f423e84c49737d9b03b70c7e669881&mpshare=1&scene=24&srcid=&sharer_sharetime=1572059307308&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213533" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐收藏 | 决策树、随机森林、bagging、boosting、Adaboost、GBDT、XGBoost总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485444&idx=2&sn=b84999e79ea8dbdb6a5b55a317cbecaa&chksm=e9d018c5dea791d39d73b2fec353fe9ba86bb9b6e02e5ae1bce9504d9695b0a22096f7d068d7&mpshare=1&scene=24&srcid=&sharer_sharetime=1571654574645&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213791" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">详解机器学习中的熵、条件熵、相对熵、交叉熵</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494362&idx=1&sn=46e73b1bff8beb40afba33fb12b4dce5&chksm=fbd758b6cca0d1a0ca1b2d0a2c115c5b891624975bdd16137706eb4aafdc550ac9a20809613b&mpshare=1&scene=24&srcid=1012P2mw5CsbzaW8tDPIK9LY&sharer_sharetime=1570842866673&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214199" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习评估指标 AUC 综述</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU5MjEwMTE2OQ==&mid=2247488888&idx=3&sn=44002e20e73961bc0038be44d6a63f83&chksm=fe25bf26c9523630067fd43a349699dd20ff8e73a5d65848d7577344abfb1bfb844ce5936950&mpshare=1&scene=24&srcid=&sharer_sharetime=1570353016861&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214371" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">不足20行Python代码，高效实现K-means均值聚类算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486257&idx=1&sn=6f04234257b6b08ae9b9b4752f6178b1&chksm=e870da7cdf07536a484a225e50c525ce33f89f37380857d2c0cad6bd1404229c4bda9fbefd67&mpshare=1&scene=1&srcid=&sharer_sharetime=1570014608667&sharer_shareid=8724c7983f20914ec3c0c086bba89335#rd" target="_blank" rel="noopener" ADD_DATE="1575214544" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习领域必知必会的12种概率分布（附Python代码实现）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247508566&idx=2&sn=0844ce062822be67386d35e9e95a8e02&chksm=e99e91afdee918b951ba380de7dffa5af051c272b801f2c2cab41c115324e94550e4f940063b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214563" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">学点基本功：机器学习常用损失函数小结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247490380&idx=2&sn=31031b66fe7df26dfb31ea7c04b06a9c&chksm=eb7c3687dc0bbf9107db656191b716d66bdc5e7d7a806d74d084a7df24b324098a9264babdc4&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214713" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">先验分布与后验分布，认真看看这篇</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486101&idx=1&sn=53d7d6b37f2c90a288d6b365af33761e&chksm=e870dbd8df0752ce7fe83cef50f7541bda1ae888e2256776654f36c81dd1524316cb62d81dc0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214733" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">XGBoost超详细推导，终于有人讲明白了！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247490204&idx=1&sn=5a7e3d307639db60f7174530d09e922e&chksm=eb7c3757dc0bbe41a088a02ab1736d941449a3aa4ae82583a90fb6b070cef6034e9c81564b1d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214936" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">模型评估指标AUC和ROC，这是我看到的最透彻的讲解</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750545&idx=1&sn=6ee9a126932a20460d963261515a75c0&chksm=bd1259dc8a65d0ca843b9862020a121a595ab9547353cff217ddc46da933ec0633b34229189c&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215154" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">XGBoost缺失值引发的问题及其深度分析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247486980&idx=1&sn=413db8b20d19ef22bfbce05ecd0e0ece&chksm=fb39ab0fcc4e22198067163a173a6c49275e747559711bb823fae3c8f945dcf2147df23da427&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener" ADD_DATE="1575215324" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">DBSCAN聚类算法原理总结</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196593" LAST_MODIFIED="1575868321">深度学习</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484166&idx=1&sn=52017f26cf6ab9e10cd4deb66ac815f1&chksm=fc92b9b0cbe530a65829b6c2d84fb4d701e210c045d625d18ecc5ac36824e683810f485bc2a8&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208575" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">残差网络解决了什么，为什么有效？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247487710&idx=2&sn=7760bde74bc02a6203a07bc750c98345&chksm=fb39b5d5cc4e3cc3e42063c90942daf8faaf1c688f4eed3a5b227f48348f3feac6f7a7b7945f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575210080" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">三层神经网络</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247487139&idx=1&sn=256eb21930ff9c331551f945eee9d5ef&chksm=e870dfeedf0756f89c6f633ec54c82adff8df0ec23b75017553b7758253463a7ebdaa3567808&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575210139" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">矩阵求导了</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485487&idx=1&sn=1e5e79062218b1748b05a7a0235df7da&chksm=e9d018eedea791f85dafeedc4989ba37b4bf3ca2ef12bba1d4b6a674b9d5fcd140d3aea251f7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213443" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">详细解读LSTM与GRU单元的各个公式和区别</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610653&idx=1&sn=e8d57af2b44d4f7b12581b136a4b8ef4&chksm=f1296afac65ee3ecff858596e283e0f121b11206a0be47a333458c2f2b587ac9b89793b21ba6&mpshare=1&scene=24&srcid=&sharer_sharetime=1572059339433&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213516" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐收藏 | Dropout、梯度消失/爆炸、Adam优化算法，神经网络优化算法看这一篇就够了</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484021&idx=1&sn=3d5738889aefa9e5969112a1917458e4&chksm=fc92b8c3cbe531d522e4514f8e9b8ee0b0fd6fa4d1d24758445af1dd898a4aace844c0ecd0a0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213600" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">走马观花Google TF-Ranking的源代码</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU4NTY4Mzg1Mw==&mid=2247485885&idx=1&sn=9371ab42ae8f8383e390ee7281feff90&chksm=fd878f5fcaf006491642eb4480a551e0aee4feecade6773ae4940087a686fd062cb7e56c7a94&mpshare=1&scene=1&srcid=&sharer_sharetime=1571841604558&sharer_shareid=ea858e8c591aa98c750152f703babf33#rd" target="_blank" rel="noopener" ADD_DATE="1575213622" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深入剖析深度学习中Batch Size大小对训练过程的影响</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3OTAyMjcyMw==&mid=2247484686&idx=1&sn=d40a7ea6fe88ebdcf95e429ff22ccc8d&chksm=cf0b82e2f87c0bf49b83818fc9b1e15f6ccc84b69f19c9098abc7677135f8fc50c2d5bf40857&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213893" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【DL】一文读懂深度学习中的Normalization模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486527&idx=1&sn=712ba2518092c53ba4d3db3dfdfd477d&chksm=e870dd72df075464acc72b6b8fee0823c60500754a5819f8c856ccbcb1e00a66d3ae7266f6a8&mpshare=1&scene=1&srcid=&sharer_sharetime=1571277975785&sharer_shareid=8724c7983f20914ec3c0c086bba89335#rd" target="_blank" rel="noopener" ADD_DATE="1575213901" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">如何通俗易懂地解释卷积？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487474&idx=2&sn=d46c6c70345a894564c917d727bedb38&chksm=eb501b61dc279277e9f42083f1d2723b7e5e7614307231356298e2bcebb462458535af147fea&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213924" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Multi-task Learning(Review)多任务学习概述</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&mid=2247500269&idx=1&sn=067b36f177fa97124691aacec3ffca3e&chksm=96ea1e6da19d977b88de33f3e8efe21d1660076b45d9aa32dcf0b60b66d4cf2fb998054f09cd&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214133" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">BN究竟起了什么作用？一个闭门造车的分析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247508784&idx=5&sn=b8f5466969507c44739362ac3133e907&chksm=e99e90c9dee919df986b51d236544443557f09bfee7c76c3d5ce6e7b870f301a8065e8df5e4a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214217" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">TensorFlow中的计算图</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494208&idx=1&sn=50a940f4ce6093cd6c75f84e6c8efd59&chksm=fbd7582ccca0d13a270878d4aeeda8de15cc4be694b86185a95a74fee4aa9ae90efe87fe1bad&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214680" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度度量学习中的损失函数</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247486989&idx=2&sn=29ccf3cebfb860e0286936e50f519f02&chksm=eb501a9edc279388b75babd25b68687883ba998d5470c6db745a11a1268c9d2efcf8e51523d0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215162" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">BN、LN、IN、GN、SN归一化</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTU3Njg4Mw==&mid=2247484505&idx=1&sn=ba3bd929b0531e6195cbfd198d5030a4&chksm=fbd37f05cca4f613a936c30c4baf76dbb949bbe153f3f5f5420035c1394fbab18b3de2dc773a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215219" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Tensorflow常用函数使用说明及实例简记</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247487087&idx=1&sn=52dbf276829ff5215b4005919fe8124c&chksm=fb39ab64cc4e2272e3842afaeea927a93df00e345be76d96981440c94d196ab9679593707515&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener" ADD_DATE="1575215255" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文彻底搞懂BP算法：原理推导+数据演示+项目实战（上篇）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247487859&idx=1&sn=44a5eb7c14d5b8d5a45d4727b14d09f5&chksm=fb39b478cc4e3d6eefc5a9493b94833c2518878230da56ee306b85714a631c150b755a51cda0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868321" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【CNN】很详细的讲解什么以及为什么是卷积（Convolution）！</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196597" LAST_MODIFIED="1575550735">面试</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487709&idx=2&sn=b0a0e580f8e9f25c015aad9f7a714973&chksm=eb50044edc278d58134dacb2accc3182d4fcede07bd5fb90b5b0ea8c0c9439b68c64d73d8dac&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196777" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【面试题】机器学习与深度学习常见面试题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487575&idx=1&sn=b2c0c2b5986eff0a6ed67c7ee0a0498f&chksm=eb5004c4dc278dd29da3ef87c3098e97350b1e0e49520aa993014d3741c48d2ff71c9acab3f9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212430" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【干货】22道机器学习常见面试题目</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485557&idx=1&sn=94c064d486795dff139828dab350070c&chksm=e9d018b4dea791a297dee2cb6b7dd8375f4d8cdafdb4af734a74850fe0cd311db1508349b885&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212509" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">面经分享|中科院老哥的算法&amp;开发岗面经总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485536&idx=1&sn=5c5e62585a73273bf4adb5f61bb42de1&chksm=e9d018a1dea791b76a811ed4a5734634cce44d7763eeec9b734448045bd68001618e83ba9233&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212835" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">决策树算法十问及经典面试问题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzUzNjcyODU5MQ==&mid=2247483979&idx=1&sn=78c62345c189f3b6fe59cccffc190473&chksm=faf0872bcd870e3debdf522cf8be9cd17b7aa365b03bc9d3177e35f8a2129e2771185d305398&mpshare=1&scene=24&srcid=&sharer_sharetime=1572276675082&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575212951" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">SVM---这可能是最直白的推导了</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610332&idx=1&sn=5a90a97db4670ba2dbced9286474d964&chksm=f1296b3bc65ee22df8ae8027305bf35cc9be86098f16ec84be5279f65ddb31a5de5185594fa6&mpshare=1&scene=24&srcid=&sharer_sharetime=1572059430619&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213508" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">MLK | 机器学习常见算法优缺点了解一下</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485481&idx=2&sn=26c13008a1a88534e847f02af7a2f454&chksm=e9d018e8dea791fea8277a4726520549cbd5be2ca8b0be3c1fe2f688845334c0e89a7508107f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213592" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">六道腾讯、百度、美团常爱问的面试智力题和答案</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484315&idx=2&sn=3c901e2ef8b8714572a7d1b317641cfe&chksm=ce921de7f9e594f1720fe4b76d1aa9fc2512f544ead42b79ee0da319288d93749fe16a0f77f0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213744" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">超详细SVM（支持向量机）知识点，面试官会问的都在这了。。。</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485444&idx=1&sn=71b8b810f0188b5827bef43c882928e0&chksm=e9d018c5dea791d38a7a64767543594e0c2dc0d5190f32ef9f36f53b72c6182e1df351a87f24&mpshare=1&scene=24&srcid=&sharer_sharetime=1571654588338&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213757" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习与深度学习核心知识点总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIxNDgzNDg3NQ==&mid=2247486416&idx=1&sn=b8839a7df04816a6d90cdec600e25d39&chksm=97a0c004a0d74912f3909a9abffc8f614e491e02598a0888348b0a2361b900e1af304eafed89&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214148" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">互联网技术面试最后反问面试官思路及问题整理分享</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484276&idx=1&sn=ece3498bc8570bb063851767d0dac9ed&chksm=ce921d08f9e5941ec2c86ec3ab1c747dbef62478deba4480045a85ae5f80dcd5080a06caeb7f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214192" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">面试中问你 Batch Size大小对训练过程的影响</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486295&idx=2&sn=4321b94213cf559ab9f0c549c92eb3a0&chksm=e870da1adf07530ca9d226f31b9a11c962e7b157c7e11e9f5de4285d70b61c678af6db421c7e&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214386" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">算法工程师常见面试问题及相关资料汇总（附简历模板）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484237&idx=1&sn=013e2bf9499a160bd8f892c024461a7f&chksm=ce921d31f9e594272637f77386315a3b52f85b46177f6a5afc57c0a4e3858e1918242bc1e6d1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214755" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一道有悖直觉的概率题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485159&idx=1&sn=d429aac8370ca5127e1e786995d4e8ec&chksm=e9d01626dea79f30043ab80652c4a859760c1ebc0d602e58e13490bf525ad7608a9610495b3d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215082" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">珍藏版 | 20道XGBoost面试题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485018&idx=1&sn=c803466f48ba64919495f9a7d89473fb&chksm=e9d0169bdea79f8dc97b35b5892d176b0fb51de5554aaf08eba920a45e782355dea8b81bbfd0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215171" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">带答案分享-算法面试中的趣味题目</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247484667&idx=1&sn=1e3d7a7e40acf15259c12c48ce638a5b&chksm=e9d0143adea79d2cb747e253767d9646484ec74569f175ed1e5123373093120a69fe959419cd&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215288" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">带答案面经分享-L1正则&amp;L2正则</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247484647&idx=1&sn=5ee98e0d264dcc0430b8f5d9dc092975&chksm=e9d01426dea79d30a498fa36f851bce50ff46e5c85b4def39246cfbd58b21b33bf46a1fdecfd&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215295" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">带答案面经分享-面试中最常考的树模型！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU3NTgyODQ1Nw==&mid=2247486084&idx=1&sn=fcfbba75e5a3190d7b4551849cb91c73&chksm=fd1c7202ca6bfb14d419b350cbb8b01aa67ed4e3f608e421653edf1ddc64e33b4630e5927652&token=1719948296&lang=zh_CN#rd" target="_blank" rel="noopener" ADD_DATE="1575215302" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">必会的 24 道 Shell 脚本面试题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247484473&idx=2&sn=99c63abe7593924eda5537da4be4d2c6&chksm=e9d014f8dea79dee7061a9013a6de10b89d889c89129e530aaec81f614a4b2953bd66c9bfde2&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215338" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">头条广告算法面经！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247484266&idx=1&sn=b00a44332ae66a8ffd1b3a4eb387e386&chksm=e870d227df075b316a81ce8f2e2f53303247596d8d4b148263013425ce34caeb192aace84f34&mpshare=1&scene=2&srcid=0406h1C5FHq4btQnJ4f5gnFa&from=timeline#rd" target="_blank" rel="noopener" ADD_DATE="1575215369" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">决策树，逻辑回归，PCA-算法面经</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486926&idx=2&sn=48bb3547b4cebe17dc2bc06e686b9073&chksm=97048672a0730f64867ccd32d6d5d425e6cc75dc638ac2f640e128dac29bbfedf1c2ce16d325&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575550735" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AI基础：图解Transformer</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196612" LAST_MODIFIED="1575868395">推荐</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483809&idx=1&sn=e0c98e0e5e672b7401b27733f3385389&chksm=9b7c9848ac0b115ef7c71d145946c961607a2af9828f4836c1fab3421b37897c7502d2baf41a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208724" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">用户画像必会的行为偏好计算方法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495039&idx=1&sn=35905df6cd4ef33d2ce505d284d3c8ad&chksm=fbd75f13cca0d605c17bf7a8b3b899b7798a590008625fcffbf00d77c2451249bbdc086d6b18&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212747" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统中模型训练及使用流程的标准化</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484100&idx=1&sn=0d64e42e1ca702e3266e2853ab224687&chksm=fc92b872cbe53164448ff5b56a3e7d0c1265ba2f47dab481b505a81d697834607e29f7e528db&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212913" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Contextual Bandit算法在推荐系统中的实现及应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485422&idx=2&sn=cc938ca96dae791e252eaa47300276c1&chksm=e9d0172fdea79e39a5bbbe94f00560335af10a61d7c1718c6fb53432a33ec140942e88a2a407&mpshare=1&scene=24&srcid=&sharer_sharetime=1571212582482&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213961" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统数据集大列表</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485303&idx=1&sn=9116b1708be7a3d83f2d30a926dfdeb5&chksm=e9d017b6dea79ea099fbcd1743ea0f06e14851c7dc8e842703ad048b4df6fb25cf41b8af1382&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214670" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">RS Meet DL(65)-负采样点击率修正的那些事</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU3Njc2ODczNw==&mid=2247483816&idx=1&sn=c635327405456447bfe9508b53e324d3&chksm=fd0f9e26ca7817308612a7de78a987658ab5f54ab4d60fe70b0877bf77da1e3793bc27edb0f9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214725" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">透着浓浓工业风的Facebook深度学习推荐系统论文</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485950&idx=1&sn=907f9c059ee6546f6316b7d898e13692&chksm=fb5730e4cc20b9f27f0f21226774390d1f0823b48c8de303f5dd75a30ce405a09cfa72b6d5f7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214800" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统应该如何保障推荐的多样性？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485677&idx=1&sn=1b369da4c7a7f69cba3f6716b78fea50&chksm=fb5731f7cc20b8e1a0d0e2aae4fbbd03ea6560a55a2d0766086ea31ada4199a85fbd6e4f1ed7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215048" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Exact-k：组合推荐的秘密</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485723&idx=1&sn=91074cb7c7366a29353d57e6ed59e26c&chksm=fb573001cc20b91721fc715585e8269b9f27fdd27d063080ac1d0f365e5f52e39e85b6d94a3a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215061" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐算法之E&amp;E</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485737&idx=1&sn=42597b00b6db51b1e4dd8bb75cf646eb&chksm=e9d019e8dea790fe4558866a7522af34370c305922b3047c89fe90435474104e16a66d2a902b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868292" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐算法三视角</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484199&idx=1&sn=3c2d3f9aa389d4bc30192d429599822c&chksm=fc92b991cbe53087539a2f19fddf02edefe089396136d25b4684039724794bf5f217529f9dd1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868307" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">微信算法工程师带你一文了解「推荐系统」 领域的最新进展</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196617" LAST_MODIFIED="1575868280">NLP</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487713&idx=2&sn=f2a5bd681f8377b8e6fc53960d0612ae&chksm=eb500472dc278d64dd7adae709f3337a1903614a343c3564b0ea361d81d68287b024f85647de&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196754" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【干货】长文详解Attention的前世今生</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247487554&idx=1&sn=ddb75eab39c2aae578e812792974e759&chksm=e870c10fdf0748190ca29c4b80dfd10c72211527cd0784a909a68810bd158458d6ea36e0dbee&mpshare=1&scene=24&srcid=&sharer_sharetime=1574645218342&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575207317" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">All Attention You Need</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487657&idx=2&sn=b58e4343b41dd8c1f70d5ac009a89172&chksm=eb50043adc278d2cd3bf61d27205d2e4125a19a11ee42a52dee30795cc20ca933ac623021d54&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208623" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【NLP】浅谈 Transformer-based 模型中的位置表示</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&mid=2247500808&idx=1&sn=57141f4690836d60ef8ed58497bb6619&chksm=96ea1b88a19d929e4c468aebebc0dfa657e6f200ed96ef0107c81ad0540c936bcddb92811c85&mpshare=1&scene=24&srcid=&sharer_sharetime=1573467011879&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575212301" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">从三大顶会论文看百变Self-Attention</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483689&idx=1&sn=479c022f717892aeba183c16a7d13220&chksm=9b7c98c0ac0b11d6c17180ae539e63ab925831b47822b1154c471f2e57f551d8b55e4776bbf3&mpshare=1&scene=24&srcid=&sharer_sharetime=1573017209241&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575212496" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">绝对干货！NLP预训练模型：从transformer到albert</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&mid=2650411752&idx=3&sn=dc7f5cdd72da5df431c8427126f47baf&chksm=becd94b289ba1da4535ebbc168d088435eabb0c57854b6c32386f46558481562f7624d4a9ed4&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212826" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">word2Vec总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3OTAyMjcyMw==&mid=2247485068&idx=1&sn=0d0ea8d0b66cd4b553a47924e2abde3c&chksm=cf0b8160f87c0876a092e409feadaa42438f3ca55618f9f866de4de7f26a7a814f8a1314ea95&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212934" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【NLP实战】快速掌握常用的向量空间模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486615&idx=1&sn=0dfd0d28f5c23d9bf1a3e771db555026&chksm=e870dddadf0754cc044f60c685606b2c26b1112cf6662fbe4be9aef98cad683c499e2bec23ad&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213423" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【NLP】 深入浅出解析BERT原理及其表征的内容</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247490559&idx=1&sn=3648f0e755ae95cea0cebe69a16e9e19&chksm=eb7c3634dc0bbf229f95eb6372765038b1ad30de5762d4e7c1daa15f94b2f75e0a781466fa88&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214379" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">文本数据的特征提取都有哪些方法？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTU3Njg4Mw==&mid=2247484595&idx=1&sn=7e88477786bb7f96413aef4054d61d20&chksm=fbd37fefcca4f6f96f17ccfad2e5681b05c8062d4939bddd6662a19b1d20f956ad63f7af5fc1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215210" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">论文阅读 | ELMO详述</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247486779&idx=3&sn=b10aa65e9c91a2e4c23916147accb86f&chksm=eb5019a8dc2790befced65c554ed315602d6f40432425d52f7eabe26072be80ec617d028dea9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215269" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">从One-hot, Word embedding到Transformer，一步步教你理解Bert</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486914&idx=2&sn=4c7f590f7f5e3bf888c89086fac57a07&chksm=9704867ea0730f68d3efb48dc8893829cf9a877abbebaea95d22cae8d5a15d6029d5fc7e78d7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575424348" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AI基础：词嵌入基础和Word2vec</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485721&idx=2&sn=6665df59312644ed446b67d2aea0646b&chksm=e9d019d8dea790ce8a9f5d4fef8dfaf01dee86460193668c1a8c099b98058125272102d81f77&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575550761" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">特征工程|空间特征构造以及文本特征构造</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486959&idx=2&sn=030848835e4666ccc48f88815d80c31f&chksm=97048653a0730f4509dec65b08390c0bb757dde8439cfd7451b6e5368ec812ee2e0a18412845&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868280" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AI基础：一文看懂BERT</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196622" LAST_MODIFIED="1575214266">C++</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484681&idx=2&sn=6b78f50bfd040df0f8e18a00248d8c96&chksm=9f2a9d51a85d144702a30e1a1893c5c4a2f69042a5cddecdfe63628a76c53f3922d5f3077603&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196764" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">C++与C中的const关键字有何差别？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484645&idx=1&sn=0d206643984806af496863a92f597741&chksm=9f2a9cbda85d15ab36dabc022e2d79ab0ca335ac725171b434d2c011c8f9b9539a4b78176bf3&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208634" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">图说C++对象模型：对象内存布局详解</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484639&idx=1&sn=8281dc3b0175457af79662d5800df22c&chksm=9f2a9c87a85d15915d925900edb382d42c018eff0a2000e70b367a118474c749b3c222d227f6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575210124" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">函数，从编辑到编译</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484625&idx=1&sn=4c8a87c7a2176fb49d56e60b21639da6&chksm=9f2a9c89a85d159f637de77e867979a8c5e04d393f15864c38e5fb3e359e5d4156dfbf0d4173&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212523" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">C++ 异常机制分析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484573&idx=2&sn=41a7725d0364ac2a6a929ac7f8e93cc8&chksm=9f2a9cc5a85d15d3fd5eb1a46caed32f78588bf028a07386ffd8fcbf57e4f64b60b5beede311&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213810" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">细说new与malloc的10点区别</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484558&idx=1&sn=660f62f7a3ce4780f40d7f140505ba4d&chksm=9f2a9cd6a85d15c0d5a6a4d771825bcd04bb5e10907c20366678c88fb8ef9143f7a3df254838&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213884" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">C++ 顺序容器基础知识总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484517&idx=1&sn=f367201862e666d9e880f95045a730cb&chksm=9f2a9c3da85d152bb062a0bff2eb40fce6abaf18eb2e270c8ddda8ded4ee6950bf87fa641d9d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214258" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">C++ 工程师校招面试考点汇总</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484520&idx=1&sn=812669fc85ac58defc1b251908edd375&chksm=9f2a9c30a85d15268d84a04fc98ea30553bf6121403e80719b92f22312b605a228f2c88e20c9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214266" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">你们要的C++面试题答案来了--基础篇</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196627" LAST_MODIFIED="1575214580">Python</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247491008&idx=1&sn=b3ce39dd6bae639a5744027ce870b6a2&chksm=eb7c300bdc0bb91d333dc55adde999497dad9b27613308521f9577eab98417ac4f8d4c287bcf&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212448" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Python要点总结，我使用了100个小例子！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247490860&idx=1&sn=7e623b25d04fd157e24281191e373ded&chksm=eb7c30e7dc0bb9f13aa04f861ba97fb30d568d1d52d1581c83c0fc804296c2d26b90602106ea&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213614" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Python列表生成式12个小功能，你常用哪几个？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247508668&idx=3&sn=af77a77f93a3a2c7d27a573f0e5e7141&chksm=e99e9145dee918539e3f31e27223b5cf21777b77e3c9379910db5f24d03ea605d7eac64acdb9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214351" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">24式加速你的Python</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzMjY0MjE1MA==&mid=2247488340&idx=1&sn=572a046a414e830e209e8ea1c7cc92e0&chksm=e890905ddfe7194b2478fa00075469b83d997133290aef42d6c2af0db3aca1b46a6543823e11&mpshare=1&scene=1&srcid=1006yYgqNuFLOKxal8UIdw2q&sharer_sharetime=1570373954581&sharer_shareid=cca782c357f6c145b41a8f02429cfadb#rd" target="_blank" rel="noopener" ADD_DATE="1575214362" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">盘一盘 Python 系列特别篇 - 面向对象编程</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0OTU5OTI4MA==&mid=2247487279&idx=1&sn=ed65c8160af724c8fd321b7b590148e2&chksm=fbac2e70ccdba766e0cb9f38d3998f022e43890c62caaedf443def939ef5f7b20b15e0504fc1&mpshare=1&scene=24&srcid=0930GamV35ySHAnwY3HRb1Qo&sharer_sharetime=1569807689911&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214580" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">17个Python骚操作，你都Ok吗？</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196633" LAST_MODIFIED="1575215397">Java</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485808&idx=1&sn=1013253533d73450cef673aee13267ab&chksm=cea246bbf9d5cfad1c21316340a0ef1609a7457fea4113a1f8d69e8c91e7d9cd6285f5ee1490&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208654" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">新手也能看懂的线程池学习总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247489989&idx=1&sn=76fc6b53ac9c7e9a3bf127e6ace66c3c&chksm=e9c5e074deb26962dcb2aa82df61e93847b60b106f92fa0b38f7d8cea07d12d7eb3f8cf180a5&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214949" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">面试官：线程顺序执行,这么多答案你都答不上来？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485015&idx=1&sn=5daa243c3359b88fc88b951f9d08b273&chksm=cea2499cf9d5c08a7698559a2fc27078c6b35856bc2d3588172bf64708c115d4b35d3de80cd9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215397" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">关于Java基础你不得不会的34个问题</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196644" LAST_MODIFIED="1575868271">大数据</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485651&idx=1&sn=d6938dc815abcf589884ac4c75b5b76f&chksm=e9d01812dea79104c3744ad2b8c5807e8bbc8990ed305f23bfdfd968798cd38c52aaadbdb427&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207335" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Spark学习记录|RDD分区的那些事</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1NjM1ODEyMg==&mid=2247484594&idx=1&sn=b9544db3d5a5df068932d5196e64be44&chksm=ea26a737dd512e21ed37485317f1f04dc08e3599d27177b3308a3d5d766db8809580173eb461&mpshare=1&scene=24&srcid=1028viAPbFbuPfHckHt4hBlQ&sharer_sharetime=1572192951887&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213331" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">大数据分析工程师面试集锦6-HDFS</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1NjM1ODEyMg==&mid=2247484557&idx=1&sn=c67166866a77c4ff66079a0a68d72e9c&chksm=ea26a708dd512e1ef7181fef9e1d5ac7f20b00d96f71582c2e02c3c53251b360119de5cb0912&mpshare=1&scene=24&srcid=10284EheCZe0742FhhTEEvUS&sharer_sharetime=1572192940074&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213348" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">大数据分析工程师面试集锦5--Spark面试指南</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610686&idx=1&sn=1331f4c63e66a66496cf21b07ee8bc68&chksm=f1296ad9c65ee3cfa8612043b83d150676c5cc83df7a96ab9d74648e6a5a69ad7d097d1fd4bf&mpshare=1&scene=24&srcid=&sharer_sharetime=1572059315365&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213523" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文带你搞清楚什么是“数据倾斜”</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247484981&idx=1&sn=8c587787a049578fd483a8d4d4000553&chksm=e9d016f4dea79fe2a2757dfd004e717583bd9a592c77497c641ee762057ce29688443c0cd359&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214830" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">算法人必懂的Hive知识-四道Hive面试&amp;笔试题解析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247507755&idx=5&sn=ea10cfe7f0263b9eb87b490904b204dc&chksm=e99eecd2dee965c4767c2a253f96cd6d08724f19aeabf266a4225a560d8e55b0fef6423a3db1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215100" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">如何应对大数据分析工程师面试Spark考察，看这一篇就够了</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485921&idx=2&sn=5704ddca211870ed1ac2ca76d2441e8f&chksm=cea2462af9d5cf3ccbb346b2908e9bc05e963de329d33f1f6744d40480106cc5409e098860d1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868271" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最新 | 10 道 BAT 大厂海量数据面试题（附题解+方法总结）</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196648" LAST_MODIFIED="1576590745">比赛</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486823&idx=2&sn=0da7cadbb4113e88cc75b0d2ada47078&chksm=970486dba0730fcd4cee4b318aabfe20a87738a39009e9fb6076ee6594b64745f7bf5d41dbea&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196660" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AI基础：特征工程-类别特征</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1Nzc1NjI0Nw==&mid=2247484689&idx=1&sn=0d8d986ef83e9859a413e5092bdebcad&chksm=fc31bf29cb46363fac6e567f39babae494f183955cde92fb605643898987b43a1d1480f673ab&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196673" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">科大讯飞工程机械核心部件寿命预测挑战赛冠军分享</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610972&idx=1&sn=bc8773722eefe5d9cd4f9acd910908d9&chksm=f12969bbc65ee0addd06fb4b556f9b166a46bb80b53750bccd092ad87ffd2d0dea7425c519da&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196741" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">特征工程系列：时间特征构造以及时间序列特征构造</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610948&idx=1&sn=27499a3d0b0915b7993f042888569870&chksm=f12969a3c65ee0b58343805c2af2f018f9fd97e4f7baf9250d8dafaa0339ba54baf8bad3879c&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207276" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">MLK | 一文理清集成学习知识点(Boosting&amp;Bagging)</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1Nzc1NjI0Nw==&mid=2247483848&idx=1&sn=543ed8056ebe0ecc880e132e319eaf7d&chksm=fc31bbf0cb4632e60cca70eb65d0911e45ffc1221d457651948a473057e1571275309b6c9408&mpshare=1&&srcid=0923QF77HfU9LuXb1myrYvRD&sharer_sharetime=1569246891410&sharer_shareid=c5fe03d072516208a37563362f0311b6&from=timeline&scene=2&subscene=2&clicktime=1573048853&enterid=1573048853#rd" target="_blank" rel="noopener" ADD_DATE="1575212422" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">竞赛集成CookBook</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1Nzc1NjI0Nw==&mid=2247484561&idx=1&sn=71965b0b07c5cdb1b1a2b1166a3b0396&chksm=fc31bea9cb4637bff01c4e9fcb10b6fcc0692b527dd1e2479bbbfd825299daa5b08658a4ebda&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212964" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Kaggle竞赛宝典方案汇总</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486476&idx=2&sn=61d4a37dd7c4c5e5201e5114315ce85d&chksm=e870dd41df075457b347089cf8840353305696cd6e1c876da787a0dfe476969d6766bd1d2dd7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214181" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文简述如何使用嵌套交叉验证方法处理时序数据</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486412&idx=1&sn=170c8ae517afa3739b553bc6406b7305&chksm=e870da81df0753972a9f82d6723e71ccdd09ff02b176c49e7a474e121de5f6bad4cfac5ba3e5&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214274" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文讲解特征工程 | 经典外文PPT及中文解析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA4MTk3ODI2OA==&mid=2650342180&idx=1&sn=e82d0829e2cee371402a51d92cf9c48d&chksm=878115d7b0f69cc18971bd7514431c84a7709968a3718df7b684d6aa2ec587b8788bee2c2ac3&mpshare=1&scene=24&srcid=1001SvGXqrez5fEVzrul3ckg&sharer_sharetime=1569861140389&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214571" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">特征工程(四): 类别特征</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486041&idx=1&sn=e64c8dbefb342db326f3860792d0e424&chksm=e870db14df07520253e15bafa78bff743b367211f783bb7d6fa18c42230fa64ac26cc55326c3&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214766" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文梳理2019年腾讯广告算法大赛冠军方案</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247485783&idx=1&sn=aaf30d238581bed4c3f3dcbc325f4295&chksm=e870d81adf07510c2308b74ed7377706693077432cca5b740e297a5f0b64e6f74f5dbfbfa30b&mpshare=1&scene=1&srcid=&sharer_sharetime=1569166924229&sharer_shareid=f2c339398e3f2b64bd28d9acd013a411#rd" target="_blank" rel="noopener" ADD_DATE="1575214775" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">竞赛专题（四）特征工程-竞赛中的必杀技</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483936&idx=1&sn=8faf2b0fb67359265096c8193877c86e&chksm=9b7c9bc9ac0b12df822870807ab75f49135ee59b868cf5ae98ef36623698de03efd8f3ab58aa&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1576590745" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">风控特征—时间滑窗统计特征体系</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196688" LAST_MODIFIED="1575215388">数据结构与算法</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI2NjA3NTc4Ng==&mid=2652081686&idx=2&sn=efe3d60204bacd3f7aea33a433d7a37c&chksm=f17485f3c6030ce55847939b463f500712c6738725abb679eca14b463bbde3ed8466af6a75df&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196787" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">经典动态规划：高楼扔鸡蛋</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484377&idx=1&sn=3db94956969494f35e1c3035adaaecb3&chksm=ce921da5f9e594b3f3185c0d42cb6d7dabac3cbac02a8321bb05ba03cc4fd656c5e549086348&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196802" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">回溯算法详解</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485814&idx=2&sn=704cee4eaaec8fc98765899bdeec988e&chksm=cea246bdf9d5cfab168380240e9a20927930a905665b0d89e15207122f29ccc5afba0df37615&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208588" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">告别动态规划，连刷40道动规算法题，我总结了动规的套路</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MzMxNDY5Ng==&mid=2247485710&idx=1&sn=c8a87c05323d2053413796ae4d5cb3b7&chksm=fb0c0f69cc7b867f99a524f0dc15ecab455666284d1af5209364bb137b59461c0a06d81790eb&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208702" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">谁能想到，求最值的算法还能优化？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI2NjA3NTc4Ng==&mid=2652081592&idx=2&sn=851b2558c574b43b392ce44073e85621&chksm=f174865dc6030f4b5f17618ccdd107846e9ed18d6dc4511a5de158a6382f1d61157754d39db6&mpshare=1&scene=24&srcid=&sharer_sharetime=1572918928163&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575212607" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">图解“红黑树”原理，一看就明白！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484232&idx=1&sn=3221dd842ff10f50505bd820c1462bd6&chksm=ce921d34f9e59422efcda7fe727c318cc6bb22fe14a23e986050aa1b0e9f5531c79f73e281c6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214810" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文解决背包问题（上）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247503579&idx=5&sn=3394c2e1fc42738152f5d42e14365933&chksm=e99efd22dee97434c1f7693be116581d5f203fec9a792280f99be80a2a07e4a3d82a8883ef0b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215379" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">算法面试经常需要你手写的三个排序算法（Python语言）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484985&idx=1&sn=93343d355abf36c77a361c9931cbe2d1&chksm=fa0e69b8cd79e0ae1e6b57665a456da5f421cc92fe6934337f1eb1e18c3fd6a3c1adc8ca88c2&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215388" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">几道和「二叉树」有关的算法面试题</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196725" LAST_MODIFIED="1575213735">广告</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485696&idx=1&sn=e9d0e9ef271f6f996b0d33cf7016fc2d&chksm=e9d019c1dea790d798b13875bbced246e89d36057a5c44b2bc3a74f58dcf450ba2d9398402be&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196730" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">计算广告系列(三)-通过单品拍卖的例子通俗理解机制设计</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485470&idx=1&sn=02ba16ba150743927b4a387a43a20bdc&chksm=e9d018dfdea791c9e6582ee8342a42bc961d2493575245875f76a3828a58a0336d7ea33cadd4&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213735" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">RS Meet DL(67)-计算广告中的COEC简介</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196701" LAST_MODIFIED="1575215195">其他</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483815&idx=1&sn=116857bdd7363a145533f8f3e4ef2faf&chksm=9b7c984eac0b1158ff08f2f796351e896c63d47b7e9b88633b8183b7afa497ff0180d802b2e0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207492" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">让算法工程师们事半功倍的PyTorch Tricks集合</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0OTU5OTI4MA==&mid=2247487563&idx=3&sn=a77e2341461f603939fdc6da9fb59538&chksm=fbac3114ccdbb802c23522f544ce8d6019e8e42e0b02949b988ae41144d34cf2370a4d103db5&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212331" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【Git学习笔记4】关于远程仓库的必知、创建与合并分支（fast foeward模式）及解决冲突</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484334&idx=1&sn=9f59515ee62a5aede81a802de044caaf&chksm=ce921dd2f9e594c4cea350210a9dc310c9532d57e1280f301f6f07013719635f11b1b4342b2e&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213321" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最近学到的Git知识，大厂的Git机制还是很方便的</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&mid=2650865446&idx=1&sn=68c1bcc9827376b5c7f227a7b769c545&chksm=8b661863bc11917547825276507e65eaf84743327276d2cac325fd906ce4113082b1990c1923&mpshare=1&scene=1&srcid=&sharer_sharetime=1570626733972&sharer_shareid=36e02e48fe2d9ffeff241f6d8df8edf2#rd" target="_blank" rel="noopener" ADD_DATE="1575214304" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">count(1)、count(*) 与 count (列名) 的执行区别</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485532&idx=1&sn=518a99348719e8d92227a584bb413dc3&chksm=fb573146cc20b850f189670eee84ba05928e030f26eead628929b3529003813b3207e95bb671&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215038" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">电商行业，你必须掌握的9大推荐策略</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487106&idx=2&sn=72c66c30246b186db9b53f07756ce65f&chksm=eb501a11dc279307bbb91a732355718e4c944b4c9ac1d6a76b38e4ea276ae2ceeaaaccc791e5&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215093" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【Linux】最常用命令：简单易学，但能解决95%以上的问题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzMzMzOTI3Nw==&mid=2247484902&amp;idx=1&amp;sn=d677261fda90b67bf5eda886447a4f77&source=41#wechat_redirect" target="_blank" rel="noopener" ADD_DATE="1575215195" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">学会这21条，你离 Vim 大神就不远了！</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576153953" LAST_MODIFIED="1576590801">论文</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495222&idx=1&sn=6b5db8a1e243ea4dd8c6b02e5558e85d&chksm=fbd75c5acca0d54c56860d0b7d2e2dfb2dc703c17a2cbc821f8e85780b2ea760ebf2cdf5940a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575210114" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">[ ICDE2020 ] SeqFM：基于多视图自注意力的动态序列感知 CTR 预测模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483881&idx=1&sn=6532870e6ad5b85cbfffa8cba69a9d0b&chksm=fc92bb5fcbe53249422b416577ad07a04eaa7c291a9aa4660b579ee84bd4ae1273852d91d74d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214001" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">效果炸裂，阿里推出深度树匹配召回升级版JTM</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483918&idx=1&sn=650e788a11bb64b55db62185176e38ca&chksm=fc92b8b8cbe531ae7b094ab18eda9250fbac0c83b54d66697905fc17b5919379d9ccb694f367&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213876" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AutoInt:使用Multi-head Self-Attention进行自动特征学习的CTR模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483724&idx=1&sn=03c24d7661e7a5c3fab6b84f12794111&chksm=fc92bbfacbe532ecc25c654185d721589c294b3136c65f26f68351aea8991efb81d51bde9d72&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215231" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Google最新论文，首次引入自动网络设计高效解决大规模深度推荐模型的特征嵌入问题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483793&idx=1&sn=3d828d00f99e294640b77a748bc14cbf&chksm=fc92bb27cbe53231e7d4ea6c6a20e4d6f70587712cb6808286ee75c484b5867096dd7cb41195&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214283" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度CTR预估新积木ONN模型源码阅读与调参经验</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484197&idx=1&sn=20e749add71bf9fab9415c0dec69b27d&chksm=fc92b993cbe530851e37e09dc226bae1deaa163951c64ff5cd74c0d969c5878e5071c519d051&mpshare=1&scene=24&srcid=&sharer_sharetime=1575627524712&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575868395" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度推荐系统之序列化建模2019最新进展</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzMzYwNzY2NQ==&mid=2247484861&idx=1&sn=6203fa9537091b21a83679efc4595dd3&chksm=e8825d23dff5d4352a6e03ba7e77d427a0f8d3614dd45202c117e24075d96a596819df7ce3de&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215121" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">R&amp;S[18] | SIGIR2018：深度学习匹配在搜索与推荐中的应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&mid=2247501800&idx=1&sn=faa374bddb4237ae2ecfce06fb1d03d8&chksm=96ea1868a19d917e0674d17e70eea31eed76bdbb7b186e5be85b716b4a147b5cddedc5cd20e7&mpshare=1&scene=1&srcid=&sharer_sharetime=1576141140885&sharer_shareid=870ce2544b04a88b189d627d7134fc8f#rd" target="_blank" rel="noopener" ADD_DATE="1576154199" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">2019年，异质图神经网络领域有哪些值得读的顶会论文？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247496007&idx=1&sn=c0e0d603533c69a66d8ff93b54396ebd&chksm=fbd7432bcca0ca3de60cdde385c995f5e99dc79f34e254ae8eef579301017a727aa47ec5e20f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1576590801" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">用户行为序列推荐模型</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576153971" LAST_MODIFIED="1576154167">召回</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483810&idx=1&sn=0b15e1f4ff020fd746f11085995aade0&chksm=9b7c984bac0b115d59ad5ac44e86b88c9d4e2caa0468dfc63159241118e3a72663f598c87d2c&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208553" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【Graph Embedding】node2vec-算法原理，实现和应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483667&idx=1&sn=2798a11dce733bd088f25536774811f1&chksm=9b7c98faac0b11ecba756a74da563ba05de0c3bef5c019d313bd920d0598ebb2a33ce1a3527a&mpshare=1&scene=1&srcid=&sharer_sharetime=1572581142370&sharer_shareid=75450ee52aab1158cd74c57711ea459c#rd" target="_blank" rel="noopener" ADD_DATE="1575212888" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【Graph Embedding】DeepWalk算法原理，实现和应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483722&idx=1&sn=2f27f0a5e9d85a669faad20d522bc61f&chksm=9b7c98a3ac0b11b56c170e143b190e740b76a69bdde9ae37d0f1b5438a55bafcd8173d9f185f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212409" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【GraphEmbedding】LINE：算法原理，实现和应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483886&idx=1&sn=272ec1f7aa48c58d260830ad70767892&chksm=fc92bb58cbe5324eb7763e57e6f607bc5464c1cf7ce2dfcd116c49259ad0d84471d198242e63&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213988" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最新！五大顶会2019必读的Graph Embedding相关的论文</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247485824&idx=3&sn=42278b4d73f3fe47bffddc984acfec70&chksm=9704823ca0730b2aa8f8b8b1097e7e2961e8af03d630058792eb8ca0ea6645f16d4bd414c25d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212802" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">员外带你读论文：LINE: Large-scale Information Network Embedding</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247507146&idx=3&sn=c52992bbe6e3773d556664c01bf261c9&chksm=e99eef33dee966255ee6074c8b1a49c6834d66c012520e78d0b3197b38fed8b4e158806d6414&mpshare=1&scene=24&srcid=08232rJhcvJCZfvR8Tp6SMaH&sharer_sharetime=1566914149500&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575215110" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">从原理到落地，七大维度读懂协同过滤推荐算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247507514&idx=3&sn=ca17da426a894954b506a5a45c53bd57&chksm=e99eedc3dee964d533bff4b79416462827b54099ef47f5d8c50f12efca05c036c22dd9a6d25b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215143" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">从原理到落地，七大维度详解矩阵分解推荐算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NDgwNzIwMQ==&mid=2247483949&idx=1&sn=a4e0d7338774ce29b874ab3a543c45dd&chksm=fb77c263cc004b75a2c670113ed61bce4caa22c7a4d6b3ed5cc8294f9164a2b801619c66911f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215280" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统从零单排系列(七)--Airbnb实时个性化推荐之Embedding真的好用吗？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486205&idx=1&sn=a49655032683d555793de48ee864791c&chksm=fb5733e7cc20baf12a7d644b7d2e91bf7ee883a486c528002e7a4088173f6c460c787c07e77e&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213866" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【回顾】推荐系统中基于深度学习的混合协同过滤模型</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576153978" LAST_MODIFIED="1576154127">排序</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&mid=2650411766&idx=2&sn=b589d5c3c5303cc0748422aa374b6c75&chksm=becd94ac89ba1dba78aaa5322d30d49bd044c8a7096afd8f66056b746db1426e9be66dbd29c2&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212464" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度CTR预估模型的演化之路2019最新进展</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483683&idx=1&sn=109758c46d326e138ecffeb6b7439ac1&chksm=9b7c98caac0b11dc928a04cb3e534c18be0698f23f46f7a64e3dca172e737fcb336abe2fe83d&mpshare=1&scene=1&srcid=&sharer_sharetime=1572656095251&sharer_shareid=75450ee52aab1158cd74c57711ea459c#rd" target="_blank" rel="noopener" ADD_DATE="1575212849" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【CTR预估】CTR模型如何加入稠密连续型和序列型特征？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485341&idx=1&sn=79291b284b8456810df579ea41a8208d&chksm=fb573e87cc20b7913bc15cfe69eddac0d1de79e84b5d8cdf195438a96e19d13777cf06359367&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214997" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统之排序</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483892&idx=1&sn=b1d7a75eca9796076e67efc6bee0e115&chksm=9b7c981dac0b110b7bc61b6ed625d82f73cc372b5624efbc9a2cde1704799828c1415b5d87d7&mpshare=1&&srcid=&sharer_sharetime=1575864732287&sharer_shareid=52006a0d19edf83d2b8be98f4d8fe935&from=timeline&scene=2&subscene=1&clicktime=1575864843&enterid=1575864843#rd" target="_blank" rel="noopener" ADD_DATE="1575868263" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Learning to rank基本算法小结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247484862&idx=1&sn=742e078ed875922a12a881ec87b5f624&chksm=fb573ca4cc20b5b2ec388d5d5ab4a4ea33fb72d447b664ad2bb2c896103c6c76ca6484feb705&mpshare=1&scene=24&srcid=&sharer_sharetime=1568428307082&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214959" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文看懂 FM ( Factorization Machine ) 模型的各种变式</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576154244" LAST_MODIFIED="1576154250">搜索</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU5ODUxNzEyNA==&mid=2247485100&idx=1&sn=4c0b4e6a887df2a1496668127d6d1214&chksm=fe43b247c9343b51d1c9127a31b194f6476f2cfe41cbda63f92c74d26e80b46398e07baae291&mpshare=1&scene=1&srcid=&sharer_sharetime=1576123032213&sharer_shareid=65030b4340b230b9f1037ac3abfe34e5#rd" target="_blank" rel="noopener" ADD_DATE="1576154250" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">淘宝搜索模型如何全面实时化？首次应用于双11</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576214119" LAST_MODIFIED="1576214233">广告分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494579&idx=1&sn=b5274f98c5cfae81d1af68944d3252df&chksm=fbd759dfcca0d0c9f8ab04bebee04b0d7fd6fdd3eae87d3ef475fb26e03b402999c31621d034&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213935" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">爱奇艺效果广告的个性化探索与实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494020&idx=1&sn=df65908cdaf57d02eee8280d86d66949&chksm=fbd75be8cca0d2fe2d69d89a70eced34ba467acbf26fefe1bf40edea36a07e76406612383fd5&mpshare=1&&srcid=&sharer_sharetime=1570510270764&sharer_shareid=90667dd07c937c48cb4022a5f8a7c3b0&from=timeline&scene=2&subscene=1&clicktime=1570512805&enterid=1570512805#rd" target="_blank" rel="noopener" ADD_DATE="1575214344" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">OCPC 广告算法在凤凰新媒体的实践探索</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494094&idx=1&sn=4c32130746752039fba45a5ba6b7eedb&chksm=fbd75ba2cca0d2b45533b2464418873e366f1e733a5b92d8ad1a754d2390334e5443f8fa60b3&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214699" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">阿里妈妈：品牌广告中的 NLP 算法实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485921&idx=1&sn=833bef050627a5689162e1f5a9b40393&chksm=fb5730fbcc20b9edd3640c3fb808028f746b05f98691b4ce9d699a3551dc0dba969e5f9ed1d6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214822" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">微博广告推荐策略工程架构体系演进</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576214149" LAST_MODIFIED="1576214260">其他分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486603&idx=1&sn=0a825a889fe2014c584cbf3d7fe62975&chksm=fb573591cc20bc8794d005aae0a3f7be50f3d02fa527b9f546576ca57087262406dde6fd2957&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207476" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【推荐实践】微博在线机器学习和深度学习实践（文末附PPT下载链接）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247493934&idx=2&sn=6d4dadb2c34ac0cff635e52a5bf96be3&chksm=fbd75b42cca0d2545065580ebb6a9c7796cefb90b718b1f25c78c5b0a6d3d0c2eb1aa668777b&mpshare=1&scene=2&srcid=&sharer_sharetime=1569288966045&sharer_shareid=90667dd07c937c48cb4022a5f8a7c3b0&from=timeline&clicktime=1569289112#rd" target="_blank" rel="noopener" ADD_DATE="1575214747" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">电商多目标优化小结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247486585&idx=1&sn=d7cb9680e694b78953912e2163dcf986&chksm=e9293176de5eb8601cb50bc920873b9a953109e1e37bd4c2633d62bcfb75aed71e6803af0488&mpshare=1&scene=24&srcid=0917IPhiZz6f3LDk4kI8ekRT&sharer_sharetime=1568682799879&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214850" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一天造出10亿个淘宝首页，阿里工程师如何实现？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485187&idx=1&sn=1e819a18fb0503e579c0fc6e116d46d9&chksm=fb573e19cc20b70fd03d37b81027c48bb7009854500b5b67755b866272faf7b0efb11a08344e&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556747382&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214865" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度学习在 Airbnb 中的探索与应用（附论文下载链接）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485219&idx=1&sn=d16340f84ddecdb16858d7fcb67c4c80&chksm=fb573e39cc20b72fdb5ca437cbc8daa4c08638534105d21d4874ef8db74808c2001c2480947f&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556689824&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214885" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">相关性特征在图片搜索中的实践</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576590855" LAST_MODIFIED="1576590980">电商推荐分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486297&idx=1&sn=dc5128d9e852e5731c86b677c7208f84&chksm=fb573243cc20bb558b35ad717f9f78d94973c4427b7bb02701ac9873f325123a3cb922a7acda&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213433" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">大众点评信息流推荐中基于文本生成的创意优化实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484034&idx=1&sn=22fde92cc742c5fbb7874c4fc25b3169&chksm=fc92b834cbe53122459ccc417388e7b0340524196ef805936de00ec019e1f4b6d8977bb77ff9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213364" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">蘑菇街内容信息流排序实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486348&idx=1&sn=1fe7605a7d2483811f075a3d01c824bd&chksm=fb573296cc20bb80d8efd1fd6f70f37dd495cacec856b6b428ebba39c65accde0e406a549d31&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212926" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【推荐实践】强化学习在美团“猜你喜欢”的实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247484612&idx=1&sn=9526d939740fd18aefe63ad13a472c6b&chksm=fb573ddecc20b4c8a6348fea0ba6d8c8e2763922afd917a77db1a415f247ebbc9686ea584e91&mpshare=1&scene=24&srcid=&sharer_sharetime=1570802964071&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214208" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">2.5亿用户的美团智能推荐系统是如何构建的</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485192&idx=1&sn=21661e2dcf00b661b9077b4670f39a79&chksm=fb573e12cc20b704589c38ab09a988fa73f9b4e92f390ff7eead1aa6a8dd8e76cda8b7c6be21&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556728663&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214874" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">电商推荐系统及思考</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485407&idx=1&sn=fba5509bcb018eca5c4dacd409b627c4&chksm=fb573ec5cc20b7d39ef7d1c2383928f7f16d0c4d9ff248f450da10968b22df1c5b9d2669df5b&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556606971&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214908" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">京东电商推荐系统实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485196&idx=1&sn=a1d7621136291e23da4a0bd5c0aa62bb&chksm=fb573e16cc20b7002cecb3ae5acd7340505d4e54ecbf8c3bf22a0595b6465dbefb5593ac8f1b&mpshare=1&scene=24&srcid=&sharer_sharetime=1568428219564&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214969" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【推荐应用】Embedding技术在民宿推荐中的应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0NTE4NjA0OQ==&mid=2658362441&idx=1&sn=f5411e0ebd33baed8264ed7320f77e41&chksm=f2d5af27c5a22631b1fcda81a7853a354be45cb75ac842a24d062107b71e3fd2ef119610c01c&mpshare=1&scene=1&srcid=&sharer_sharetime=1576509433838&sharer_shareid=65030b4340b230b9f1037ac3abfe34e5#rd" target="_blank" rel="noopener" ADD_DATE="1576590825" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">解密淘宝推荐实战，打造 “比你还懂你” 的个性化APP</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576590866" LAST_MODIFIED="1576590983">视频、新闻分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247486975&idx=1&sn=8c5bacd451b8d08a3517dc691872f6cf&chksm=fbd4bf93cca336858770741723368e687958d3f19ff20aec614d72e2ab17fdfe68a973d278a5&mpshare=1&&srcid=&sharer_sharetime=1573370069415&sharer_shareid=03acd21ed792ec103a2d36489130b8a0&from=timeline&scene=2&subscene=1&clicktime=1573370821&enterid=1573370821#rd" target="_blank" rel="noopener" ADD_DATE="1575212322" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">「干货」YouTube 基于深度神经网络推荐系统剖析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484131&idx=1&sn=eb8551059b248f20e96b36a566a64ae8&chksm=fc92b855cbe53143b53eabc4a0a148779a3d9ee46c1bb6921fab781adadea5ead8a33b57ef49&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212398" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Hulu视频推荐如何提升推荐中的多样性</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486369&idx=1&sn=94c06edcbb3e94538ca99cda3362c453&chksm=fb5732bbcc20bbadf339f8a970402992e9c4cd1b9ad1485a52f03574f8195f92c45c2b840421&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212904" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">YouTube 多目标排序系统：如何推荐接下来收看的视频</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494558&idx=1&sn=10a6332147d713230d0fa4dbf9cdc897&chksm=fbd759f2cca0d0e4f5d39887a86b1d6efae13ad0540dc191fdbc8bb29120d0081a90c97b35f6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213978" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度学习技术在美图个性化推荐的应用实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494398&idx=1&sn=cd08a71c4a7ec9a2d81107603fc4c437&chksm=fbd75892cca0d184585075b3315fe0386d37c174995a5a4b27e02db4117a13897678dbcb52ed&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214141" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">UC 信息流推荐模型在多目标和模型优化方面的进展</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485914&idx=1&sn=98ef79659c5c0246c081e7c2c205b7f6&chksm=fb5730c0cc20b9d6684a9279037611d474df036602c1ed28d301b71306e998a26173792f8c88&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214841" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">快看漫画个性化推荐探索与实践.pdf(附下载链接)</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247484887&idx=1&sn=238cc7643c3901ff3d45326a134ac2cf&chksm=fb573ccdcc20b5db01fa4f88c717f6d4dda21307ce4f325b7ee796c88223e1bb02ecb1a4dbda&mpshare=1&scene=24&srcid=0915EC89bqiY9QAf6dZdSrd0&sharer_sharetime=1568556193226&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214928" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">今日头条推荐系统原理</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485521&idx=1&sn=5e0ee98e2f10f1b38bc5b3168b13ff7b&chksm=fb57314bcc20b85db1b2b6948677d2e859d182090a6278bc275e0dcd28d7564a6ac39f12baca&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215020" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Hulu：视频广告系统中的推荐算法实践</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576590883" LAST_MODIFIED="1576590976">其他推荐分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495507&idx=1&sn=a1e0cf988d2e366be58faf1110e4d885&chksm=fbd75d3fcca0d429b33c5a49053dd99a03e603b3230e950d0109f3c9dbe7ede21e1fa2a86752&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207287" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">RALM: 实时 Look-alike 算法在微信看一看中的应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495381&idx=1&sn=4dfd39fe16a402ffef8e32235aa36b21&chksm=fbd75cb9cca0d5af552d9958a3a08690d2767a3f0165537108231bff157fbaf28bd45760ea6b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208715" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">如何从 0 到 1 构建个性化推荐？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495109&idx=1&sn=eccf1f678affd8272ace63dfa207c23a&chksm=fbd75fa9cca0d6bfd723de5cc78631993670f99567fd3457a63187232105c854bd189acc4fe6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212440" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Airbnb 基于 Embedding 技术的实时个性化推荐</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247484814&idx=1&sn=38c68015123ee1bda8dd687ae215b8f4&chksm=fb573c94cc20b582d189f9ce54b865fbf696868f1fd598b5c2105a4abc97a8e92ccf26c761d7&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556943700&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214858" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【干货分享】深度学习新技术在搜狗搜索推荐中的深化应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485223&idx=1&sn=2deaad3a5b2de8058f865a6849e95f79&chksm=fb573e3dcc20b72bcc4b03e699a8b9ffc25e04bee4ad0782e12b2c297ce9af0cd255010e9578&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556668471&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214900" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统燃料：数据那些事儿</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485485&idx=1&sn=5d8b178ecee969b0bbc9112de0416344&chksm=fb573137cc20b8215a2506ab27640cc4d27561fb2bd430b72dd6b3369ce40e1fada147bb4369&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556583821&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214920" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">多维度分析：推荐效果明显的产品属性</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485395&idx=1&sn=8e862c796b1b25370add04f7995e8296&chksm=fb573ec9cc20b7dfaee91a2594a51ae46249d120e13646ca1ca215285bfe59c8e05ceefb62b4&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215010" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">腾讯手Q游戏中心的个性化推荐技术框架与实战</A>
            </DL><p><br>        &lt;/DL&gt;<p><br>    &lt;/DL&gt;<p><br>&lt;/DL&gt;<p></p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-34-在排序数组中查找第一个和最后一个位置</title>
    <url>/2019/12/17/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA/</url>
    <content><![CDATA[<h2 id="在排序数组中查找第一个和最后一个位置"><a href="#在排序数组中查找第一个和最后一个位置" class="headerlink" title="在排序数组中查找第一个和最后一个位置"></a>在排序数组中查找第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]<br>示例 2:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是个二分查找的变形！！！二分的框架是很简单，但是其细节问题非常致命，简单举几个例子，右边界什么时候是n什么时候是n-1，缩小范围后，什么时候是right = mid-1，什么时候是right=mid。。。。等等</p>
<p>其实这些问题都是一个最重要的概念没有搞清楚，即<strong>查找区域</strong>。</p>
<blockquote>
<p>自己还是觉得大佬的表述更加的逻辑清楚，自己讲出来就不是那么回事了</p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">二分查找算法细节详解</a></p>
</blockquote>
<p>如何界定我们的查找区域也就限制了我们一系列的操作。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findfirst</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = len(nums)</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">if</span> left == len(nums):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] != target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findlast</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = len(nums)</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[left<span class="number">-1</span>] != target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [findfirst(nums,target),findlast(nums,target)]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>京东搜索架构</title>
    <url>/2019/12/17/%E4%BA%AC%E4%B8%9C%E6%90%9C%E7%B4%A2%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="京东搜索架构"><a href="#京东搜索架构" class="headerlink" title="京东搜索架构"></a>京东搜索架构</h2><h3 id="召回过程"><a href="#召回过程" class="headerlink" title="召回过程"></a>召回过程</h3><p>分词—— 倒排索引——倒排链表</p>
<p>大量空 query  做负反馈调节</p>
<p>倒排链 没有交集的 返回空query</p>
<p>搜索意图识别、纠错、term weight</p>
<p>倒排 keyword-&gt;sku result   用于召回阶段</p>
<p>正排 skuid-&gt; 商品详情 用于粗排精排</p>
<p>召回（捞）的过程： KNN 召回（H）+个性化召回（C）</p>
<p>相关性召回</p>
<p>粗排：</p>
<p>质量、热度、品牌、个人偏好</p>
<p>25个分片 每个分片保留300个  最后保留7500个商品</p>
<p>精排：</p>
<p>入口 7500的数量</p>
<p>95%的用户 前10页  85%用户不会超过前4页  </p>
<p>GMV 流水 或者 营收</p>
<p>list = 30 精排结果返回 目前支持最高30个 </p>
<p><strong>优质增量，不截断</strong></p>
<p><strong>1️⃣</strong>拼购精选、2️⃣hotscore大于50、</p>
<p>3️⃣战略单品、4️⃣医药o2o</p>
<p>手机壳</p>
<p>推荐/搜索/广告 公司流量的三驾马车</p>
<h4 id="意图理解"><a href="#意图理解" class="headerlink" title="意图理解"></a>意图理解</h4><p>query process-&gt; 运营干预 —&gt; op-web()yemian</p>
<p>意图识别，只靠单纯的pair对是实现不了的 还需要结合 用户维度的特征：时间地点画像 ，指导搜索引擎如何来返回结果</p>
<p>运营干预的理解：</p>
<blockquote>
<p>结合国家政策或者时事热点，来限制搜索意图。比如港独的产品，是如何做到下架的</p>
</blockquote>
<p>透传？</p>
<p>H-search： 深度学习 修饰词</p>
<p>C-search：个性化 search</p>
<h3 id="多次阶段——漏斗模型"><a href="#多次阶段——漏斗模型" class="headerlink" title="多次阶段——漏斗模型"></a>多次阶段——漏斗模型</h3><p>2次召回截断</p>
<p>第三次截断为粗排序 粗排结果为7500个</p>
<p>第四次精排</p>
<h3 id="工程架构"><a href="#工程架构" class="headerlink" title="工程架构"></a>工程架构</h3><p>缓存问题</p>
<blockquote>
<p>一级缓存，1分钟，针对单页，解决10%的流量</p>
<p>二级缓存，翻页缓存，应对同一用户翻页请求，缓存10页，失效1分钟；导航区缓存，包含品牌、分类、属性汇总，失效30分钟。 服务器上给用户维护了（单商品的变化，对品牌分类汇总信息的冲击不大）</p>
<p>三级缓存，</p>
</blockquote>
<h3 id="产品思维"><a href="#产品思维" class="headerlink" title="产品思维"></a>产品思维</h3><p>马太效应问题</p>
<p>爆款产品的解决：不投广告也照样top排序，所以出现爆款产品并不是一件很好的事情</p>
]]></content>
  </entry>
  <entry>
    <title>Shell 命令基础</title>
    <url>/2019/12/17/shell%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Shell命令基础"><a href="#Shell命令基础" class="headerlink" title="Shell命令基础"></a>Shell命令基础</h2><p>日常linux下工作除了基本的命令行命令之外 还需要积累一些shell 脚本的基础知识</p>
<h3 id="source-用法"><a href="#source-用法" class="headerlink" title="source 用法"></a>source 用法</h3><p>激活脚本，比如.sh文件中定义了一些变量，完全可以通过source一个.sh文件来使得脚本中定义的变量生效</p>
<p>但是有个问题，这个生效的声明周期仅限于在该会话内，再开一个终端是不能用的</p>
<h3 id="df-和-du"><a href="#df-和-du" class="headerlink" title="df 和 du"></a>df 和 du</h3><ul>
<li>du: disk-usage 显示文件或者目录所占磁盘空间</li>
</ul>
<p>du工作原理，会对待统计文件逐个调用<code>fstat</code>这个系统调用</p>
<ul>
<li>df:disk-free  检查磁盘空间（所以并不能看某个目录的占得磁盘大小）</li>
</ul>
<h3 id="查看文件挂载在哪里"><a href="#查看文件挂载在哪里" class="headerlink" title="查看文件挂载在哪里"></a>查看文件挂载在哪里</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h &lt;path&gt; 即可查看</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Git 常用工作流</title>
    <url>/2019/12/17/git%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<h3 id="git-基本工作流"><a href="#git-基本工作流" class="headerlink" title="git 基本工作流"></a>git 基本工作流</h3><p>初级 以及讲解  配合业务 使用</p>
<ul>
<li><p>从线上拉回代码</p>
</li>
<li><p>开发前建立一个分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b marys-feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进行开发</p>
</li>
<li><p>然后将开发的结果push上去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进行 git push -u origin  branch_name</p>
</li>
<li><p>提  merger request </p>
</li>
</ul>
<h3 id="更换branch名字"><a href="#更换branch名字" class="headerlink" title="更换branch名字"></a>更换branch名字</h3><p>git branch -m oldname newname</p>
<p>然后再走一遍新的工作流，将新的branch 上传至 origin</p>
<p><a href="https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-feature-branch.md#小红开始开发一个新功能" target="_blank" rel="noopener">https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-feature-branch.md#%E5%B0%8F%E7%BA%A2%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%96%B0%E5%8A%9F%E8%83%BD</a></p>
<h3 id="只克隆branch-到本地"><a href="#只克隆branch-到本地" class="headerlink" title="只克隆branch 到本地"></a>只克隆branch 到本地</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b branch_name  git_address</span><br></pre></td></tr></table></figure>
<h3 id="完整地址"><a href="#完整地址" class="headerlink" title="完整地址"></a>完整地址</h3><p><a href="https://github.com/oldratlee/translations/tree/master/git-workflows-and-tutorials" target="_blank" rel="noopener">https://github.com/oldratlee/translations/tree/master/git-workflows-and-tutorials</a></p>
]]></content>
  </entry>
  <entry>
    <title>Apach pig 日常使用总结</title>
    <url>/2019/12/16/Apache%20pig/</url>
    <content><![CDATA[<h2 id="Apach-Pig"><a href="#Apach-Pig" class="headerlink" title="Apach Pig"></a>Apach Pig</h2><p>最近需要用到pig这个东西，故做简单的学习记录</p>
<p>首先 pig的基本组成单元是关系，就是内部存储的东西都是关系</p>
<p>是一种简单的分析工具， 其基础是运行在hadoop基础上，那么就涉及到基础的文件加载和存储问题</p>
<h3 id="pig加载数据"><a href="#pig加载数据" class="headerlink" title="pig加载数据"></a>pig加载数据</h3><p>加载数据的目的是将raw data 加载进pig的关系中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">relation_name = LOAD 'input_file_path' USING function as schema;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"></span><br><span class="line">student = LOAD 'hdfs://localhost:9000/pig_data/student_data.txt' </span><br><span class="line">   USING PigStorage(',')</span><br><span class="line">   as ( id:int, firstname:chararray, lastname:chararray, phone:chararray, </span><br><span class="line">   city:chararray );</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>relation_name</strong> - 我们必须提到要存储数据的关系。</li>
<li><strong>Input file path</strong> - 我们必须提到存储文件的HDFS目录。（在MapReduce模式下）</li>
<li><strong>function</strong> - 我们必须从Apache Pig提供的一组加载函数中选择一个函数（ <strong>BinStorage，JsonLoader，PigStorage，TextLoader</strong> ）。</li>
<li><strong>Schema</strong> - 我们必须定义数据的模式，可以定义所需的模式如下 -</li>
</ul>
<p>还有一种是加载hive表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">result = load 'hive表' using</span><br></pre></td></tr></table></figure>
<h3 id="pig-存储数据"><a href="#pig-存储数据" class="headerlink" title="pig 存储数据"></a>pig 存储数据</h3><p>是将转化为关系的数据，存储在hdfs上（local也可以）</p>
<h3 id="FOREACH-GENERATE的使用"><a href="#FOREACH-GENERATE的使用" class="headerlink" title="FOREACH, GENERATE的使用"></a>FOREACH, GENERATE的使用</h3>]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Transformer详解</title>
    <url>/2019/12/16/Transformer%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Transformer-详解"><a href="#Transformer-详解" class="headerlink" title="Transformer 详解"></a>Transformer 详解</h2><p>这个基本是面试重点，在理解这个transformer结构上，可以从宏观开始，然后逐步深入到其中的细节问题。</p>
<h3 id="说在前面："><a href="#说在前面：" class="headerlink" title="说在前面："></a>说在前面：</h3><p>  重点讲解Transformer、BERT部分，transformer-XL、XLNet优化部分做介绍</p>
<ol>
<li><p>一个概念：什么是自回归，什么是自编码？</p>
<p>常规的语言模型从左到右或从右向左都属于自回归模型，就是只依赖于上文或只依赖于下文</p>
<p>GPT就是典型的自回归（从左到右），ELMo也是，只不过其将两个方向的LSTM的hidden state 进行了concat，以来表示上下文。这种自回归方式主要适合生成类任务：文本摘要，机器翻译</p>
<p>BERT 属于去噪声自编码（Denoising Autoencoder）自编码的过程是可以见到上下文的。什么是去噪自编码呢。以BERT为例子，就是在预训练的过程中引入噪声（mask）然后masked LM的目的就是通过上下文来预测mask，达到去噪的目的。这种模式在阅读理解、SQuAD等任务上表现很好，因为这些任务是允许看到上下文的。</p>
</li>
<li><p>Transformer重要参考资料（阅读顺序排列）：</p>
<p>Attention is all your need论文、The Illustrated Transformer（详细讲解Transformer流程）、</p>
<p>The Annotated Transformer（transformer Pytorch版实现）、Transfomer Google官方实现</p>
<p>（Tensor2Tensor）</p>
<p>阅读之后至少清楚模型内部的数据（向量或矩阵）的流动（训练阶段的流动方式、测试阶段的流动方式）</p>
<ol>
<li><p>position encoding<br>理解实现方式、解决的问题</p>
</li>
<li><p>Multi-head attention</p>
<p>理解QKV的生成过程、</p>
<p><strong>重点</strong>理解</p>
<p>Multi-head是如何实现的、了解整个模型需要学习的参数是哪些</p>
<ol>
<li>self-attention<br>理解计算原理、实现方法、重点了解矩阵之间计算</li>
<li>masked self-attention<br>理解mask的作用，mask的实现方式。清楚masked self-attention 和 self-attention 的差别</li>
<li>encoder-decoder attention<br>理解该部分attention 的数据来源</li>
</ol>
</li>
<li><p>一些细节</p>
<ol>
<li>add&amp;Norm 也是有学习参数的</li>
<li>最后decoder的输出层还有一个Linear+softmax</li>
<li>在测试阶段Greedy decoding策略 和 Beam Search策略</li>
</ol>
</li>
<li><p>问题</p>
<ol>
<li>重点明白Transformer的不能解决长文本依赖的问题（受制于实现过程的内存限制、否则其序列长度是可以不受限制的）</li>
</ol>
</li>
</ol>
</li>
<li><p>Transformer-XL</p>
<p>重要参考资料：</p>
<p>Transformer论文、官方简要+动图、官方代码（未看）</p>
<ol>
<li>理解Transformer的操作过程（训练、测试），知道Transformer的弊端</li>
<li>重点理解下 Transformer 的主要组件是 decoder-only (就是只使用transformer的decoder 部分，不是完整的transformer的 encoder+decoder结构)</li>
<li>清楚下Transformer-XL解决Transformer存在问题的总体思想</li>
<li>Segment-lever Recurrence 的实现方式</li>
<li>Relative Positional Encoding 的实现方式</li>
</ol>
</li>
<li><p>BERT</p>
<p>重要参考资料：</p>
<p>BERT原文、illustrated-bert（捎带GPT ELMo）、官方源码、BERT文本分类</p>
<ol>
<li><p>背景知识<br>自编码、自回归<br>了解GPT、ELMo 跟BERT的关系</p>
</li>
<li><p>理解BERT用的只是Transformer的encoder（可以见到上下文，只部分mask）</p>
</li>
<li><p>embedding<br>了解BERT的丰富Embedding（token+segment+position）</p>
</li>
<li><p>两个创新点：<br>重点明白Masked LM 的实现，以及Loss 计算方式<br>重点明白Next Sequence Prediction的原理，以及Loss计算方式</p>
</li>
<li><p>应用<br>了解BERT对各任务的应用场景：sequence level  和 token level</p>
</li>
<li><p>一些问题<br>BERT切词方式：在源码的 tokenization.py<br>BERT的pre-traing 和 fine-tuning过程不一致问题<br>BERT还可以做feature-based 形式，后边拼接自己的模型</p>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>XLNet</p>
<p>重要参考资料：</p>
<p>XLNet原文、跟其他模型对比and论文解读、XLNet与Bert对比</p>
<ol>
<li>背景知识：BERT+Transformer-XL</li>
<li>主要方法：<br>Permutation Language Modeling 方式 用自回归的方式达到见到上下文信息<br>Architecture:Two_Stream Self-Attention for target-Aware representations(本次分享未涉及到)<br>从Transformer-XL 借鉴经验</li>
<li>XLNet 未讲解部分，还需要大家之后单独了解下</li>
</ol>
</li>
<li><p>思考</p>
<ol>
<li>NLP -&gt; Nvidia League Player</li>
<li>刷榜模型或方法层出不穷</li>
<li>实际工作中有哪些可以展开的工作</li>
</ol>
</li>
</ol>
<h3 id="Embedding层"><a href="#Embedding层" class="headerlink" title="Embedding层"></a>Embedding层</h3><p>Transformer的embedding层比较特殊的地方就是引入了Position embedding，为什么需要这样一个embedding？原因是由于后边进行self-attention的时候，每个词之间都可以进行交互，这样解决了长期依赖的问题，但是由于缺少了原有语言的顺序，那么<code>i am a boy</code>和<code>am boy a i</code>是没有区别的了，反正两两之间都会计算score.</p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>Encoder是个模块，简单的理解实际上就两部分，一部分是Mult-head Attention 另一部分是一个Positionwise FeedForward，当然还有两个小模块add&amp;norm。</p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>今天又理解了一个  Layernormalization和 batchnormalization的区别</p>
<p>针对的归一化维度是不一样的。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>百度信息流算法？面经</title>
    <url>/2019/12/16/%E7%99%BE%E5%BA%A6%E4%BF%A1%E6%81%AF%E6%B5%81%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="百度信息流算法？面经"><a href="#百度信息流算法？面经" class="headerlink" title="百度信息流算法？面经"></a>百度信息流算法？面经</h2><p>为什么要给标题打个问号呢？ 因为我是真的好奇，我自己投的到底是不是算法工程师…因为二面面试官为我的问题，真的是之前面别的地方从来没有问过的…也算给自己提个醒吧…算法工程师不仅仅需要掌握那些玄幻的算法什么….更重要的还是工程师嘛。。。</p>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>简单的自我介绍，说下自己之前做的项目，然后：</p>
<p>会不会c c++ java，我说自己java还可以，面试官紧接着问java的字符串的三种形态 stringbuffer  stringbuild什么的清楚嘛？</p>
<p>我：java写但是确实仅限于写题，具体的一些细节和底层的东西确实没有接触过。也就在大二时候用过，最近可能确实很久没用了，不太熟悉。。。</p>
<p>面试官：你用c写个堆排序吧…</p>
<p>（其实堆排序自己写起来问题倒是不大，但是c语言…用久了python 根本不记得c的一些写法了，包括最开始变量定义都写错了，也算完整写下来了吧….）</p>
<p>然后面试官问了一个算法设计题目：</p>
<blockquote>
<p>给你一批数据，有id和score，然你根据score的值大小进行加权采样，即根据score分数，从中抽取n个样本</p>
<p>Id score</p>
<p>0    3</p>
<p>1    5</p>
<p>2    10</p>
<p>3    1</p>
<p>。。。</p>
</blockquote>
<p>问怎么实现？</p>
<p>我提的思路是，可以根据score的分数对样本进行copy，也就是说对于score=3，那我就把id复制3次，对于score=10，我就把对应id复制10次，再将复制之后的整体数据进行打散，然后再随机抽取n个，由于样本中的样本分布已经被之前的操作所改变，所以完全可以达到加权采样的效果。但是这样操作的问题就是，如果数据量很大，那么你都进行复制，数据量会更大，其实是不太友好的。</p>
<p>然后看我简历有awk 和Linux，问了几个简单的命令。</p>
<p>一面给的评价还是positive的吧，问题不太大。</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>（我开始还以为是压力面，但是谁知道 人家真的就是二面….）</p>
<p>简单的聊一下项目，问下我的研究生的方向（本人研究生方向是云计算与服务工程，但是自己并没有去做相关的内容）然后针对项目中的知识点进行细致的提问，比如 lstm+crf 如果只有lstm会怎样，只有crf会怎样。项目没有问很多吧。</p>
<p>然后就是写题其实题目也很简单，写一个单链表的反转….问题就是，只能用c来实现，c语言确实很久没有写了，导致写出来的代码不伦不类，很被动。</p>
<p>然后写完单链表的反转之后他对代码不是很满意…确实很多c语言的写法可能都记不清楚了，又写了一个快排，快排的partition我也是写了一个可能跟他印象中不一样的（这会面试体验挺不好的…跟你印象中的不一样就不对了?）然后说我写的c语言不行…然后开始问我c语言的基础，全局变量和局部变量区别，说到了堆栈，就问我堆栈具体怎么实现的。</p>
<p>从这开始就进入了完全被动状态…甚至怀疑自己投错了岗位</p>
<p>问我怎么理解类，类有哪些特性</p>
<p>开始问数据库的一些知识：数据一致性，数据一致性是通过什么来实现的？（这个完全没有印象）</p>
<p>操作系统的进程线程的区别（这个还好）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实总体面完的感觉还是很糟糕的，原因一方面是感觉跟之前面其他公司的感觉完全不一样，没有推算法 没有将项目，没有机器学习相关，直接全是计算机基础。另一方面就是，自己的计算机基础真的是糟糕…可能这也是自己着力避开这些，想通过算法工程师来解决吧…但是说到底这些都是计算机专业的基础课…虽然学过忘记了…还是尽量多复习复习吧，明年秋招，尽量别被这种问题卡主。</p>
]]></content>
  </entry>
  <entry>
    <title>Dropout学习与总结</title>
    <url>/2019/12/14/dropout%E9%A2%84%E9%98%B2%E8%BF%87%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<h2 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h2><p>关于一个新东西的三连：是什么，为什么，怎么用</p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Dropout 是训练<strong>深度</strong>神经网络时采取的一种手段，来预防过拟合。在训练过程中，随机的以一定的概率“临时”抛弃掉某些节点。具体来讲，dropout作用于每个<strong>小batch</strong>训练数据，由于其随机丢弃部分神经元的机制，相当于每次迭代都在训练不同的神经网络结构。</p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>Dropout为什么会有这样的效果呢？类比bagging方法，其实达到了集成学习的效果。从bagging的集成角度来讲，传统意义上的bagging集成方法涉及多个模型的训练与评估，当网络参数规模庞大时，这种集成方式需要消耗大量的运算时间和空间。而Dropout是在小批量上进行操作，类似一种轻量级的bagging集成近似，能够实现指数级数量神经网络的训练与评估。</p>
<p>原理就是，在dropout具体实现过程中，要求每个神经元节点激活值以一定的概率p被“丢弃”（被置0）。对于有N个神经元节点的神经网络，使用Dropout 可以看做是有$2^n$ 个模型的集成（即每个神经元都可以选择 存在或者不存在），他们共享部分权值，并且具有相同的网络层数，而且模型整体的参数数目不变，大大简化了运算。每次训练都会随机挑选一批不同的神经元进行组合优化，这个过程会减弱全体神经元之间的联合适用性，减少过拟合的风险，增强泛化能力</p>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>主要涉及两个过程一个是训练过程，一个是预测过程，在训练过程我们采取了概率p来丢弃神经元，那么在运行预测过程（一次前向传播）的时候，我们不在对神经元进行丢弃，相反，我们使用概率p乘在每个神经元上，以恢复训练过程中，某神经元只有概率p存在神经网络中。</p>
<p>使用Dropout前的前向传播：</p>
<script type="math/tex; mode=display">
z_{i}^{(l+1)} = w_{i}^{(l+1)}y^l+b_{i}^{(l+1)} \\ 
y_{i}^{(l+1)} = f(z_i^{l+1}) \\
f是激活函数</script><p>使用dropout后的前向传播</p>
<script type="math/tex; mode=display">
r_{i}^{(l)} \sim Bernoulli(p) \\
\hat{y}^{(l)} = r^{(l)} \dot \ y^{(l)}  \\
z_{i}^{(l+1)} = w_{i}^{(l+1)}y^{(l)}+b_{i}^{(l+1)} \\ 
y_{i}^{(l+1)} = f(z_i^{(l+1)}) \\
f是激活函数</script><p>由此可见，是先对前一层的神经元进行“丢弃”再执行传播操作。</p>
<h3 id="一些细节的理解"><a href="#一些细节的理解" class="headerlink" title="一些细节的理解"></a>一些细节的理解</h3><p>每次dropout的是神经元，并不是权值，也就是说权值参数矩阵始终是在更新的。每一次计算$W^T X$的时候，其中X中部分神经元被置为0。这样相当于“丢弃”了这部分神经元。</p>
<p>训练过程，对于未被丢弃的神经元，还需要乘以$\frac{1}{1-p}$使得总体的分布情况保持一致。</p>
<p>预测过程，对于全部的神经元，都需要乘以概率p，来恢复训练过程中，某个神经元以概率p存在神经网络中。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>中心极限定理</title>
    <url>/2019/12/11/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><h3 id="数学表述"><a href="#数学表述" class="headerlink" title="数学表述"></a>数学表述</h3><h3 id="独立同分布的中心极限定理"><a href="#独立同分布的中心极限定理" class="headerlink" title="独立同分布的中心极限定理"></a>独立同分布的中心极限定理</h3><p>设随机变量X1，X2，……Xn，……独立同分布，并且具有有限的数学期望和方差：E(Xi)=μ，D(Xi)=σ20(k=1,2….)，则对任意x，分布函数</p>
<p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/f31fbe096b63f624c0ee83e68a44ebf81b4ca3a0.jpg" alt="img"></p>
<p>满足</p>
<p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/faf2b2119313b07e435bb59901d7912396dd8cb9.jpg" alt="img"></p>
<p>该定理说明，当n很大时，随机变量</p>
<p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/77094b36acaf2edda57f1a01861001e93801934f.jpg" alt="img"></p>
<p> 近似地服从标准正态分布N(0，1)。因此，当n很大时，</p>
<p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/d62a6059252dd42af4b35875093b5bb5c8eab8b2.jpg" alt="img"></p>
<p> 近似地服从正态分布N(nμ，nσ2)．该定理是中心极限定理最简单又最常用的一种形式，在实际工作中，只要n足够大，便可以把独立同分布的随机变量之和当作正态变量。这种方法在数理统计中用得很普遍，当处理大样本时，它是重要工具。</p>
<p>从数学公式到例子的理解，重点应该关注下 什么叫随机变量，随机变量也是一个样本的分布情况，</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>这个例子讲的挺明白，但是目前跟中心极限定理的数学表达还对不上</p>
<p><a href="https://blog.csdn.net/mingyuli/article/details/81141758" target="_blank" rel="noopener">https://blog.csdn.net/mingyuli/article/details/81141758</a></p>
<h2 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h2><p>对于一份数据集，其分布可能并不是正太分布的。但是我们可以通过采样操作，比如每次采样n=50个，一共采样m个样本集，那么这个样本集的分布是符合正太分布的。</p>
<p>比如整个数据集合的均值可能为1，方差为2。我们抽出来了m个样本，可能这m个样本中，有的样本均值为0，有的样本均值为0.9，有的为1.2有的为2.0 。但是这m个样本的分布是符合正太分布的。</p>
]]></content>
      <categories>
        <category>概率与统计面试题</category>
      </categories>
  </entry>
  <entry>
    <title>头条广告算法面经</title>
    <url>/2019/12/10/%E5%A4%B4%E6%9D%A1%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="头条广告算法面经"><a href="#头条广告算法面经" class="headerlink" title="头条广告算法面经"></a>头条广告算法面经</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>LR推</p>
<p>写题 </p>
<p>迭代二分，递归二分</p>
<p>关于业务上的问题：</p>
<blockquote>
<p>这边做的主要是召回侧，定向召回，目前也在尝试各种其他方法，主要做的是 look-like（微信看一看的定向投放）</p>
</blockquote>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>项目问题</p>
<p>什么是极大似然估计</p>
<p>什么是中心极限定理</p>
<p>（面试官感觉百度过来的）</p>
<p>写题：</p>
<p>将ip地址转为一个int32的数</p>
<blockquote>
<p>255.255.255.0 是一个字符串 要求最终返回的结果是一个int32</p>
<p>解法就是个位运算， 移位再加下一个</p>
</blockquote>
<p>紧接着 问了一个经典百度问题 hhhh</p>
<p>1T文件，存储的是ip地址，给一个128MB的内存，问如何统计出出现次数最高的前10个</p>
<p>这个问题真的得好好分析一下，现场分析的有点混乱。重点是前面的问题是可以拿过来利用的，就是一个ip地址对应一个唯一的int32  </p>
<blockquote>
<p>提了拆成不同文件，来计数，提了计数后通过堆排来过滤</p>
</blockquote>
<p>再一个问题：</p>
<p>给1，2，3三个数，然后给一个数组，这个数组就是由这三个数组成的，其中某个数可能重复很多，问如何排序</p>
<p>举个栗子[1,2,3,1,2,3,1,2,3] 排序后：[1,1,1,2,2,2,3,3,3]</p>
<blockquote>
<p>当时的思路就是 快排呗…结果被面试官嘲笑了，我就给你限制到这三个数</p>
<p>后来想了下，三个变量来记录1，2，3的个数就可以了，完事之后可以通过计数器，输出相应个数的对应值。</p>
</blockquote>
<p>然后面试题进一步进阶为：</p>
<p>现在不上三个数了，现在有一堆实例，他们都是从一个对象具体来的，比如 一个物体，其中某一个属性的值有1，2，3三种，请根据这个属性值对所有实例进行排序。</p>
<blockquote>
<p>这样就不能用上边的方法了，因为1跟1都是一样的，但是这里只对一个属性就行排，每个实例中除了该属性可能一样，其他都不一样。问怎么排序</p>
</blockquote>
<p>这个回答的就不是很好了</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>之后在网上看到的有人分享的</p>
<p>一面：</p>
<p>1、 给一个有序数组，没有重复值，给一个数组sum，从数组中找出和为sum的两个数，打印出所有可能的组合。</p>
<p>2、 两个字符串的公共子串（连续的）长度。</p>
<p>3、 数据倾斜的一道题。</p>
<p>4、 问wide和deep之间的区别。</p>
<p>5、 问AUC如何计算。</p>
<p>6、 问youtube deep network里面如何解决softmax处理对象数量巨大的问题，提到了霍夫曼树和负采样，然后问负采样怎么回事儿，然后问如何解决大数据量下的负采样。</p>
<p>7、 问youtube deep network里产生了用户和物品向量后，如何应用到在线的，主要想问如何快速获取用户喜欢的物品，是论文题提到的一个工程方法，提前简历好相应的索引。</p>
<p>二面</p>
<p>1、 将一颗二叉树转成双向链表。</p>
<p>2、 用mapreduce或spark实现itemCF中物品相似度的计算。</p>
<p>3、 如何解决L1正则不可导的那一点。</p>
<p>4、 FM和LR的区别，主要讲FM的特点。</p>
<p>5、 问AUC。</p>
<p>6、 问LR为什么不能用MSE，然后引导我回答出来的，先让我写LR的损失，然后让我推导一下使用MSE之后的梯度，观察有什么劣势。</p>
<p>7、 问AdaGrid算法原理及其特点（都是围绕学习率的，我只回答出了一个，实际上有两个，然后面试官给我讲解了一下）。</p>
<p>三面</p>
<p>问第三个项目的几个点：</p>
<p>AUC</p>
<p>线上优化器</p>
<p>神经网络优化器</p>
<p>CTR模型：注重wide&amp;Deep中wide与deep之间的区别</p>
<p>论文</p>
<p>算法题：</p>
<p>K个排序的列表，融合成一个有序列表</p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-11-盛最多水的问题</title>
    <url>/2019/12/10/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="盛最多水的问题"><a href="#盛最多水的问题" class="headerlink" title="盛最多水的问题"></a>盛最多水的问题</h2>]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-148-排序链表</title>
    <url>/2019/12/10/leetcode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4<br>示例 2:</p>
<p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路很简单，基于归并排序过程。那么就涉及到两个过程，一个是划分，一个是合并</p>
<ul>
<li>链表的划分依靠于快慢指针，得到一半一半的链表</li>
<li>链表的合并就是基于合并两个有序链表</li>
</ul>
<p>思路较为简单，但是写的过程有一些小坑，即时避开。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(head)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, head)</span>:</span></span><br><span class="line">      	<span class="comment"># 小坑1：不仅仅要看空指针 还有处理单头  否则会死循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 快慢指针</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        p = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            p = slow</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="comment"># ！！！ 最坑的地方</span></span><br><span class="line">        <span class="comment"># 目的是为了断开链表，一定要通过 next为空来断开</span></span><br><span class="line">        <span class="comment"># 原本写的  tail = slow , slow = None </span></span><br><span class="line">        p.next = <span class="literal">None</span></span><br><span class="line">				</span><br><span class="line">        <span class="comment"># 处理左侧</span></span><br><span class="line">        left = self.helper(head)</span><br><span class="line">        <span class="comment"># 处理右侧</span></span><br><span class="line">        right = self.helper(slow)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#######合并两个有序链表过程#########</span></span><br><span class="line">				<span class="comment"># 哑头，方便处理</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p1 = left</span><br><span class="line">        p2 = right</span><br><span class="line">        p3 = dummy</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val &lt; p2.val:</span><br><span class="line">                p3.next = p1</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p3.next = p2</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            </span><br><span class="line">            p3 = p3.next</span><br><span class="line">        <span class="keyword">if</span> p1:</span><br><span class="line">            p3.next = p1</span><br><span class="line">        <span class="keyword">if</span> p2:</span><br><span class="line">            p3.next = p2</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>也是链表排序，同样满足题意：基于快排的链表排序</p>
<p><a href="https://mereder.github.io/2019/11/25/单链表的快排/" target="_blank" rel="noopener">单链表快排</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-51-N皇后</title>
    <url>/2019/12/09/leetcode-51-N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qs3y3nfhj307607o748.jpg" alt="img"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<blockquote>
<p>示例:</p>
<p>输入: 4<br>输出: [<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p>
<p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]<br>解释: 4 皇后问题存在两个不同的解法。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>刚刚掌握了回溯法的套路，然后就打算拿个hard的题目试试，就发现了这个N皇后问题，发现自己拿回溯法套路完全套不上去，问题出在：</p>
<ul>
<li>递归的是什么？ </li>
<li>状态怎么表示？！！！这个也是最大的问题</li>
</ul>
<p>看完官方题解之后，大呼 秒啊~</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qs80oinhj307e06t0st.jpg" alt="秒啊"></p>
<p>首先说递归的是什么，我们要找的就是皇后的排列位置，也就是说，每一行肯定会放一个皇后，那么具体这个皇后放在哪个位置（哪一列上）就需要通过其他条件来判，比如第一行第一个皇后可以随便放，但是第二行的皇后再放的时候就需要考虑，是否会被前面放置的皇后打到….依次类推，直到最后一行也放置好一个皇后为止。</p>
<p>由此可以看到，回溯的depth是指行数（0——N-1），而在一行内，还需要罗列每一个位置即坐标对从（depth,0）….(depth,N-1)</p>
<p>再看看状态转移怎么表示，我们的目的是找到一种表示，能够来表示，当某一个皇后落位之后，其影响的其他位置都不可以有棋子。</p>
<blockquote>
<p>西洋棋中，皇后的特性是，可以横着，竖着，斜着</p>
</blockquote>
<p>我们已经通过递归的特性使得每一行不会有重复的了，所以我们需要一个表示列的状态，确保每一列只可以有一个。其次，对于斜着，有两个方向，一种是平行于主对角线，另一种是平行于辅对角线。</p>
<p>！！！trick来啦</p>
<p>对于平行于主对角线上的元素，其$row-col$都是一个常量</p>
<blockquote>
<p>举个例子：主对角线上(0,0)(1,1)…(n-1,n-1)    行标-列标=0</p>
<p>那么平行于主对角线的一条比如:(1,0),(2,1)….(n-1,n-2)  行标-列标 = 1</p>
</blockquote>
<p>那么我们只需要确定同一个斜线上只有一个皇后就好了</p>
<p>同样，对于平行于辅对角线，其$row+col$都是一个常量</p>
<p>下面进行我们的操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># 两个trick： 通过这两个trick 可以很快的得出 某一条线路能否放一个皇后</span></span><br><span class="line">        <span class="comment"># 同一条主对角线（平行于主对角线）上的元素，都符合 row-col = constant</span></span><br><span class="line">        <span class="comment"># 同一条副对角线（平行于副对角线）上的元素，都符合 row+col = constant</span></span><br><span class="line">        <span class="comment"># 不在同一列就是通过 列的来判断</span></span><br><span class="line">        stack = []   <span class="comment"># 用来存储一个临时结果</span></span><br><span class="line">        res = []	<span class="comment"># 用来存储最终结果</span></span><br><span class="line">        main_diagonal = [<span class="number">0</span>]*(<span class="number">2</span>*n)  <span class="comment"># 定义的主对角线状态存放</span></span><br><span class="line">        sub_diagonal = [<span class="number">0</span>]*(<span class="number">2</span>*n)		<span class="comment"># 定义辅对角线的状态存放</span></span><br><span class="line">        lie = [<span class="number">0</span>]*n						<span class="comment"># 定义对列的状态存放</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_position</span><span class="params">(row,col)</span>:</span></span><br><span class="line">            lie[col] = <span class="number">1</span></span><br><span class="line">            main_diagonal[row-col] = <span class="number">1</span></span><br><span class="line">            sub_diagonal[row+col] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">remove_positon</span><span class="params">(row,col)</span>:</span></span><br><span class="line">            lie[col] = <span class="number">0</span></span><br><span class="line">            main_diagonal[row-col] = <span class="number">0</span></span><br><span class="line">            sub_diagonal[row+col] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(row,col)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> (lie[col]+main_diagonal[row-col]+sub_diagonal[row+col]) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_result</span><span class="params">()</span>:</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="comment"># i 行 j列</span></span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> sorted(stack):</span><br><span class="line">                tmp.append(<span class="string">'.'</span>*j+<span class="string">'Q'</span>+<span class="string">'.'</span>*(n-j<span class="number">-1</span>))</span><br><span class="line">            res.append(tmp)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack1</span><span class="params">(row)</span>:</span></span><br><span class="line">            <span class="comment"># 逐行确定，每一行肯定可以确定一个位置（列）</span></span><br><span class="line">            <span class="comment"># 下面就是经典的回溯框架（套路）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n): </span><br><span class="line">              	<span class="comment"># 1. 检查是否满足可以进入的条件（本题就是可以放置皇后）</span></span><br><span class="line">                <span class="keyword">if</span> check(row, i):</span><br><span class="line">                  	<span class="comment"># 2. 将可以的结果加入stack中进行记录</span></span><br><span class="line">                    stack.append((row, i))</span><br><span class="line">                    <span class="comment"># 3. 记录状态加入</span></span><br><span class="line">                    add_position(row, i)</span><br><span class="line">										<span class="comment"># 4. 对于是否满足条件，如果满足条件则将结果进行输出</span></span><br><span class="line">                    <span class="comment">#    不满足继续进行递归</span></span><br><span class="line">                    <span class="keyword">if</span> row == n<span class="number">-1</span>:</span><br><span class="line">                        add_result()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        backtrack(row+<span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 5. 回弹过程，拿掉前面加入的记录</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                    <span class="comment"># 6. 更改记录状态</span></span><br><span class="line">                    remove_positon(row,i)</span><br><span class="line">         </span><br><span class="line">        <span class="comment"># 回溯更经常将递归结束条件写在外边</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">backtrack2</span><span class="params">(row)</span>:</span></span><br><span class="line">            <span class="comment"># 1. 递归结束条件</span></span><br><span class="line">            <span class="keyword">if</span> row == n:  <span class="comment"># !!!!注意这个地方与上边的区别，</span></span><br><span class="line">                add_result()</span><br><span class="line">                <span class="keyword">return</span>    </span><br><span class="line">            <span class="comment"># 逐行确定，每一行肯定可以确定一个位置（列）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n): </span><br><span class="line">                <span class="comment"># 2. 检查是否满足可以进入的条件（本题就是可以放置皇后）</span></span><br><span class="line">                <span class="keyword">if</span> check(row, i):</span><br><span class="line">                  	<span class="comment"># 3. 将可以的结果加入stack中进行记录</span></span><br><span class="line">                    stack.append((row, i))</span><br><span class="line">                    <span class="comment"># 4. 记录状态加入</span></span><br><span class="line">                    add_position(row, i)</span><br><span class="line">										<span class="comment"># 5. 递归下一层</span></span><br><span class="line">                    backtrack(row+<span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 6. 回弹过程，拿掉前面加入的记录</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                    <span class="comment"># 7. 更改记录状态</span></span><br><span class="line">                    remove_positon(row,i)</span><br><span class="line"></span><br><span class="line">        backtrack1(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># backtrack2(0)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>专业书籍书单</title>
    <url>/2019/12/09/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<h2 id="专业书籍书单"><a href="#专业书籍书单" class="headerlink" title="专业书籍书单"></a>专业书籍书单</h2><p>如果仔细的品味完这些书，保证自己的能力能得到质的飞越！！！</p>
<h3 id="基本刷题"><a href="#基本刷题" class="headerlink" title="基本刷题"></a>基本刷题</h3><ul>
<li>[ ] Leetcode（147/1200）</li>
<li>[x] 剑指offer</li>
<li>[ ] 编程思想</li>
</ul>
<h3 id="机器学习大方向"><a href="#机器学习大方向" class="headerlink" title="机器学习大方向"></a>机器学习大方向</h3><ul>
<li>[ ] 统计学习方法</li>
<li>[ ] 机器学习（西瓜书）</li>
<li><p>[ ] 百面机器学习</p>
</li>
<li><p>[ ] 强化学习精要</p>
</li>
</ul>
<h3 id="算法工程师基本技能"><a href="#算法工程师基本技能" class="headerlink" title="算法工程师基本技能"></a>算法工程师基本技能</h3><ul>
<li><p>编程语言</p>
<ul>
<li>python 核心编程</li>
<li>java ？？？ </li>
</ul>
</li>
<li><p>大数据方向</p>
</li>
<li><p>[ ] Spark内核机制解析以及性能调优</p>
</li>
<li><p>[ ] Hive编程指南</p>
</li>
</ul>
<h3 id="其他维度的培养"><a href="#其他维度的培养" class="headerlink" title="其他维度的培养"></a>其他维度的培养</h3><ul>
<li>[ ] 产品思维</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>机器学习中的评价指标——ROC,AUC</title>
    <url>/2019/12/09/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87AUC/</url>
    <content><![CDATA[<h2 id="ROC"><a href="#ROC" class="headerlink" title="ROC"></a>ROC</h2><p>ROC曲线是 receiver operating characteristic curve的简称。（受试者工作特征曲线）</p>
<p>其横坐标为<strong>假阳性率(False Positive Rate,FPR)</strong>， 纵坐标为<strong>真阳性率(True Positive Rate, TPR)</strong></p>
<script type="math/tex; mode=display">
FPR = \frac{FP}{N} \\
TPR = \frac{TP}{P} \\</script><p>对于假阳性率、真阳性率，需要一点实际例子来进行理解。拿我之前做过的识别三俗文章的例子来理解。对于一批样本100个，其中三俗文章（正例）有6篇，非三俗文章（负例）94篇，我们建立一个简单的文本分类模型来识别这批数据，我们分类器的结果是，100篇中，判为三俗的有8篇，但是真正三俗的仅为5篇，剩余92篇均判为非三俗，其中有1篇判错。</p>
<p>模型整体准确率为：</p>
<script type="math/tex; mode=display">
\frac{5+91}{100} = 96\%</script><p>针对三俗类别来说的精确率为:</p>
<script type="math/tex; mode=display">
\frac{5}{8} = 62.5\% \\ 
即 分类正确的正样本个数占分类器判定为正样本个数的比例</script><p>针对三俗类别来说的召回率为:</p>
<script type="math/tex; mode=display">
\frac{5}{6} = 83.3\% 
即分类正确的正样本个数占实际正样本个数的比例</script><p>假阳性率为:</p>
<script type="math/tex; mode=display">
FPR = \frac{3}{94}  \\
即 被误判为三俗的样本，占真实非三俗样本总数的比例</script><p>真阳性率为：</p>
<script type="math/tex; mode=display">
TPR = \frac{5}{6} \\
即分类正确的三俗样本，占实际三俗样本个数的比例，跟召回率一样</script><h3 id="如何绘制ROC曲线"><a href="#如何绘制ROC曲线" class="headerlink" title="如何绘制ROC曲线"></a>如何绘制ROC曲线</h3><p>关键点在于：<strong>每个截断点都对于一个TPR和FPR</strong></p>
<p>绘制ROC曲线的过程，就是不断枚举截断点（分类阈值）的过程，通过动态调整截断点，从最高分的得分开始，逐渐调整到最低点，其中每一个截断点都对应一个坐标（FPR,TPR），将这些点连成线就构成了ROC曲线。</p>
<h2 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h2><p> AUC即 area under curve ,指的是ROC曲线下的面经，该值能够量化地反映基于ROC曲线衡量出的模型性能。AUC一般取值0.5-1之间，AUC越大，说明分类器越可能把真正的正样本排在前面，分类性能越好。</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-46-全排列</title>
    <url>/2019/12/09/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="Leetcode-46-全排列"><a href="#Leetcode-46-全排列" class="headerlink" title="Leetcode-46-全排列"></a>Leetcode-46-全排列</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>回溯方法</strong>：“不撞南墙不回头”</p>
<ul>
<li><p>思考怎么撞到南墙——通过递归来达到</p>
</li>
<li><p>思考回溯的“南墙”是什么——递归的终止条件</p>
</li>
<li>思考回头的话怎么回头——状态记录</li>
</ul>
<blockquote>
<p>res: 结果集，[[],[],[]…] 的数据形式</p>
<p>used: 用来进行状态记录，使用过的将不能再使用，用来保证全排列过程，前面出现的字符，后边不在出现</p>
<p>stack: 用来存放结果，其中包含了回溯的加入和回退过程，</p>
<p>depth: 用来记录递归的深度（全排列字符串的个数），当depth等于字符串长度时，也就是某一种排列形成，我们将其排列结果加入到结果集中</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span>  <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        used = [<span class="literal">False</span>]*len(nums)</span><br><span class="line">        stack = []</span><br><span class="line">        self.helper(res,stack,<span class="number">0</span>, nums, used)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, res, stack, depth, nums, used)</span>:</span></span><br><span class="line">        <span class="comment"># 迭代出口  回溯所说的：撞到南墙</span></span><br><span class="line">        <span class="keyword">if</span> depth == len(nums):</span><br><span class="line">            res.append(stack.copy()) <span class="comment"># 需要copy否则stack是动态变化的 会在res中变化</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">              	<span class="comment"># 不断前进过程</span></span><br><span class="line">                stack.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">								<span class="comment"># 递归操作，递归深度不断加深</span></span><br><span class="line">                self.helper(res,stack,depth+<span class="number">1</span>,nums,used)</span><br><span class="line">								<span class="comment"># 一旦撞到南墙，则开始回头</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-17-电话号码的组合</title>
    <url>/2019/12/08/leetcode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="电话号码的组合"><a href="#电话号码的组合" class="headerlink" title="电话号码的组合"></a>电话号码的组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pj84tjdlj30dv0ckdhp.jpg" alt="img"></p>
<p>示例:</p>
<p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先肯定需要一个映射表的，来映射数字到字母组的关系。</p>
<p>其次，根据数字的顺序，字母也是有前后顺序的。感觉上写几层循环枚举就可以解决了，但是进一步发现，循环的层数是不确定的，所以用递归来解决。</p>
<p>递归：</p>
<ul>
<li>递归的出口就是，生成的字符串长度与数字长度相等</li>
<li>每次递归的操作：<ul>
<li>将字符拼入待生成字符串</li>
<li>递归进入下一层，将当前生成字符串传入，且数字字符串向下移动一位</li>
<li>将拼入的字符删掉（回溯的过程）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        table = &#123;<span class="string">'2'</span>:<span class="string">'abc'</span>,</span><br><span class="line">                 <span class="string">'3'</span>:<span class="string">"def"</span>,</span><br><span class="line">                 <span class="string">'4'</span>:<span class="string">"ghi"</span>,</span><br><span class="line">                 <span class="string">'5'</span>:<span class="string">"jkl"</span>,</span><br><span class="line">            		 <span class="string">'6'</span>:<span class="string">"mno"</span>,</span><br><span class="line">                 <span class="string">'7'</span>:<span class="string">"pqrs"</span>,</span><br><span class="line">                 <span class="string">'8'</span>:<span class="string">"tuv"</span>,</span><br><span class="line">                 <span class="string">'9'</span>:<span class="string">"wxyz"</span>&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(table,res, <span class="string">''</span>,digits,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, table, res, string, digits,index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(string) == len(digits):</span><br><span class="line">            res.append(string)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        tmp = string</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> table[digits[index]]:</span><br><span class="line">            tmp += ch</span><br><span class="line">            self.helper(table,res,tmp,digits,index+<span class="number">1</span>)</span><br><span class="line">            tmp = tmp[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>剑指</strong>上面记得有一段，大部分递归问题都可以通过画成树状结构来进行分析。其实这个题也是，从根到叶子节点的一条完整路径就是一个可能的结果。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-647-回文子串</title>
    <url>/2019/12/08/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p>示例 1:</p>
<p>输入: “abc”<br>输出: 3<br>解释: 三个回文子串: “a”, “b”, “c”.<br>示例 2:</p>
<p>输入: “aaa”<br>输出: 6<br>说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”.<br>注意:</p>
<p>输入的字符串长度不会超过1000。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>处理回文问题最好用的一个方式就是中心扩散，即从中间向两边扩散。</p>
<p>扩散的过程不仅可以记录回文子串内容，还可以记录长度，还可以记录个数（只要始末位置不一样就算一个回文串）</p>
<p>本题就是让字符串中每一个字符都当一次中心，然后通过中心扩散来统计不同回文串的个数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> center <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            count += self.centerSpread(s,center,center) <span class="comment"># 奇数对称</span></span><br><span class="line">            count += self.centerSpread(s,center,center+<span class="number">1</span>) <span class="comment"># 偶数对称</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">centerSpread</span><span class="params">(self, s,l,r)</span>:</span> <span class="comment"># 中心扩散</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&gt;=<span class="number">0</span> <span class="keyword">and</span> r &lt; len(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l-=<span class="number">1</span></span><br><span class="line">            r+=<span class="number">1</span></span><br><span class="line">            count+=<span class="number">1</span> <span class="comment"># 起止位置不同就算一个</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-18-四数之和</title>
    <url>/2019/12/08/leetcode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p>
<p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跟三数之和思路是一样的，我们复习下：</p>
<blockquote>
<p>三数之和中，我们先通过预排序，让数组有序。然后固定一个数，然后移动剩下的两个数（双指针）</p>
<p>即：预排序+固定一个+双指针</p>
</blockquote>
<p>对于四数之和，我们采用同样的方案，只不过这里需要更改的是，我们固定<strong>两个数</strong></p>
<ul>
<li>特判，特殊情况直接处理</li>
<li>预排序</li>
<li>固定一个数a<ul>
<li>处理相同情况</li>
<li>再固定一个数b<ul>
<li>处理b的相同情况</li>
<li>定义双指针</li>
<li>双指针进行移动<ul>
<li>4sum == target添加结果</li>
<li>4sum &lt; target: 移动左指针</li>
<li>4sum &gt; target: 移动右指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> range(n<span class="number">-3</span>):</span><br><span class="line">            <span class="keyword">if</span> a &gt; <span class="number">0</span> <span class="keyword">and</span> nums[a] == nums[a<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> range(a+<span class="number">1</span>,n<span class="number">-2</span>):</span><br><span class="line">                <span class="keyword">if</span> b &gt; a+<span class="number">1</span> <span class="keyword">and</span> nums[b] == nums[b<span class="number">-1</span>]: <span class="comment"># 注意条件，一定是b &gt;a+1不能跟a再比较</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                l = b+<span class="number">1</span></span><br><span class="line">                r = n<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    <span class="keyword">if</span> nums[a]+nums[b]+nums[l]+nums[r] == target:</span><br><span class="line">                        res.append([nums[a],nums[b],nums[l],nums[r]])</span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l+<span class="number">1</span>]:</span><br><span class="line">                            l+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r<span class="number">-1</span>]:</span><br><span class="line">                            r-=<span class="number">1</span></span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">                        r-=<span class="number">1</span>  </span><br><span class="line">                    <span class="keyword">elif</span> nums[a]+nums[b]+nums[l]+nums[r] &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: </span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-992-K个不同整数的子数组</title>
    <url>/2019/12/08/leetcode-992-K%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="K个不同整数的子数组"><a href="#K个不同整数的子数组" class="headerlink" title="K个不同整数的子数组"></a>K个不同整数的子数组</h2><p>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。</p>
<p>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）</p>
<p>返回 A 中好子数组的数目。</p>
<blockquote>
<p>示例 1：</p>
<p>输出：A = [1,2,1,2,3], K = 2<br>输入：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].<br>示例 2：</p>
<p>输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</p>
</blockquote>
<p>提示：</p>
<blockquote>
<p>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= A.length<br>1 &lt;= K &lt;= A.length</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>方案比较巧妙的办法是：</p>
<p>K个不同整数的子数组 = 用至多K个不同整数的结果 -  至多K-1个不同整数的结果</p>
<blockquote>
<p>以【1，2，3】为例，K=3时候，</p>
<p>至多K个包含:[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]</p>
<p>至多K-1个包含: [1],[2],[3],[1,2],[2,3],[1,3]</p>
<p>做差结果 就是 [1,2,3]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithKDistinct</span><span class="params">(self, A: <span class="string">'List[int]'</span>, K: <span class="string">'int'</span>)</span> -&gt; 'int':</span></span><br><span class="line">        <span class="keyword">return</span> self.subarraysWithAtMostKDistinct(A, K) - </span><br><span class="line">      										self.subarraysWithAtMostKDistinct(A, K<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithAtMostKDistinct</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        lookup = collections.defaultdict(int) <span class="comment"># 字典记录整数情况，为1是表示出现一次，为0表示没有</span></span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:   <span class="comment"># 通过右移来扩展 包含不同整数</span></span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &gt; k: <span class="comment"># 一旦满足k个就进行左移，循环跳出的时候，正好是K个不同整数</span></span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res += r - l </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>还没搞懂</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-6-Z字形变换</title>
    <url>/2019/12/07/leetcode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<blockquote>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<p>L   C   I   R<br>E T O E S I I G<br>E   D   H   N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
</blockquote>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p>string convert(string s, int numRows);</p>
<blockquote>
<p>示例 1:</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”<br>示例 2:</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:</p>
<p>L       D      R<br>E   O E    I  I<br>E C    I H   N<br>T       S      G</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这种题上来就先模拟下这个的生成过程，模拟过程中就能找到一定的规律：</p>
<ul>
<li>先从上下下，再从下向上</li>
<li>总是在 0行或者 n-1行转换反向</li>
<li>不要受Z字形诱导，最后的输出结果就是按行从上到下将字符串拼接</li>
</ul>
<p>举个例子：</p>
<blockquote>
<p>LEETCODEISHIRING </p>
<p>结果是：</p>
<p>L    C      I     R<br>E T O E  S  I  I G<br>E    D     H    N</p>
<p>过程1：</p>
<p>L</p>
<p>E</p>
<p>E</p>
<p>过程2换方向：</p>
<p>LC</p>
<p>ET</p>
<p>E</p>
<p>再换方向：</p>
<p>LC</p>
<p>ETO</p>
<p>ED</p>
<p>依次类推最终结果是：</p>
<p>LCIR<br>ETOESIIG<br>EDHN</p>
<p>最终按行输出就是：</p>
<p>LCIRETOESIIGEDHN</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        direction = <span class="literal">False</span> <span class="comment"># True 为向下，False向上</span></span><br><span class="line">        res = [<span class="string">''</span>]*numRows</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            res[row] += ch <span class="comment"># 字符串直接把字符接到后边</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">0</span> <span class="keyword">or</span> row == numRows<span class="number">-1</span>: <span class="comment"># 看是否需要换方向</span></span><br><span class="line">                direction = <span class="keyword">not</span> direction</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> direction: <span class="comment"># True 为向下，False向上</span></span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row -= <span class="number">1</span></span><br><span class="line">				<span class="comment"># 结果按行拼接起来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-5-最长回文子串</title>
    <url>/2019/12/07/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<blockquote>
<p>示例 1：</p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p>
<p>输入: “cbbd”<br>输出: “bb”</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先判断一个字符串是不是回文字符串，就是看该字符串是否是中心对称的。</p>
<ul>
<li>奇数个时:   aba对称</li>
<li>偶数个时：aa对称</li>
</ul>
<p>现在是从一个字符串中，找出最长的回文字符子串，只需要遍历一遍字符串，假设每个位置都是一个回文子串的中心，然后根据是否是回文串来验证，记录长度最大的回文子串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            oddsres = self.helper(s, i, i)</span><br><span class="line">            evenres = self.helper(s, i, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mx &lt; len(oddsres):</span><br><span class="line">                mx = len(oddsres)</span><br><span class="line">                res = oddsres</span><br><span class="line">            <span class="keyword">if</span> mx &lt; len(evenres):</span><br><span class="line">                mx = len(evenres)</span><br><span class="line">                res = evenres</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, s, i, j)</span>:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">-1</span> <span class="keyword">and</span> j &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                res = s[i:j + <span class="number">1</span>]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># i和j 已经不等了</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>分析：总的遍历为o(N)，两种对称方式的遍历为o(2N)，总的时间复杂度为o(N^2)</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口问题</title>
    <url>/2019/12/07/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B3%BB%E5%88%97%E9%A2%98%E7%BB%84/</url>
    <content><![CDATA[<h2 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a>滑动窗口问题</h2><p>题组：</p>
<ul>
<li>[x] 3.无重复字符的最长子串</li>
<li>[ ] 30.串联所有单词的子串</li>
<li>[x] 76.最小覆盖子串</li>
<li>[ ] 159.至多包含两个不同字符的最长子串</li>
<li>[ ] 209.长度最小的子数组</li>
<li>[ ] 239.滑动窗口最大值</li>
<li>[ ] 567.字符串的排列</li>
<li>[ ] 632.最小区间</li>
<li>[ ] 727.最小窗口子序列</li>
<li>[ ] 992.有k个不同整数的子数组</li>
</ul>
<p>For <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        lookup = collections.defaultdict(int)</span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &lt; r - l:</span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res, r - l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>For <a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank" rel="noopener">159. Longest Substring with At Most Two Distinct Characters</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lookup = collections.defaultdict(int)</span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &gt; <span class="number">2</span>:</span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res, r - l) </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>For <a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">340. Longest Substring with At Most K Distinct Characters</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lookup = collections.defaultdict(int)</span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &gt; k:</span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res, r - l) </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>For <a href="https://leetcode.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener">992. Subarrays with K Different Integers</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithKDistinct</span><span class="params">(self, A: <span class="string">'List[int]'</span>, K: <span class="string">'int'</span>)</span> -&gt; 'int':</span></span><br><span class="line">        <span class="keyword">return</span> self.subarraysWithAtMostKDistinct(A, K) - self.subarraysWithAtMostKDistinct(A, K<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithAtMostKDistinct</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        lookup = collections.defaultdict(int)</span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &gt; k:</span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res += r - l </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://mp.weixin.qq.com/s/6YeZUCYj5ft-OGa85sQegw" target="_blank" rel="noopener">五分钟学算法-滑动窗口</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-76-最小覆盖子串</title>
    <url>/2019/12/07/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</p>
<blockquote>
<p> 示例：</p>
<p>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”<br>说明：</p>
<p>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口，基本思想分为两步：</p>
<ul>
<li>滑动窗口右边界，产生可能的解（子串）</li>
<li>再滑动窗口左边界，优化产生的解，让解尽可能小</li>
</ul>
<p>基本套路：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">		window.add(s[right])  <span class="comment"># 右侧不断扩展过程</span></span><br><span class="line">		right+=<span class="number">1</span></span><br><span class="line"> 		...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> 满足条件的解:   <span class="comment"># 直到处理的结果不再满足条件</span></span><br><span class="line">      	left-right 作为结果</span><br><span class="line">    		window.remove(s[left])</span><br><span class="line">        left+=<span class="number">1</span>					<span class="comment"># 满足条件下，左侧不断收缩过程</span></span><br></pre></td></tr></table></figure>
<p>滑动窗口适用解决的问题：</p>
<blockquote>
<p>跟字符串相关的匹配问题，求最优（最长或者最小串）</p>
</blockquote>
<p>对应到本题上，我们要求的最小覆盖子串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        window = defaultdict(int)</span><br><span class="line">        needs = defaultdict(int)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> t:</span><br><span class="line">            needs[ch] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>   <span class="comment"># 左边界</span></span><br><span class="line">        r = <span class="number">0</span>		<span class="comment"># 右边界</span></span><br><span class="line">        match = <span class="number">0</span></span><br><span class="line">        mn = <span class="number">999999999</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):  <span class="comment"># 右边界不断扩，直到结尾</span></span><br><span class="line">            ch = s[r]</span><br><span class="line">            <span class="comment">#右移过程##################################</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> needs:</span><br><span class="line">                window[ch] += <span class="number">1</span>  <span class="comment"># 只记录待匹配字母</span></span><br><span class="line">                <span class="keyword">if</span> window[ch] == needs[ch]:</span><br><span class="line">                    match += <span class="number">1</span>  <span class="comment"># 右移过程记录匹配到的个数</span></span><br><span class="line">            r += <span class="number">1</span>  <span class="comment"># 右移一次</span></span><br><span class="line">            <span class="comment">##########################################</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> match == len(needs):  <span class="comment"># 条件：当前匹配的个数 等于 需求匹配的个数</span></span><br><span class="line">                <span class="keyword">if</span> mn &gt; r - l:  <span class="comment"># 与最优结果比较，更新我们的最优结果</span></span><br><span class="line">                    mn = r - l</span><br><span class="line">                    res = s[l:r]</span><br><span class="line">                <span class="comment">#左移过程##################################</span></span><br><span class="line">                <span class="keyword">if</span> s[l] <span class="keyword">in</span> needs:  <span class="comment"># 左侧是待匹配的字母，进行左移时，进行记录</span></span><br><span class="line">                    window[s[l]] -= <span class="number">1</span> <span class="comment"># </span></span><br><span class="line">                    <span class="keyword">if</span> window[s[l]] &lt; needs[s[l]]:</span><br><span class="line">                        match -= <span class="number">1</span>   <span class="comment"># 这里会打破条件，导致不匹配，说明不能继续左移了，跳出再右移</span></span><br><span class="line">                l += <span class="number">1</span> <span class="comment"># 左移一次</span></span><br><span class="line">                <span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们也能清楚的感受到，用####标注出来的两个部分基本就是我们的左移和右移的过程，不过需要带着这个题的理解进行使用。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-32-最长有效括号</title>
    <url>/2019/12/06/leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:</p>
<p>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="简单粗暴没通过"><a href="#简单粗暴没通过" class="headerlink" title="简单粗暴没通过"></a>简单粗暴没通过</h4><p>上来最简单的肯定是 暴力解法啊，就是罗列所有可能的字符情况，然后逐个判断是否有效。</p>
<p>然后就挂了… 超出时间限制，case中218/230，有一部分通不过。于是想了几个简单的优化方法</p>
<ul>
<li>有效字符串肯定是以’(‘开头，以’)’结尾</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s: 空返回</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> len(s)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">')'</span>:</span><br><span class="line">                    count-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> count == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 枚举的过程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>: <span class="comment"># 优化</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(s)):</span><br><span class="line">                    <span class="keyword">if</span> s[j] == <span class="string">')'</span>:  <span class="comment"># 优化</span></span><br><span class="line">                        <span class="keyword">if</span> valid(s[i:j+<span class="number">1</span>]):</span><br><span class="line">                            l = j-i+<span class="number">1</span></span><br><span class="line">                            mx = max(mx,l)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
<h4 id="最优化想到dp"><a href="#最优化想到dp" class="headerlink" title="最优化想到dp"></a>最优化想到dp</h4><p>首先由于括号匹配的特殊性，最长的有效括号肯定是以’)’结尾的，所以我们只需要dp来统计’)’为尾的情况的最大值。</p>
<p>然后就需要考虑下转移状态，也就是说第i个位置以’)结尾’的最长有效长度怎么计算的问题：</p>
<p>只需要考虑两种情况，即i-1位置是’(‘还是’)’：</p>
<p>当i-1位置为’(‘：</p>
<blockquote>
<p>那么构成 ….()，肯定是在前面的基础上能+2，前面如果都无效那就是0+2，前面如果也有效就是前面的长度+2。这里所说的前面就是 dp[i-2]的结果</p>
</blockquote>
<p>当i-1位置为’)’:</p>
<blockquote>
<p>那么就构成….))，这个怎么计算有效呢？就需要参考dp[i-1]的长度，实际问题就变成了….(有效))，如果前面有效的子串前面还有个’(‘那就可以在前面有效子串的基础上长度+2，<strong>注意</strong>，还需要再加上再前面的有效子串的长度，举个栗子！！！<br>01234567<br>( ) ( (  ) ( ) )，当第7位时，由于第6位是’)’，且第6位已经计算好了结果为dp[6]=4，即从下标3，4，5，6这四个有效长度，此时计算第七位时，会直接用： 当前位置7-前面有效长度4-1=2，此时下标2为’(‘，与7匹配上，所以后边总的有效长度为 4+2，此时！！！ 前面也是有效的括号即dp[1]=2，那么总的结果应该是4+2+2</p>
<p>即dp[7] = dp[6]+2+dp[7-dp[6]-2]</p>
<p>(有空了一定画个图)</p>
</blockquote>
<ul>
<li>以’)’结尾考虑：<ul>
<li>其前一位为’(‘: dp[i] = dp[i-2] + 2</li>
<li>其前一位为’)’ 且 i-dp[i-1] -1 为’(‘：dp[i] = dp[i-1]+2 + dp[i-dp[i-1]-2]</li>
</ul>
</li>
<li>以’(‘结尾不考虑</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>]*len(s)</span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">')'</span>: <span class="comment"># 只需要判断 ')即可'</span></span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    <span class="keyword">if</span> i<span class="number">-2</span> &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[i] = dp[i<span class="number">-2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> s[i<span class="number">-1</span>] == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i-dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>:</span><br><span class="line">                      	<span class="comment"># dp[i-1]+2表示新形成的有效子串长度，dp[i-dp[i-1]-2]表示之前有效子串</span></span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span> + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]</span><br><span class="line">                        </span><br><span class="line">                mx = max(mx,dp[i])</span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
<p>其实最后只要中间过程的最大值，所以不会像一般dp过程，dp数组的最后一个元素才是结果。</p>
<h4 id="更优的解法"><a href="#更优的解法" class="headerlink" title="更优的解法"></a>更优的解法</h4><p>从左向右遍历一次，遇到’(‘，left++，遇到’)’，right++，当left==right时，取max(2*left,max),当right&gt;left，说明字符串无效，令left=right = 0</p>
<p>上述过程再从右向左重复一次，不同之处是，从右向左过程，当left&gt;right时，说明字符串无效，令left=right=0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从左到右</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                mx = max(left*<span class="number">2</span>,mx)</span><br><span class="line">            <span class="keyword">elif</span> right &gt; left:</span><br><span class="line">                left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从右到左</span></span><br><span class="line">        left,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                mx = max(left*<span class="number">2</span>,mx)</span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                left,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-20-有效括号</title>
    <url>/2019/12/06/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: “()”<br>输出: true<br>示例 2:</p>
<p>输入: “()[]{}”<br>输出: true<br>示例 3:</p>
<p>输入: “(]”<br>输出: false<br>示例 4:</p>
<p>输入: “([)]”<br>输出: false<br>示例 5:</p>
<p>输入: “{[]}”<br>输出: true</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先说只有一种类型的括号的话，我们的解决方案（这也是<a href="https://mereder.github.io/2019/11/29/leetcode-22-括号生成/" target="_blank" rel="noopener">Leetcode-22-括号生成</a>题目中的一个步骤）。</p>
<p>如果只有一种括号，我们在遍历字符串的时候，只需要注意两个问题：</p>
<ul>
<li>遍历过程中 左边个数&gt;=右边个数</li>
<li>遍历结束后 左边个数 == 右边个数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(s)</span>:</span></span><br><span class="line">  	count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">      <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">      <span class="keyword">elif</span> i == <span class="string">')'</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">   	<span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>对应这个问题，上述方法就行不通了，因为涉及到三种不同的符号，单考虑一种括号的顺序正确是没用的，还需要考虑到括号之间的交叉，比如:</p>
<blockquote>
<p>{ [ } ]</p>
</blockquote>
<p>单个符号的顺序没有问题，但是总的就是不正确的括号。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n5vtuvdhj30v40h2myu.jpg" alt="Leetcode官方解答"></p>
<p>我们可以看到，如果一整个字符串都是有效的，那么其子字符串肯定也是有效的，那么最小的子问题就是一对相邻括号是匹配的。</p>
<p>那么可以通过删除掉匹配到的括号，逐步将问题解决。具体操作。</p>
<p><strong>（图来自Leetcode官方解答，他们的图画的真的好，就拿过来了）</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n66bcjb7j30ls04ct8u.jpg" alt="image-20191206181715420"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n675t327j30i404m3yp.jpg" alt="image-201912061817155"></p>
<p>这样可以通过栈来解决，匹配到的就出栈，否则就进栈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> a==<span class="string">'('</span> <span class="keyword">and</span> b == <span class="string">')'</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">'['</span> <span class="keyword">and</span> b == <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">'&#123;'</span> <span class="keyword">and</span> b == <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(s[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> match(stack[<span class="number">-1</span>], s[i]):</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-26-删除排序数组中的重复项</title>
    <url>/2019/12/05/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<blockquote>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>说明:</p>
<p> 为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:(引用问题嘛，传值传引用)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>虽然是个easy的题，但是一开始确实没有很好的思路，其实每次做数组的题老是不会灵活的使用指针（也就是数组的下标），每次都是只有依次遍历的指针。没有灵活使用</p>
<p>这个题使用两个指针(i慢，j快)</p>
<ul>
<li>i指针用来指示有效数字（即无重复数）</li>
<li>j指针用来遍历数组所有数，重复就跳过，不重复就赋值到 i+1</li>
</ul>
<p>比较好的是数组是排好序的，所以单次遍历就能把重复数都找出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != nums[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-81-搜索旋转的排序数组II</title>
    <url>/2019/12/05/leetcode-81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</url>
    <content><![CDATA[<h2 id="搜索旋转的排序数组ii"><a href="#搜索旋转的排序数组ii" class="headerlink" title="搜索旋转的排序数组ii"></a>搜索旋转的排序数组ii</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<p>示例 1:</p>
<p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true<br>示例 2:</p>
<p>输入: nums = [2,5,6,0,0,1,2], target = 3<br>输出: false<br>进阶:</p>
<p>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>变数是出现<strong>重复的数</strong>了</p>
<p>原本的思路是：</p>
<ul>
<li><p>如果 mid == target 直接返回</p>
</li>
<li><p>前半部有序（指的是[3,4,5,6,7,0,12]，中间划开前面是[3,4,5,6]有序，后边是[7,0,1,2]不完全有序）</p>
<ul>
<li>target落在有序序列，即left—-mid中，则查找这个范围所以right = mid-1</li>
<li>target落在无序序列，即mid—right中，则left = mid+1</li>
</ul>
</li>
<li>后半部有序（指的是[6,7,0,1,2,3,4,5],中间划开，前面是[6,7,0,1]不完全有序，后边是[2,3,4,5]有序）<ul>
<li>target落在无序序列，即left—-mid中，则查找这个范围所以right = mid-1</li>
<li>target落在有序序列，即mid—right中，则left = mid+1</li>
</ul>
</li>
</ul>
<p>当出现重复的数字，如果不出现在两端还好，没有影响</p>
<p>原本只需要判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:  <span class="comment"># 命中 返回</span></span><br><span class="line">    <span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt;= nums[left]:  <span class="comment"># mid的位置，mid落在前半部还是后半部</span></span><br><span class="line">    <span class="string">'''前半部有序的操作'''</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="string">'''后半部有序的操作'''</span></span><br></pre></td></tr></table></figure>
<p>但是对应有重复数的出现，可能会存在下面的情况，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left == mid == right </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] <span class="keyword">or</span> [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>此时分不清到底是前半部分有序还是后半部分有序，但是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left == mid == right 一定 != target</span><br></pre></td></tr></table></figure>
<p>因为我们先判断了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:  <span class="comment"># 命中 返回</span></span><br><span class="line">		<span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure>
<p>既然左left右right 都不等，我们干脆往中间移动，去掉干扰项即可，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] <span class="number">1</span> <span class="keyword">or</span> <span class="number">5</span> [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>操作之后，问题也就回到了我们熟悉的问题上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 不能确定哪一侧有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == nums[mid] == nums[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 在左侧序列，左侧是有序的</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt;= nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[left]&lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid <span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 在右侧序列，右侧是有序的</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>新聚思（Synnex）</title>
    <url>/2019/12/04/Synnex/</url>
    <content><![CDATA[<h1 id="synnax实习总结"><a href="#synnax实习总结" class="headerlink" title="synnax实习总结"></a>synnax实习总结</h1><p>问题：</p>
<p>lr 推 还可以</p>
<p>svm推 …</p>
<p>xgboost 推…</p>
<p>编程：</p>
<p>kmeans  </p>
<p>堆排序</p>
<p>鸡蛋落地问题</p>
<p>概率题：  </p>
<p>圆上3点 构成锐角三角形的概率</p>
<p>spark  </p>
<p>完全阵亡</p>
<p>实际业务场景应用问题</p>
<p>文本分类 的全流程</p>
<p><strong>以上问题都是笔试题（是的我在现场笔试了一个小时）</strong></p>
<p>其他一些细节问题</p>
<p>transformer 的问题 每个细节问题 </p>
<p>mutil过程具体怎么操作的  </p>
<p>为啥除以dk</p>
<p>add 和norm 具体操作 为什么 有什么作用</p>
<p>decoder中 的mask Attention 怎么操作的</p>
<p>实习问题：</p>
<p>1.薪资问题  </p>
<p>实习薪资：保密 :smile_cat:</p>
<p>2.团队规模 </p>
<p>400人左右 其中it技术100多人， 算法团队20人这样吧</p>
<p>有transfer北美的机会</p>
<p>3.发展问题</p>
<p>工程师会需要有夜班嘛 对应时差 </p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>京东搜索排序面经-已过</title>
    <url>/2019/12/04/%E4%BA%AC%E4%B8%9C%E6%90%9C%E7%B4%A2%E6%8E%92%E5%BA%8F%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="京东搜索排序面经"><a href="#京东搜索排序面经" class="headerlink" title="京东搜索排序面经"></a>京东搜索排序面经</h2><h3 id="jd"><a href="#jd" class="headerlink" title="jd"></a>jd</h3><p>招聘岗位：算法实习生（能获得导师许可并保证至少6个月的实习）</p>
<p>工作地点：北辰世纪中心，位于北京朝阳区奥林匹克公园附近</p>
<p>【工作内容】</p>
<ol>
<li>基于京东海量的用户和商家数据，应用机器学习算法，优化搜索排序</li>
</ol>
<p>【任职要求】</p>
<ol>
<li><p>对机器学习、数据挖掘、深度学习等算法领域有研究热情和扎实的基础</p>
</li>
<li><p>计算机、数学及相关专业研究生、博士生</p>
</li>
<li><p>熟悉python、C++与Linux开发 </p>
</li>
<li><p>良好的沟通协调能力，较好的主动性和求知欲</p>
</li>
<li><p>熟悉tensorflow、pytorch、caffe等学习框架优先</p>
</li>
<li><p>熟悉强化学习及相关框架，或对其有强烈兴趣者优先</p>
</li>
</ol>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面：</p>
<p>主要是聊项目经历 说一下项目</p>
<p>基本套路 讲一下项目背景 讲一下项目的基本过程 讲一下其中的亮点  难点 与反思 </p>
<p>其实后边三个是更重要的  </p>
<p><strong>问了神经网络防止过拟合的方法！！！</strong></p>
<blockquote>
<ol>
<li>参数正则化， L1 L2</li>
<li>dropout</li>
<li>early stoping</li>
<li>参数(权值共享)</li>
<li>BatchNormaliaztion</li>
</ol>
</blockquote>
<p>题目一： 从m个数中随机等概率抽取n个数（面试官让我实现random.choice）</p>
<p>题目二：找出一个数组中，超过一半的个数的元素</p>
<p><a href="https://mereder.github.io/2019/12/04/leetcode-169-多数元素/" target="_blank" rel="noopener">Leetcode-169-多数元素</a></p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>主要问我的都是算法点吧…</p>
<p>决策树怎么进行特征选择，信息增益怎么算，信息增益比怎么算</p>
<p>其中着重讲了神经网络的参数更新过程（前向传播，反向传播，要写链式求导）</p>
<p>Xgboost，让我手推一边，能推到哪里就写到哪里，然后讲一下整个表达式中的各个含义</p>
<p>笔试题目：</p>
<p><a href="https://mereder.github.io/2019/11/29/插入排序/" target="_blank" rel="noopener">插入排序</a></p>
<h3 id="三面交叉面"><a href="#三面交叉面" class="headerlink" title="三面交叉面"></a>三面交叉面</h3><p>来的面试官是这边做知识图谱的一位，全程都属于聊天状态。</p>
<p>抛给我的问题都算是思考类型的吧</p>
<p>笔试题目：给出括号的对数，问有多少种不同的排列方式</p>
<p><a href="https://mereder.github.io/2019/11/29/leetcode-22-括号生成" target="_blank" rel="noopener">Leetcode-22-括号生成</a></p>
<h3 id="四面leader"><a href="#四面leader" class="headerlink" title="四面leader"></a>四面leader</h3><p>应该是这个组的老大吧，他说他手下大概20多个人。</p>
<p>老大过来跟我说了下他们这边主要做什么</p>
<p>然后搜索流量占了京东app流量的一半以上，dau6000W，检索条数更是十亿级别吧。</p>
<p>然后说了说自己从nlp转到推荐或者搜索的初衷</p>
<p>老大说，还挺好…不用再给你洗脑了。（没太明白）</p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-169-多数元素</title>
    <url>/2019/12/04/leetcode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="多数元素（超过数组一半的元素）"><a href="#多数元素（超过数组一半的元素）" class="headerlink" title="多数元素（超过数组一半的元素）"></a>多数元素（超过数组一半的元素）</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: [3,2,3]<br>输出: 3<br>示例 2:</p>
<p>输入: [2,2,1,1,1,2,2]<br>输出: 2</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解题方法有很多，最直观的一种就是计数呗，看哪个元素的总数和超过了数组的一半。这种方法就需要考虑用什么来存储计数的结果，当然hash是最好的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        hash=&#123;&#125;</span><br><span class="line">        n=len(nums)</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        max_count=n//<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(nums[i] <span class="keyword">not</span> <span class="keyword">in</span> hash):</span><br><span class="line">                hash[nums[i]]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash[nums[i]]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(hash[nums[i]]&gt;max_count):</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure>
<p>还有一种想法，直接排序，那中间位置的元素肯定是超过数组一半的那个，那这样又涉及到排序算法。最快就是</p>
<p>$nlogn$ 进而想到，其实我们不用完全将数组排好序，只要我们找到中间的那个位置的元素就可以了，如何做到呢？我们知道快排有个良好的特性：每一轮快排结束后，一个元素会被放到最终的位置上，那么我们根据这个特性，只需要找到位于中间位置的那个元素就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">          <span class="comment">#	类似剪枝过程，如果mid不在范围内的一侧就不用去遍历了。</span></span><br><span class="line">            index = self.partition(nums,left,right)</span><br><span class="line">            <span class="keyword">if</span> index == mid:</span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">            <span class="keyword">elif</span> index &lt; mid:</span><br><span class="line">                left = index+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = index<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> nums[mid]</span><br><span class="line">            </span><br><span class="line">		<span class="comment"># 快排基础，用来找一次快排将某个元素确定的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self,nums,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        pivot = nums[right]</span><br><span class="line">        slow = left<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> slow != i:</span><br><span class="line">                    nums[i],nums[slow] = nums[slow],nums[i]</span><br><span class="line">        slow += <span class="number">1</span></span><br><span class="line">        nums[slow],nums[right] = pivot,nums[slow]</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<p><strong>更巧妙的办法</strong>：摩尔投票法</p>
<p>基本思想就是，占大多数的元素个数总和肯定比其他元素总和要高。</p>
<p>count来计数，对于重叠的元素++，对于不同的元素—，当count为0时需要重新选一个值作为计数的基础元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                res = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] == res:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-82-删除排序链表中的重复元素ii</title>
    <url>/2019/12/04/leetcode-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</url>
    <content><![CDATA[<h2 id="删除排序链表中的重复元素ii"><a href="#删除排序链表中的重复元素ii" class="headerlink" title="删除排序链表中的重复元素ii"></a>删除排序链表中的重复元素ii</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5</p>
<p>示例 2:</p>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>相比于easy题目<a href="">Leetcode-83-删除排序链表中的重复元素</a></p>
<p>本题的难度在于不仅仅要删除后边的重复数，连本位置的重复数也要删掉。</p>
<p>所以需要找到所有相同的数，然后进行链表的一次删除操作（排序链表，相同的数在一起，一次删除操作即可）。</p>
<p>简单的地方仍在于给的是排序链表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 哑变量，方便处理头部删除 前一个题不需要是因为头部不会进行删除</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        p = dummy				<span class="comment"># 作为有效链表的尾部，后边只会接上不重复的数</span></span><br><span class="line">        q = dummy.next	<span class="comment"># 重复数的指针，如果有重复则会一直遍历到不重复的数或者None停止</span></span><br><span class="line">        <span class="keyword">while</span> q.next:</span><br><span class="line">            tmp = q.val</span><br><span class="line">            <span class="keyword">if</span> q.next.val == tmp: <span class="comment"># 存在重复情况，进入操作</span></span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> q.val == tmp: <span class="comment"># 不为空并且值重复</span></span><br><span class="line">                    q = q.next</span><br><span class="line">                p.next = q</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> q:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:									<span class="comment"># 前后两个数不重复，则继续向后遍历</span></span><br><span class="line">                p = p.next</span><br><span class="line">                q = q.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-83-删除排序链表中的重复元素</title>
    <url>/2019/12/04/leetcode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>双指针遍历，较为简单</p>
<p>重点是：排序链表，并且删除后还保留了一个基本的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        p = head</span><br><span class="line">        q = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">                p.next = q.next</span><br><span class="line">                q = p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                q = q.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-73-矩阵置0</title>
    <url>/2019/12/04/leetcode-73-%E7%9F%A9%E9%98%B5%E7%BD%AE0/</url>
    <content><![CDATA[<h2 id="矩阵置0"><a href="#矩阵置0" class="headerlink" title="矩阵置0"></a>矩阵置0</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<p>示例 1</p>
<blockquote>
<p>输入:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>输出:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]<br>示例 2:</p>
<p>输入:<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br>输出:<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]<br>进阶:</p>
<p>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。<br>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。<br>你能想出一个常数空间的解决方案吗？</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>限制算法的性能：时间复杂度$O(m*n)$空间复杂度$O(1)$</p>
<p>如果没有任何限制，这个题目其实会很简单，就是遍历，将找到的0所在行列都置为0，那样复杂度绝对不止m*n</p>
<p>当时想到的解法就是，两次遍历，每次的遍历都是m*n，那么最终还是m*n的时间复杂度。</p>
<p>只需要找到的0，将其所在行和所在列标识出来，怎么标识，就是通过矩阵的首行和首列来当我们的存储，把需要置为0的行的首位变为0，首列变为0 ，第二次遍历的时候，只需要遍历第一行将其中为0的所在列都置为0，再遍历第一列，将其中为0的所在行都置为0。</p>
<p>这时又出现一个问题，就是原本首行首列就有的0怎么办？由于只能用常数空间，所以考虑两个变量来标识出来首行首列是否原本就需要都置为0 的。</p>
<p>细节问题：对于矩阵遍历要从1开始，这样起到保护首行首列的作用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        first_row = <span class="literal">False</span></span><br><span class="line">        first_col = <span class="literal">False</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                first_col = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                first_row = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_row:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_col:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>作业帮算法实习生面经——已过</title>
    <url>/2019/12/03/%E4%BD%9C%E4%B8%9A%E5%B8%AE%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="jd"><a href="#jd" class="headerlink" title="jd"></a>jd</h2><p>投递岗位</p>
<p>1、深入自然语言处理相关的核心技术研究，如对话系统、问答系统、阅读理解等NLP技术；</p>
<p>2、用机器学习/深度学习等技术解决分层模型、点击预估、流失预测等业务问题；</p>
<p>3、负责用户增长中的算法问题，提升约课、到课、转化、回捞等相关转化率；</p>
<p>4、将自然语言技术应用具体业务中，包括智能客服、催到课、用户意图分类等。</p>
<h2 id="一面："><a href="#一面：" class="headerlink" title="一面："></a>一面：</h2><p>写题：</p>
<p>1.旋转数组中找target （腾讯视频NLP二面题目） 面试官指导下磕磕绊绊写出来了，腾讯视频面试时候写出来是因为当时分开完成的，先写了找到断点的地方，然后再找target</p>
<p><a href="https://mereder.github.io/2019/11/18/leetcode-33/" target="_blank" rel="noopener">Leetcode-33-搜索旋转数组</a></p>
<p>2.合并两个有序数组 easy</p>
<p>简单聊了聊项目 对于技术点没有深挖</p>
<h2 id="二面："><a href="#二面：" class="headerlink" title="二面："></a>二面：</h2><p>聊项目（前一段实习在网易的项目） 实现背景 实现策略（数据、算法） 实现结果</p>
<p>没有深挖技术点</p>
<p>思路题：</p>
<p>给了一个问题背景</p>
<p>护林员统计了一片森林的各种树的特征（树的种类啊 树的高度啊 树年龄 等等）</p>
<p>其中有一些数据的树高统计由于人为的失误导致数据异常，问如何检查异常的树高数据</p>
<p>当时的回答，就是离群点检测：</p>
<p>如何检测离群点，我给的方案是，首先可以做回归，比如给定一些基础特征，然后根据特征来预测树高</p>
<p>那么正常的值应该都在回归曲线附近，那么也需要一个超参数来衡量在什么范围内的数据是正常，什么范围外的数据是异常点</p>
<p>其次想到了对于异常点（离群点） 背景就是数据分布属于高斯分布的情况下，那么数据可以根据 </p>
<p>均值 +- n个标准差来做判断</p>
<p>==知识点待补充，如何来分析数据的离群点==</p>
<p>算法题：</p>
<p>给一个矩阵m*N，找从左上角到右下角的路径个数，其中会有一些路径是有障碍的 没有办法走过去。</p>
<p><a href="https://mereder.github.io/2019/12/03/leetcode-63-不同路径II/" target="_blank" rel="noopener">Leetcode-62-不同路径II</a></p>
<p>提问环节：</p>
<p>他们组主要做对话技术部分，之前的都已经搭好了，如果现在过去的话也是做基于分析badcase的解决提高对话的有效转化</p>
<p>聊了下这边的技术主要内容 他们月活大概 1.2亿 </p>
<p>业务的应用场景主要是 约课 和课程转化率</p>
<p>目前主要的操作都是自动化的， ASR 到信息理解 然后输出 语音内容，通过对话来帮助客户完成课程转化或者付费内容的购买。</p>
<p>主要涉及的是对话技术、内容理解、用户拉新 和 约课（课程）转化</p>
<p>最后面完通过hr的交流，大概我当时面的是对话技术组，就是通过推荐那边得到潜在转化客户，然后通过机器人电话对客户进行约课或者付费课的转化。基本都已经搭建完了，他们现在的大部分工作应该是在处理badcase，一些对话结果可能不是很好在做处理。</p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>小米桌面信息流推荐算法面经——已过</title>
    <url>/2019/12/03/%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="小米桌面信息流推荐算法工程师"><a href="#小米桌面信息流推荐算法工程师" class="headerlink" title="小米桌面信息流推荐算法工程师"></a>小米桌面信息流推荐算法工程师</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>主要聊一下项目 （经典必问问题：项目背景，项目意义指标等，难点，亮点）</p>
<p>全流程推一边 xgboost 完事</p>
<p>写题： 将 一个m*n的矩阵中，有个别的数值为0，将0所在的行和列全都置为0.</p>
<p>基本方法就是 暴力解决， 遍历矩阵的时间复杂度就是O(m*n) 对于一个位置为0，将其行列置为0的时间复杂度是O(m+n)</p>
<p>但是面试官要求，时间复杂度为O(1)，所以需要考虑下</p>
<p>磕磕绊绊吧 最终没有完全写出来但是跟真正的解法已经很接近了</p>
<p>事后补充：<a href="https://mereder.github.io/2019/12/04/leetcode-73-矩阵置0/" target="_blank" rel="noopener">73. 矩阵置零</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        first_row = <span class="literal">False</span></span><br><span class="line">        first_col = <span class="literal">False</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                first_col = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                first_row = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_row:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_col:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>聊下项目</p>
<p>问下transformer 的结构 以及基本的理解</p>
<p>问下lr基本的内容</p>
<p>问下 除了bert这一种预训练词向量外 还有没有了解别的。</p>
<p>（这个地方有必要好好把word2vec、elmo、gpt这些重新学习下）</p>
<p>写题：</p>
<p>链表重复数删除，将一个单链表中，重复的数进行删除。</p>
<p><a href="https://mereder.github.io/2019/12/04/leetcode-82-删除排序链表中的重复元素ii/" target="_blank" rel="noopener">Leetcode-82-删除排序链表中的重复元素ii</a></p>
<p>交流下基本问题：</p>
<p>Dau1800W 桌面信息流 推荐上层在北京这边，内容理解在武汉。他们主要做推荐侧…</p>
<p>其实我个人觉得小米这边对于自己学技术来说这边还是蛮合适的，尤其是晓伟哥跟我说，推荐的技术要比搜索更复杂一些的时候，觉得最后选择京东搜索排序那边可能并不是一个最好的选择吧？….</p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-3-无重复字符的最长子串</title>
    <url>/2019/12/03/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><strong>滴滴算法工程师（EP组没记错的话  hhh）一面面试题目</strong></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p> 输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p> 输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个破题，前后看了好几遍才理解了最优解法的意义。</p>
<p>这里面主要是利用<strong>滑动窗口</strong>机制，那么还需要使用几个辅助变量来帮助实现这个思想</p>
<blockquote>
<p>d: 是一个字典用来存放&lt;字符,最后一次的位置&gt; 这个一方面 方便我们来查找重复字符 另一方面方便确认两个重复字符直接的距离</p>
<p>start: 是 我们找到的无重复字符串的开始</p>
<p>end：是我们找到的无重复字符串的结尾，同时也是遍历字符串的指针</p>
<p>mx：存储最长无重复字符串的长度</p>
</blockquote>
<p>无重复字符串的长度计算即:$end-start+1$</p>
<p>end是不断再向后走的，我们需要判断的是start应该放在什么位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s[end] <span class="keyword">in</span> d:</span><br><span class="line">  start = max(d[char]+<span class="number">1</span>,start)</span><br></pre></td></tr></table></figure>
<p>start记录无重复子串的开始，char表示当前遍历的字符，d是字典，存放各个字符的最终位置</p>
<ul>
<li><p>查看当前字符是否重复，如果重复再看是否在 无重复串中间：</p>
</li>
<li><p>如果 在 无重复串中间 即 start &lt; d[char] 需要更新无重复字符串的开始位置为 d[char]+1</p>
</li>
<li><p>如果 不在 无重复串中间，即 start &gt; d[char] 那么当前字符不会对我们的无重复字符串产生影响</p>
</li>
<li><p>相当于重新定义了 无重复字符串的开始位置，方便后边计算无重复字符串的长度</p>
</li>
</ul>
<blockquote>
<p>举个例子：</p>
<p>abcdc  当遍历到第二个c时，原本的无重复串为abcd ，此时重复字符c是在重复串中间的，那么需要更新我们的窗口，将start从a的下标调整到前一个c的下标+1</p>
<p>再举个例子</p>
<p>abcdba 接着上一个分析，当经过第二个b之后，无重复子串被置为 cdb，当处理最后一个a时，尽管前面有重复的a但是对于我们的无重复子串是没有影响的，可以直接加上，变成cdba。</p>
<p>每次更新start位置之后，无重复字符串长度为end-start+1，不一定都能得到最长的，所以每次都需要再跟max做个比较</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        d = &#123;&#125;  <span class="comment"># 记录字符以及字符最后一次出现的位置</span></span><br><span class="line">        mx = <span class="number">0</span>  <span class="comment"># 记录最长的长度</span></span><br><span class="line">        start = <span class="number">0</span> <span class="comment"># 记录无重复字符串的开始位置</span></span><br><span class="line">        end = <span class="number">0</span>  <span class="comment"># 记录无重复字符串的结束位置</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; len(s): <span class="comment"># 遍历字符串</span></span><br><span class="line">            char = s[end]  <span class="comment"># 当前字符串</span></span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">in</span> d:</span><br><span class="line">                <span class="comment"># 查看当前字符是否重复，如果重复再看是否在 无重复串中间：</span></span><br><span class="line">                <span class="comment"># 如果 在 无重复串中间 即 start &lt; d[char] 需要更新无重复字符串的开始位置为 d[char]+1</span></span><br><span class="line">                <span class="comment"># 如果 不在 无重复串中间，即 start &gt; d[char] 那么当前字符不会对我们的无重复字符串产生影响</span></span><br><span class="line">                <span class="comment"># 相当于重新定义了 无重复字符串的开始位置，方便后边计算无重复字符串的长度</span></span><br><span class="line">                start = max(d[char]+<span class="number">1</span>,start)</span><br><span class="line">            </span><br><span class="line">            mx = max(mx,end-start+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 更新我的字典中，字符的位置信息</span></span><br><span class="line">            d[char] = end</span><br><span class="line">            end+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
<h4 id="更像滑动窗口套路的解法"><a href="#更像滑动窗口套路的解法" class="headerlink" title="更像滑动窗口套路的解法"></a>更像滑动窗口套路的解法</h4><ul>
<li>右移寻找最长可行解</li>
<li>左移优化解的结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        window = defaultdict(int)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            ch = s[r]  <span class="comment"># 当前遍历到的字符</span></span><br><span class="line">            window[ch] += <span class="number">1</span> <span class="comment"># 窗口内该字符个数+1</span></span><br><span class="line">            r += <span class="number">1</span>		<span class="comment"># 右移一次</span></span><br><span class="line">            length += <span class="number">1</span>  <span class="comment"># 长度+1</span></span><br><span class="line">            <span class="keyword">while</span> window[ch] &gt; <span class="number">1</span>: <span class="comment"># 若不重复，则字符的长度应该为1，若大于1说明重复</span></span><br><span class="line">                window[s[l]] -= <span class="number">1</span> <span class="comment"># 将左侧的移除掉，一直到满足 while 中的条件</span></span><br><span class="line">                l += <span class="number">1</span>						<span class="comment"># 左移一次</span></span><br><span class="line">                length -= <span class="number">1</span>				<span class="comment"># 长度-1</span></span><br><span class="line">            mx = max(mx,length)</span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
<p>上面length 变量是可以省略的，通过r-l+1来计算得到即可</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p><a href="https://mereder.github.io/2019/12/07/滑动窗口系列题组/" target="_blank" rel="noopener">滑动窗口问题</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-63-不同路径II</title>
    <url>/2019/12/03/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    <content><![CDATA[<h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2><p><strong>作业帮算法实习生二面面试题</strong></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jfbb1hcej30b4053gll.jpg" alt="img"></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<blockquote>
<p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<p>1.向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</p>
<p>2.向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>机器人走路问题，还是用动态规划来解决，最基本的动态规划递归状态是</p>
<script type="math/tex; mode=display">
当前路径数 = 左侧格子路径+上边格子路径 \\
n_{i,j} = n_{i,j-1} + n_{i-1,j} \\
dp[i][j] = dp[i][j-1] + dp[i-1][j]</script><p>这个题有特殊的要求，存在障碍那么就需要对障碍点进行下判断：</p>
<ul>
<li>第一步就是障碍点： 直接返回0</li>
<li>第一列或者第一行存在障碍点 那么后继的都应该为0</li>
<li>其他情况的障碍点 只需要存在就令该位置对应dp为0</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment"># 特殊情况，起始位置就是障碍则为0 否则为1</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># dp空间初始化进行赋值 第一行    </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># dp 空间初始化进行赋值 第一列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 其他情况 需要进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment"># 遇到障碍 dp = 0</span></span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">               	<span class="comment"># 非障碍，根据情况进行dp[i][j]的赋值</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> dp[i<span class="number">-1</span>][j] == <span class="number">0</span> <span class="keyword">and</span> dp[i][j<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i<span class="number">-1</span>][j] == <span class="number">0</span> <span class="keyword">or</span> dp[i][j<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-53-最大子序和</title>
    <url>/2019/12/01/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p>
</blockquote>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>基本方法动态规划，动态规划就是求最值过程，其中每一个元素都面临着两种选择，要还是不要，对应dp过程：</p>
<blockquote>
<p>dp[i] = max(dp[i-1]+nums[i],num[i])</p>
</blockquote>
<p>最终结果是，dp数组中结果最大的那个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        // 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span><br><span class="line">        int result = INT_MIN;</span><br><span class="line">        int numsSize = int(nums.size());</span><br><span class="line">        // dp[i]表示nums中以nums[i]结尾的最大子序和</span><br><span class="line">        vector&lt;int&gt; dp(numsSize);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        result = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            result = max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h4><p>贪心算法就是思考每一步我的选择都是最优的，如果i之前的和为正数，那么可以继续连续和，则加上nums[i]。如果之前的和已经为负数了，那么没有必要继续连续，到i位置，我们重新定义连续和为nums[i]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">                tmp += data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = data</span><br><span class="line">            ans = max(ans,tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>使用更为精妙的分治法来求解</p>
<p>思路就是，求一个数组的最大连续和，可以转化为求左侧数组最大子序列和，求右侧数组最大子序列和，<strong>求跨过分界点的连续子序列</strong>，这样问题就被分治化解了。重点就是如何求跨过分界点的连续子序列和</p>
<p>Ps:这个思路可以了解下，但是解这道题来说，真的是时间空间都不够好</p>
<p>时间复杂度$O(nlogn)$，空间复杂度$O(logn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.helper1(nums,<span class="number">0</span>,n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper1</span><span class="params">(self, nums, left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        </span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        left_res = self.helper1(nums,left,mid)</span><br><span class="line">        right_res = self.helper1(nums,mid+<span class="number">1</span>,right)</span><br><span class="line">        cross_res = self.helper2(nums,left,mid,right)</span><br><span class="line"></span><br><span class="line">        res = max(left_res,right_res,cross_res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper2</span><span class="params">(self,nums,left,mid,right)</span>:</span></span><br><span class="line">        res_left = -np.inf</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从中间向前</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid,left<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            tmp += nums[i]</span><br><span class="line">            res_left = max(tmp,res_left)</span><br><span class="line"></span><br><span class="line">        res_right = -np.inf</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从中间向后</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid+<span class="number">1</span>,right+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">            tmp += nums[i]</span><br><span class="line">            res_right = max(tmp,res_right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res_left+res_right</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2019/12/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基于分治思想的排序算法，稳定的排序算法，时间复杂度$O(NlogN)$，空间复杂度为$O(N)$（需要一个备份数字来进行存储）。</p>
<p>排序算法的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergreSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment"># 迭代终止条件</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len(nums) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment"># 分治过程 不断划分</span></span><br><span class="line">    left = mergreSort(nums[:mid])</span><br><span class="line">    right = mergreSort(nums[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 核心操作：比较左右两个数组，将比较小的先加入备份数字</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt;= right[r]:</span><br><span class="line">            res.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left):</span><br><span class="line">        res.append(left[l])</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> r &lt; len(right):</span><br><span class="line">        res.append(right[r])</span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a =[<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">    print(a)</span><br><span class="line">    res = mergreSort(a)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>最基础的应用，求逆序对数。</p>
<p>基本思想就是：左边的都是小于右边的，那么逆序对数就是右边的一个对应左边每一个。</p>
<p>在merge过程就可以进行计数</p>
<p>举个例子：</p>
<blockquote>
<p>[1,3,5],[2,4,6]</p>
<p>左侧序列的5可以组成的逆序对有(5,2)(5,4)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-222-完全二叉树的节点个数</title>
    <url>/2019/12/01/leetcode-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h2><p>给出一个完全二叉树，求出该树的节点个数。</p>
<p>说明：</p>
<p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / \  /</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始想法是，计算完全二叉树的节点个数是有技巧的，根据其最后一层的深度以及最后一层的叶子节点个数，是可以计算出完全二叉树的节点个数的。</p>
<blockquote>
<p>若最后一层深度为d，最后一层节点个数为N</p>
<p>$ total = 2^{d-1}-1+N$</p>
</blockquote>
<p>但是想到我都能遍历到叶子节点了，肯定也能遍历叶子节点上面的其他节点了，所以我只需要遍历一遍二叉树，就知道我的树节点个数了-_-！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>
<p>解法简单粗暴：时间复杂度是O(N)，N是叶子节点个数</p>
<p>优化解法</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-117-填充每个节点的下一个右侧节点指针 II</title>
    <url>/2019/12/01/leetcode-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/</url>
    <content><![CDATA[<h2 id="填充每个节点的下一个右侧节点指针ii"><a href="#填充每个节点的下一个右侧节点指针ii" class="headerlink" title="填充每个节点的下一个右侧节点指针ii"></a>填充每个节点的下一个右侧节点指针ii</h2><p>给定一个二叉树</p>
<blockquote>
<p>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}</p>
</blockquote>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：</p>
<blockquote>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>参考题目<a href="https://mereder.github.io/2019/11/27/leetcode-116-填充每个节点的下一个右侧节点指针/" target="_blank" rel="noopener">Leetcode-116-填充每个节点的下一个右侧节点指针</a></p>
<p>自己的解法还是依靠于层次遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            cur -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>,nxt):</span><br><span class="line">                    queue[index<span class="number">-1</span>].next = queue[index]</span><br><span class="line">                cur = nxt</span><br><span class="line">                nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2019/11/29/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>基础排序算法之一，也是基于交换的排序方案</p>
<p>时间复杂度是$O(N^2)$</p>
<p>当然有可以优化的点，就是当一次插入中，没有跟  有序部分最后一个发生交换的话，可以直接退出当前循环了，继续去操作下一个数值</p>
<p>算法实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">        flag = <span class="literal">False</span> <span class="comment"># 优化地方</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">0</span>,<span class="number">-1</span>): <span class="comment"># j=i开始，向j=0 遍历</span></span><br><span class="line">            <span class="keyword">if</span> nums[j<span class="number">-1</span>] &gt; nums[j]:</span><br><span class="line">                nums[j<span class="number">-1</span>],nums[j] = nums[j],nums[j<span class="number">-1</span>]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag: <span class="comment"># 未发生交换</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">    insertSort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-22-括号生成</title>
    <url>/2019/11/29/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p><strong>京东搜索排序实习生面试——三面试题</strong></p>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<blockquote>
<p>[“((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”]</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>面试当时这个题实际上是没有正确的搞出来的，当时的大概思路是，我可以对括号进行全排列（类似字母组合排列的那个），然后对生成的每一次结果进行判断，如果符合括号规则就是正确的，如果不符合就不保留</p>
<p>（当时交叉面，只让我提了下思路，回leetcode惊人的发现这个题的暴力解法就是这样，不过怎样递归生成一个串，确实没有写出来）</p>
<p>面试官提示，这个题是可以通过dfs来解决的。（然并卵…..）</p>
<p>==正题==</p>
<h4 id="方法一-暴力解法"><a href="#方法一-暴力解法" class="headerlink" title="方法一 暴力解法"></a>方法一 暴力解法</h4><p>正如上边说的，我先去考虑如何生成，然后对生成的序列做判断，来判断是否有效，有效就加入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(A = [])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(A) == <span class="number">2</span>*n:</span><br><span class="line">                <span class="keyword">if</span> valid(A):</span><br><span class="line">                    ans.append(<span class="string">""</span>.join(A))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.append(<span class="string">'('</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line">                A.append(<span class="string">')'</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(A)</span>:</span></span><br><span class="line">            bal = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">'('</span>: bal += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: bal -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bal &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> bal == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        generate()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="方法二-深度优先搜索"><a href="#方法二-深度优先搜索" class="headerlink" title="方法二 深度优先搜索"></a>方法二 深度优先搜索</h4><p>看解法里面大家也管这个过程叫回溯，没想明白回溯体现在哪里。</p>
<p>重点来了！！！</p>
<p>leetcode大佬的分析图：<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/" target="_blank" rel="noopener">回溯算法（深度优先遍历）+ 广度优先遍历 + 动态规划</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9fcqtixz8j31hc0u0q9e.jpg" alt="LeetCode 第 22 题：“括号生出”题解配图.png"></p>
<p>对于自己来说，真的是一图胜千言，看了这个图就明白是怎么回事了。</p>
<p>方法一是不断的生成，生成很多个叶子节点，但是大部分都是无效的，但是采用的是”后剪枝“</p>
<p>那我干嘛不在生成的过程中就考虑下合法性呢？ 相当于”预剪枝“</p>
<p>下面解法我觉得巧妙的地方应该是<strong>left和right 两个变量</strong>的利用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        left = n</span><br><span class="line">        right = n</span><br><span class="line">        self.dfs(<span class="string">''</span>,left,right,res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, string, left,right,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right ==<span class="number">0</span>:</span><br><span class="line">            res.append(string)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span>: <span class="comment"># 对于不满足的情况不在进行遍历</span></span><br><span class="line">            self.dfs(string+<span class="string">'('</span>, left<span class="number">-1</span>,right,res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:  <span class="comment"># 对于不满足的情况不在进行遍历</span></span><br><span class="line">            self.dfs(string+<span class="string">')'</span>,left,right<span class="number">-1</span>,res)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-86-分隔链表</title>
    <url>/2019/11/29/leetcode-86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<blockquote>
<p> 示例:</p>
<p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
</blockquote>
<p><strong>链表归并排序的基础模块</strong></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路很简单，设置两个 dummy node 来分别表示 前面 和后面的链表，这样遍历一次head就可以直接得到结果了</p>
<p><strong>采用dummy node这个方法可以很方便的处理链表问题</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        before = ListNode(<span class="number">-1</span>) <span class="comment"># dummy node</span></span><br><span class="line">        after = ListNode(<span class="number">-2</span>)</span><br><span class="line">        p = before</span><br><span class="line">        q = after</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                p.next = head</span><br><span class="line">                p = p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q.next = head</span><br><span class="line">                q = q.next</span><br><span class="line">            </span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        p.next = after.next</span><br><span class="line">        q.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> before.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2019/11/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>先留几个坑，有空回来填：</p>
<ul>
<li>快排的时间复杂度平均为$NlogN$，最差退化为$N^2$</li>
<li>快排是不稳定排序算法，即相同值的前后顺序可能会发生变化</li>
<li>快排的优化是：1.先将数组乱序random.shuffle(in place)  2.枢值的选取随机</li>
</ul>
<p>基本面试最最最基础的问题了</p>
<p>尤其是其中的partition函数，更是很多其他算法题的应用基础</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个跟市面上大多数partition不太一样</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition1</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="comment"># 选一个枢值</span></span><br><span class="line">    pivot = nums[right]</span><br><span class="line">    slow = left - <span class="number">1</span>   <span class="comment"># slow指针用来记录较小元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> slow != i:</span><br><span class="line">                nums[slow],nums[i] = nums[i],nums[slow]</span><br><span class="line">    <span class="comment"># 经过上面的遍历过程，slow指向小于pivot的最后一个，所以还需要将slow++ 才是pivot的位置</span></span><br><span class="line">    slow += <span class="number">1</span></span><br><span class="line">    nums[slow], nums[right] = pivot, nums[slow]</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt; right:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    index = partition1(nums,left,right)</span><br><span class="line">    quick_sort(nums, left, index<span class="number">-1</span>)</span><br><span class="line">    quick_sort(nums, index+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    quick_sort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">10</span>]</span><br><span class="line">    print(a)</span><br><span class="line">    quickSort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Naive Bayes</title>
    <url>/2019/11/28/NB/</url>
    <content><![CDATA[<h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>基础知识点：</p>
<ul>
<li><p>为什么叫朴素（特征之间独立）</p>
</li>
<li><p>贝叶斯公式（）</p>
<script type="math/tex; mode=display">
P\left(B_{i} | A\right)=\frac{P\left(B_{i}\right) P\left(A | B_{i}\right)}{\sum_{j=1}^{n} P\left(B_{j}\right) P\left(A | B_{j}\right)}</script></li>
</ul>
<ul>
<li><p>朴素贝叶斯算法的极大似然过程（就是统计做count）</p>
</li>
<li><p>朴素贝叶斯算法的贝叶斯估计（+1平滑，拉普拉斯平滑？）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ML</category>
        <category>算法面试</category>
      </categories>
  </entry>
  <entry>
    <title>Logistic Regression</title>
    <url>/2019/11/28/LR/</url>
    <content><![CDATA[<h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>机器学习最基础的东西，基本上也涵盖了一个机器学习算法的方方面面，可谓麻雀虽小五脏俱全。</p>
<p>对于LR，需要重点掌握：</p>
<ul>
<li>对数几率的含义，以及为什么是逻辑<strong>回归</strong></li>
<li>可以写出逻辑回归的概率分布函数（我的理解就是个分段函数，y取0或y取1）</li>
<li>可以写出逻辑回归的极大似然</li>
<li>损失函数最终的化简结果</li>
<li>梯度下降中的梯度怎么求出来的</li>
</ul>
<h3 id="关于逻辑回归的几个问题"><a href="#关于逻辑回归的几个问题" class="headerlink" title="关于逻辑回归的几个问题"></a>关于逻辑回归的几个问题</h3><ul>
<li><p>为什么使用梯度下降来求最优，为什么不直接用解析解直接得到最优结果就好了呢？</p>
<blockquote>
<p>这个问题归结于解析解的计算问题上：</p>
<p>$\theta = (XX^T)^{-1}X^TY$</p>
<p>如果想一次性计算出参数的最优值，这个计算量是很庞大的，尤其计算机求矩阵的逆的计算量巨大，所以没有办法实现，只能依靠梯度下降这种方法，逐步到达最优</p>
</blockquote>
</li>
<li><p>LR如何来进行过拟合限制，具体怎么操作的，为什么这样就可以达到抑制过拟合</p>
<blockquote>
<p>引入L2正则项</p>
</blockquote>
</li>
<li><p>为什么用极大似然来操作，或者换句话问，为什么要用交叉熵损失，用均方误差不可以吗？</p>
<blockquote>
<p>不可以，我们平时做的都是凸优化，对于分类问题用均方误差，优化函数是非凸的？？</p>
</blockquote>
</li>
<li><p>LR模型需要归一化嘛？为什么需要归一化，体现在哪里？归一化的类型都有什么？</p>
<blockquote>
<p>LR肯定需要归一化，</p>
<p>为什么需要归一化呢，重点问题出现在进行梯度下降过程，如果两个特征的的特征空间不是一致的，那么梯度下降过程很可能走的是“之字形”（优化的是个椭圆形的，每次优化都是垂直等高线向下），那么不会收敛或者很难收敛，进行特征归一化之后，特征空间都是相同的，那么优化的方向是一致的（优化的等高线是个圆形，垂直圆一直向圆心）</p>
<p>问题是出现在L2正则上，</p>
<p>归一化的类型有：</p>
<p>线性归一化： 这种归一化方法比较适用在数值比较集中的情况。这种方法有个缺陷，如果max和min不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。实际使用中可以用经验常量值来替代max和min。</p>
<script type="math/tex; mode=display">
x^{\prime}=\frac{x-\min (x)}{\max (x)-\min (x)}</script><p>标准差归一化：经过处理的数据符合标准正态分布，即均值为0，标准差为1，其转化函数为：</p>
<script type="math/tex; mode=display">
x^{*}=\frac{x-\mu}{\sigma}</script><p>非线性归一化：</p>
<p>经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括 log、指数，正切等。需要根据数据分布的情况，决定非线性函数的曲线，比如log(V, 2)还是log(V, 10)等。</p>
</blockquote>
</li>
<li><p>LR的特征离散化</p>
<blockquote>
<h4 id="为什么LR把特征离散化后效果更好？离散化的好处有哪些？"><a href="#为什么LR把特征离散化后效果更好？离散化的好处有哪些？" class="headerlink" title="为什么LR把特征离散化后效果更好？离散化的好处有哪些？"></a>为什么LR把特征离散化后效果更好？离散化的好处有哪些？</h4><p>逻辑回归属于广义线性模型，表达能力受限；<br>在工业界，很少直接将连续值作为逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1特征交给逻辑回归模型，这样做的优势有以下几点：</p>
<ol>
<li>逻辑回归属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，能够提升模型表达能力，加大拟合；</li>
<li>离散化后可以进行特征交叉，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力；</li>
<li>特征离散化以后，起到了简化了逻辑回归模型的作用，降低了模型过拟合的风险。</li>
<li>离散特征的增加和减少都很容易，易于模型的快速迭代；</li>
<li>稀疏向量内积乘法运算速度快，计算结果方便存储，容易扩展；</li>
<li>离散化后的特征对异常数据有很强的鲁棒性：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰；</li>
<li>特征离散化后，模型会更稳定，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问；</li>
</ol>
<p>李沐曾经说过：模型是使用离散特征还是连续特征，其实是一个“海量离散特征+简单模型” 同 “少量连续特征+复杂模型”的权衡。既可以离散化用线性模型，也可以用连续特征加深度学习。就看是喜欢折腾特征还是折腾模型了。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>ML</category>
        <category>算法面试</category>
      </categories>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2019/11/28/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>几个重要的排序算法中比较常用的或者经常写的</p>
<p>主要过程就是：</p>
<ul>
<li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 大顶推  将最大值往上挪  最小值在叶子节点</span></span><br><span class="line"><span class="comment"># 1. 大顶堆的一次调整过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">headAdjust</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">    <span class="comment"># 函数内的临时变量</span></span><br><span class="line">    root = start</span><br><span class="line">    child = <span class="number">2</span>*root+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> child &lt; end:</span><br><span class="line">        <span class="comment"># 找左右叶子节点中值较大的一个</span></span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt; end <span class="keyword">and</span> nums[child+<span class="number">1</span>] &gt; nums[child]:</span><br><span class="line">            child = child + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若 某一个叶节点值确实 大于根 则进行操作</span></span><br><span class="line">        <span class="keyword">if</span> nums[root] &lt; nums[child]:</span><br><span class="line">            <span class="comment"># 交换 根 和 叶的值</span></span><br><span class="line">            nums[root], nums[child] = nums[child], nums[root]</span><br><span class="line">            <span class="comment"># 调换了叶子节点的值，继续调整以叶子节点为根的分支</span></span><br><span class="line">            root = child</span><br><span class="line">            child = <span class="number">2</span>*root+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># 从第一个非叶子节点开始 从下向上调整树为大顶堆</span></span><br><span class="line">    start = n &gt;&gt; <span class="number">1</span> - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 2. 从下到上建造大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start,<span class="number">-1</span>,<span class="number">-1</span>):   <span class="comment"># 从start 到0</span></span><br><span class="line">        headAdjust(nums,i,n)</span><br><span class="line">    <span class="comment"># 此时已经  调整为大顶堆</span></span><br><span class="line">    <span class="comment"># 3. 堆排序过程：不断将最大值交换到数组尾部，然后再调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        nums[<span class="number">0</span>],nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        headAdjust(nums,<span class="number">0</span>,i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试阶段</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">10</span>]</span><br><span class="line">    print(a)</span><br><span class="line">    heapSort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<h3 id="主要应用场景"><a href="#主要应用场景" class="headerlink" title="主要应用场景"></a>主要应用场景</h3><p>1.面试直接写堆排序的过程</p>
<p>2.海量数据中取最小（或最大 topK问题）</p>
<blockquote>
<p>维护一个k大小的堆，如果堆不满直接加入，若满堆，则根堆内最值比较，选择替换堆内元素 或者 不替换</p>
<p>若不是海量数据取topk， 可以考虑 快排形式</p>
</blockquote>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-74-搜索二维矩阵</title>
    <url>/2019/11/28/leetcode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h2><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>示例 1:</p>
<blockquote>
<p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>输出: true</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是个二分查找的过程，重点就是如何将二维矩阵变成我们熟悉的一维数组形式。</p>
<p><strong>重点</strong></p>
<blockquote>
<p>二维矩阵的行标和列标可以完全对应到一维数组的index上</p>
<p>以示例为例：</p>
<p>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]</p>
<p>取数字 10，其row_index = 1, col_index =0</p>
<p>对应到一维数组上就是，row_index<em>n+col_index = 1\</em>n+0 = 4 </p>
</blockquote>
<p>借用官方的一张图</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9e1zgrvrvj30y40aswgy.jpg" alt="image-20191128210209085"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = m*n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">            row = mid//n </span><br><span class="line">            col = mid%n </span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-116-填充每个节点的下一个右侧节点指针</title>
    <url>/2019/11/27/leetcode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h2><p>给定一个<strong>完美</strong>二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9czbm9s44j30vk0d0aby.jpg" alt="image-20191127224430562"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看到示意图的时候，很明显的树的层次遍历嘛。</p>
<p>重点就是在层次遍历的什么阶段把指针都连接上，也就是换到下一层的时候，把队列内的节点都接上</p>
<blockquote>
<p>执行用时 :48 ms, 在所有 python3 提交中击败了100.00%的用户</p>
<p>内存消耗 :13.9 MB, 在所有 python3 提交中击败了97.13%的用户</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            cur -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> index,tree <span class="keyword">in</span> enumerate(queue):</span><br><span class="line">                    <span class="keyword">if</span> index+<span class="number">1</span> == len(queue):</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tree.next = queue[index+<span class="number">1</span>]</span><br><span class="line">                cur = nxt</span><br><span class="line">                nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>写完这个还觉得蛮不错，想去写个解法，结果在讨论区看到大神的解法</p>
<p>基本思想就是  给的next指针不仅仅赋值了，而且还利用到了，方便后边问题的解决</p>
<ul>
<li>pre 指针一直是处于每一层的最左侧</li>
<li>cur 指针则依次遍历这一层的节点<ul>
<li>先把cur的左和cur的右链接起来</li>
<li>如果cur的next还有 那么就把cur的右和cur下一个节点的左链接起来</li>
<li>向右移动一次cur</li>
</ul>
</li>
<li>pre向下移动一层</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pre = root</span><br><span class="line">        cur = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pre.left:</span><br><span class="line">            cur = pre</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                cur.left.next = cur.right</span><br><span class="line">                <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.right.next = cur.next.left</span><br><span class="line">                cur = cur.next</span><br><span class="line">            pre = pre.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-106-从后序和前序构建二叉树</title>
    <url>/2019/11/27/leetcode-106-%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="从后序和前序构建二叉树"><a href="#从后序和前序构建二叉树" class="headerlink" title="从后序和前序构建二叉树"></a>从后序和前序构建二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<blockquote>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]</p>
</blockquote>
<p>返回如下的二叉树：<br>        3<br>       / \<br>      9  20<br>         /  \<br>       15   7</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于Python实现起来太简单了（可以利用list的切片特性）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.helper(inorder,postorder)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,inorder,postorder)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(postorder[<span class="number">-1</span>])</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,val <span class="keyword">in</span> enumerate(inorder):</span><br><span class="line">            <span class="keyword">if</span> val == root.val:</span><br><span class="line">                index = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">        root.left = self.helper(inorder[:index],postorder[:index])</span><br><span class="line">        root.right = self.helper(inorder[index+<span class="number">1</span>:],postorder[index:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>树的基本操作</title>
    <url>/2019/11/27/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="深度优先遍历（dfs）"><a href="#深度优先遍历（dfs）" class="headerlink" title="深度优先遍历（dfs）"></a>深度优先遍历（dfs）</h2><h3 id="递归调用（前序遍历为例）"><a href="#递归调用（前序遍历为例）" class="headerlink" title="递归调用（前序遍历为例）"></a>递归调用（前序遍历为例）</h3><h3 id="迭代-stack-（前序遍历为例）"><a href="#迭代-stack-（前序遍历为例）" class="headerlink" title="迭代+stack （前序遍历为例）"></a>迭代+stack （前序遍历为例）</h3>]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-104-二叉树的最大深度</title>
    <url>/2019/11/27/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9corf4apnj30uu0bu0te.jpg" alt="image-20191127163906089"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>树的基础题目，理解树的递归调用，同时该题目还是</p>
<p>leetcode-xxx-平衡二叉树</p>
<p>的基础，平衡二叉树的判定条件主要就是计算左右两个子树的高度差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left = self.maxDepth(root.left)</span><br><span class="line">        right = self.maxDepth(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>最简单的方法是通过递归实现的，</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetode-111-二叉树的最小高度</title>
    <url>/2019/11/27/leetcode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="二叉树的最小高度"><a href="#二叉树的最小高度" class="headerlink" title="二叉树的最小高度"></a>二叉树的最小高度</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9codkqvmmj30vs0ciwf6.jpg" alt="image-20191127162545789"></p>
<p><strong>注意是最小高度，区别于算法题二叉树的高度（指二叉树的最大高度）</strong></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目简单，但是没有写出来，答案error，问题理解的不好</p>
<p>最小的深度：题目限制，只有到叶节点才能计算深度</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9coidktqyj30a207cwel.jpg" alt="image-20191127163024655"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">		<span class="comment">#			1</span></span><br><span class="line">		<span class="comment">#		/</span></span><br><span class="line">		<span class="comment">#	2	</span></span><br><span class="line">		<span class="comment"># 上述这种树，其最小深度为2  而按照下面的写法结果返回为1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">       <span class="keyword">return</span> self.helper(root)</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       </span><br><span class="line">       left = self.helper(root.left)</span><br><span class="line">       right = self.helper(root.right)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> min(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>问题出在：对于一个节点只含有一个子节点，只需要计算一侧就好，如果把为空的另一侧也算进去，这样在该层深度肯定为 1。不符合叶节点才计算长度的要求了</p>
<p>正解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        depth = <span class="number">10000</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            depth = min(self.helper(root.left),depth)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            depth = min(self.helper(root.right),depth)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth+<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-430-扁平化多级双向链表</title>
    <url>/2019/11/27/leetcode-430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="扁平化多级双向链表"><a href="#扁平化多级双向链表" class="headerlink" title="扁平化多级双向链表"></a>扁平化多级双向链表</h2><p>您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9csuhhhhgj30uw0degme.jpg" alt="截屏2019-11-27下午7.00.04"></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9d0viqd2nj31190l5gmo.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9d0vm9n9mj325905lmxs.jpg" alt="img"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跟<a href="https://mereder.github.io/2019/11/26/leetcode-114-二叉树展开为链表/" target="_blank" rel="noopener">Leetcode-114-二叉树展开为链表</a>的整体解决方案是一样的，只不过需要注意下问题是双向链表。</p>
<p>坑：前后节点之间是有前后指针相连的，当对于child节点，其prev节点并没有直接指向父节点<strong>而是None</strong>，进行指针操作的时候注意</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, prev, next, child):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.prev = prev</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.child = child</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.child <span class="keyword">and</span> cur.next:</span><br><span class="line">              	<span class="comment"># 1. 拿出子链表，同时子链的prev连上cur</span></span><br><span class="line">                p = cur.child</span><br><span class="line">                p.prev = cur</span><br><span class="line">                <span class="comment"># 2. 遍历子链表直到尾部</span></span><br><span class="line">                <span class="keyword">while</span> p.next:</span><br><span class="line">                    p = p.next</span><br><span class="line">                <span class="comment"># 3. 将原后续链表接入到子链表尾部</span></span><br><span class="line">                p.next = cur.next</span><br><span class="line">                cur.next.prev = p</span><br><span class="line">                <span class="comment"># 4. 调整子链表成为后续链表 并且child为None</span></span><br><span class="line">                cur.next = cur.child</span><br><span class="line">                cur.child = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 链表最后一个含有子链表，就直接调换下位置即可</span></span><br><span class="line">            <span class="keyword">elif</span> cur.child <span class="keyword">and</span> <span class="keyword">not</span> cur.next:</span><br><span class="line">                cur.next = cur.child</span><br><span class="line">                cur.child.prev = cur <span class="comment"># 因为这个没有导致case 20/22  没完全通过</span></span><br><span class="line">                cur.child = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 链表后移动 一个</span></span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Xgboost 原理分析</title>
    <url>/2019/11/26/xgboost/</url>
    <content><![CDATA[<ul>
<li>学的是什么？<ul>
<li>很多CART树</li>
<li>loss+regulization</li>
</ul>
</li>
<li>怎么学的？<ul>
<li>增量学习，每次只学一棵树，前面树固定</li>
<li>loss怎么写：泰勒展开</li>
<li>正则怎么做：</li>
</ul>
</li>
<li>还有哪些优化：<ul>
<li>shrinkage</li>
<li>列采样</li>
</ul>
</li>
<li>跟其他方法有何异同<ul>
<li>与gbdt的优缺点</li>
<li>与RF有什么优缺点</li>
</ul>
</li>
<li>怎么用<ul>
<li>几个关键参数：树的个数，树深， 叶子节点个数， </li>
</ul>
</li>
</ul>
<h2 id="学的是什么？"><a href="#学的是什么？" class="headerlink" title="学的是什么？"></a>学的是什么？</h2><p>对于任何一个有监督模型来说，都是从一批又标签的数据中进行学习</p>
]]></content>
      <categories>
        <category>ML</category>
        <category>算法面试</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-114-将二叉树展开为链表</title>
    <url>/2019/11/26/leetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bkaid387j30vq0r4wft.jpg" alt="题目描述"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如下过程生动的描述了节点的拼接过程</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">//将 <span class="number">1</span> 的左子树插入到右子树的地方</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line">//将原来的右子树接到左子树的最右边节点</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> //将 <span class="number">2</span> 的左子树插入到右子树的地方</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> //将原来的右子树接到左子树的最右边节点</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">作者：windliang (leetcode 用户的分享)</span><br><span class="line">链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-<span class="number">-26</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.left:   </span><br><span class="line">                <span class="comment"># 1. 找到最右点</span></span><br><span class="line">                before = cur.left</span><br><span class="line">                <span class="keyword">while</span> before.right:</span><br><span class="line">                    before = before.right</span><br><span class="line">                <span class="comment"># 2. 右子树插入到嘴有点</span></span><br><span class="line">                before.right = cur.right</span><br><span class="line">                <span class="comment"># 3. 左子树放到右子树位置</span></span><br><span class="line">                cur.right = cur.left</span><br><span class="line">                <span class="comment"># 4. 原左子树置为None</span></span><br><span class="line">                cur.left = <span class="literal">None</span></span><br><span class="line">                <span class="comment"># 5. 继续下一个节点</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.right</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-103-二叉树之字形遍历</title>
    <url>/2019/11/26/leetcode-103-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树锯齿形遍历（之字形）"><a href="#二叉树锯齿形遍历（之字形）" class="headerlink" title="二叉树锯齿形遍历（之字形）"></a>二叉树锯齿形遍历（之字形）</h2><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9big7ti98j30uw0hw0to.jpg" alt="image-20191126161510462"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>trick：</p>
<ul>
<li><p>使用两个栈 一个栈负责左-&gt;右压栈，一个栈负责右-&gt;左压栈</p>
</li>
<li><p>flag来区分对哪个栈进行操作</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        s1 = [] <span class="comment"># 左右压  出栈先右</span></span><br><span class="line">        s2 = [] <span class="comment"># 右左压  出栈先左</span></span><br><span class="line">        tmp = []</span><br><span class="line">        s1.append(root)</span><br><span class="line">        flag =<span class="literal">True</span>  <span class="comment"># 表示flag非空</span></span><br><span class="line">        <span class="keyword">while</span> s1 <span class="keyword">or</span> s2:</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                node = s1.pop()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    s2.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    s2.append(node.right)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> s1:</span><br><span class="line">                    res.append(tmp)</span><br><span class="line">                    tmp = []</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = s2.pop()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    s1.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    s1.append(node.left)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> s2:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    res.append(tmp)</span><br><span class="line">                    tmp = []</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-98-验证二叉搜索树</title>
    <url>/2019/11/26/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>首先二叉搜索树（二叉排序树，二叉查找树）的概念：</p>
<blockquote>
<p>它或者是一棵空树，</p>
<p>或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照概念，只需要递归判定就好了。</p>
<p>如果左节点符合，右节点符合，且根的值也符合 left&lt;root&lt;right，则符合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root, <span class="number">-2</span>**<span class="number">32</span>, <span class="number">2</span>**<span class="number">32</span><span class="number">-1</span>)  <span class="comment"># 这个地方有trick 借用最大最小值来完成</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= left <span class="keyword">or</span> root.val &gt;= right: <span class="comment"># 记得带上等号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.helper(root.left,left,root.val) <span class="keyword">and</span> self.helper(root.right, root.val, right)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-95-不同的二叉搜索树（具体路径）</title>
    <url>/2019/11/26/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/</url>
    <content><![CDATA[<h2 id="不同的二叉搜索树II"><a href="#不同的二叉搜索树II" class="headerlink" title="不同的二叉搜索树II"></a>不同的二叉搜索树II</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bg9rbsntj30v20nq768.jpg" alt="image-20191126145946420"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没有思路…. 看一下人家是怎么解决的</p>
<p>总的解决是两个部分</p>
<ul>
<li>先构建以i为根的树，构建过程可以依靠递归来实现</li>
<li>再遍历构建好的树，进行左—右的排列组合</li>
</ul>
<p>这样就完成了以i为根的所有可能情况的搜索，然后再按照这样的办法一次遍历1…N.</p>
<p>注意 要求的返回结果是 List[TreeNode]  相当于降低了难度，组装树的过程只需要考虑左右节点就可以了</p>
<p>==不要受题目描述的输出结果影响，实际输出只需要输出根节点就好了，系统内部应该会有一个遍历操作==</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span>    </span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>,n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;right:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]  <span class="comment"># 不可以直接返回None  函数之间返回的都是 []</span></span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 1. 以为i根递归建树</span></span><br><span class="line">            left_tree = self.helper(left,i<span class="number">-1</span>)</span><br><span class="line">            right_tree = self.helper(i+<span class="number">1</span>,right)</span><br><span class="line">						<span class="comment"># 2. 以i为根对左右两侧进行排列组合</span></span><br><span class="line">            <span class="keyword">for</span> l_tree <span class="keyword">in</span> left_tree:</span><br><span class="line">                <span class="keyword">for</span> r_tree <span class="keyword">in</span> right_tree:</span><br><span class="line">                    root = TreeNode(i)</span><br><span class="line">                    root.left = l_tree</span><br><span class="line">                    root.right = r_tree</span><br><span class="line">                    <span class="comment"># 3. 排好的结果加入结果集</span></span><br><span class="line">                    res.append(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 数据形式 [TreeNode1,TreeNode2,....TreeNode...]</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>实习期间的租房体验</title>
    <url>/2019/11/26/%E5%AE%9E%E4%B9%A0%E7%A7%9F%E6%88%BF/</url>
    <content><![CDATA[<h3 id="租房原因"><a href="#租房原因" class="headerlink" title="租房原因"></a>租房原因</h3><p>实习立项，学院要求搬出校区，只能在外边租房住。还好是个码农，可以靠实习工资基本贴补下租房的费用。</p>
<h3 id="租房选择"><a href="#租房选择" class="headerlink" title="租房选择"></a>租房选择</h3><p>其实租房的时候，可选择的空间特别大，条件也特别多，如果漫无目的的去找房子很费时间很费力气，还很费鞋子。所有需要自己优先确定好3个自己最在意的事情，基本上按照这3个标准（就一个标准也行）然后排查一下就可以很快的定位出租房范围，然后价格差不多的情况下，中介靠谱就签了。</p>
<p>我的三个标准：</p>
<ul>
<li>租房最好在公司附近，每天路上的时间一定一定不要超过1小时，半小时最好</li>
<li>合租房间其他卧室正常（最好几室就几个人住）</li>
<li>价格是实习工资的一半，要不就活不下去了</li>
</ul>
<p>第一个条件是比较坚决的，第二三个条件可以波动。</p>
<h3 id="中介"><a href="#中介" class="headerlink" title="中介"></a>中介</h3><p>永丰南那里中润置家还是挺好的，至少我租了6个月的体验还算可以吧</p>
<p>肖家河东西区那边就是合美家还可以，就是收服务费这个事情一定要搞清楚</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-96-不同的二叉搜索树</title>
    <url>/2019/11/25/leetcode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9anyc2kikj30iw06st8u.jpg" alt="image-20191125223959254"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则</p>
<script type="math/tex; mode=display">G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)</script><p>当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>$ f(i)=G(i−1)∗G(n−i) $</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9ao389x1kj30ss09oabr.jpg" alt="image-20191125224443905"></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>重点感受下将一个大问题划分为小问题，并且存在较多重复子问题时候考虑dp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 当出现节点个数为0表示None 也算一个节点</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>): <span class="comment"># i相当于 数字总数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>): <span class="comment"># j 相当于每次作为根的数字</span></span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>]*dp[i-j] <span class="comment"># 以j为根，左侧总数*右侧总数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-94-二叉树中序遍历</title>
    <url>/2019/11/25/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h1><p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3</p>
<p>输出: [1,3,2]</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>1.递归解决很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        self.inorderTraversal(root.left)</span><br><span class="line">        self.res.append(root.val)</span><br><span class="line">        self.inorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
<p>2.迭代方式解决</p>
<p>思路：模拟递归调用，用栈来实现系统的递归调用栈</p>
<p>需要一个栈来记录，需要一个cur来表示当前节点</p>
<ul>
<li>如果栈不空且cur不空 则循环：<ul>
<li>如果cur.left不空，则循环压栈：<ul>
<li>将cur的左边节点压栈</li>
<li>Cur = cur.left</li>
</ul>
</li>
<li>栈顶出栈 且获取该节点的数值</li>
<li>该节点右节点压栈</li>
<li>cur指向当前节点（此时当前节点为上一步节点的右节点）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            </span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            cur = node.right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题目：单链表快排</title>
    <url>/2019/11/25/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<h1 id="单链表快排"><a href="#单链表快排" class="headerlink" title="单链表快排"></a>单链表快排</h1><p>微软小冰组实习生面试</p>
<p>给一个单链表，按照快排的思想将单链表进行快速排序</p>
<p>相似题目leetcode 148 排序链表（上面解法使用的是归并排序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单链表的快速排序</span></span><br><span class="line"><span class="comment"># 微软小冰一面笔试题 已挂</span></span><br><span class="line"><span class="comment"># 思考问题复杂了，真正交换的过程不用考虑节点交换，只需要交换节点的值就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要数组，其中的left right 就是链表可以进行遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    pivot = left.val</span><br><span class="line">    p = left  <span class="comment"># 用来返回中间</span></span><br><span class="line">    q = left  <span class="comment"># 用来遍历</span></span><br><span class="line">    <span class="keyword">while</span> q != right:  <span class="comment"># 注意此处的条件</span></span><br><span class="line">        <span class="keyword">if</span> q.val &lt; pivot:</span><br><span class="line">            p = p.next</span><br><span class="line">            <span class="comment"># swap 此处交换是 一个大值 和 一个小值的交换</span></span><br><span class="line">            <span class="keyword">if</span> p != q:</span><br><span class="line">                q.val, p.val = p.val, q.val</span><br><span class="line">        q = q.next</span><br><span class="line">    <span class="comment"># 交换一次  此处是pivot和目标位置的交换，交换后pivot被交换到了最终位置上</span></span><br><span class="line">    left.val, p.val = p.val, pivot</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left == right <span class="keyword">or</span> left.next == right:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    mid = partition(left, right)</span><br><span class="line">    quickSort(left, mid)</span><br><span class="line">    quickSort(mid.next, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    quickSort(head, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printList</span><span class="params">(head)</span>:</span></span><br><span class="line">    tmp = []</span><br><span class="line">    p = head</span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        tmp.append(p.val)</span><br><span class="line">        p = p.next</span><br><span class="line"></span><br><span class="line">    print(tmp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 3 5 2 4 1</span></span><br><span class="line">    head = ListNode(<span class="number">3</span>)</span><br><span class="line">    head.next = ListNode(<span class="number">5</span>)</span><br><span class="line">    head.next.next = ListNode(<span class="number">2</span>)</span><br><span class="line">    head.next.next.next = ListNode(<span class="number">4</span>)</span><br><span class="line">    head.next.next.next.next =ListNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    printList(head)</span><br><span class="line">    sort(head)</span><br><span class="line">    printList(head)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>面试题目</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-1104-二叉树寻路</title>
    <url>/2019/11/25/leetcode-1104-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode-15-三数之和</title>
    <url>/2019/11/25/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>完全异于2Sum的思路</p>
<ul>
<li><p>特殊情况处理None等。。。</p>
</li>
<li><p>首先通过排序使数字基本有序</p>
<blockquote>
<p>预排序，通过预排序方便处理重复的情况，这样相同的数字都在一块，跳过则方便。而且本身是$O(n^3)$的时间复杂度，用一个排序才$O(nlogn)$还是划得来</p>
<p>本题解题思路体现了很重要的一点，当复杂度高于排序的时间复杂度时候，可以通过预排序来降低时间复杂度。毕竟做一次排序的时间复杂度为O(NlogN)，所有数字排序之后，就有了很好的特性<strong>有序</strong>。</p>
</blockquote>
</li>
<li><p>遍历排序后的数组</p>
<ul>
<li>如果num[i] &gt;0 说明其后元素都&gt;0 不会出现相加为0情况 break</li>
<li>如果i&gt;0 and num[i] == num[i-1]，说明当前i为重复情况 ，可考虑跳过</li>
<li>令left = i+1 right = n-1 (相当于左右指针):left&lt;right 循环<ul>
<li>如果三数相加为0 则找到匹配的，加入结果集，并且依次排出（跳过）left(或right)为相似值的情况</li>
<li>如果三数相加&lt;0，说明不够大，则left++</li>
<li>如果三数相加&gt;0，说明太大了，则right—</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><p>预排序$O(nlogn)$，遍历数组的过程是$O(n)$ 双指针遍历$O(n)$，总的来说还是$O(n^2)$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 预排序 很重要</span></span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> : </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            right = len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right]) == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i],nums[left],nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> nums[right] == nums[right<span class="number">-1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span>  <span class="comment"># 这个地方需要注意 要把数移动到下一个不一样的数那里 </span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> (nums[i] + nums[left] + nums[right]) &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-237-删除链表中的节点</title>
    <url>/2019/11/21/leetcode-237/</url>
    <content><![CDATA[<h1 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h1><p>普通删除方法是有前一个节点，然后将前一个节点的next指向待删除节点的下一个节点，这样完成了当前节点的删除</p>
<p>问题是</p>
]]></content>
  </entry>
  <entry>
    <title>打家劫舍系列题组(198/213/337)</title>
    <url>/2019/11/21/leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="打家劫舍系列"><a href="#打家劫舍系列" class="headerlink" title="打家劫舍系列"></a>打家劫舍系列</h1><p>这个题可以深刻的领悟到dp过程中的一个思想：就是对于某一个状态，我存在两种选择，要或者不要 </p>
<p>如果要 考虑要的情况，如果不要考虑不要的情况。</p>
<h2 id="Leetcode-198-easy"><a href="#Leetcode-198-easy" class="headerlink" title="Leetcode 198 easy"></a>Leetcode 198 easy</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>示例 2:</p>
<p>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单dp过程，优化方法：只和前后两个状态有关，没必要维护一个数组，考虑两个变量就OK了</p>
<p>基本dp 状态转移方程：</p>
<script type="math/tex; mode=display">
dp[n+1] = max(dp[n-1]+num[n+1],dp[n])</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span>]*n </span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line"><span class="comment">## 优化了存储空间的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  	<span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    		<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      	pre = <span class="number">0</span></span><br><span class="line">      	cur = <span class="number">0</span></span><br><span class="line">      	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        		tmp = cur</span><br><span class="line">        		cur = max(pre+nums[i],cur)</span><br><span class="line">        		pre = tmp</span><br><span class="line">      	<span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
<p>其中max就是来选择两种状态的最大值，其中$dp[n-1]+num[n+1]$就是n+1状态我要的结果，$dp[n]$就是n+1状态我不要的结果，通过max做出选择。</p>
<h2 id="Leetcode-213-medium"><a href="#Leetcode-213-medium" class="headerlink" title="Leetcode 213 medium"></a>Leetcode 213 medium</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着<strong>第一个房屋和最后一个房屋</strong>是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在基础上增加限制条件，实际问题就是两次leetcode-198的基础问题</p>
<p>第一次就是我要开始的节点那么我的序列就是[：-1]</p>
<p>第二次我要某位的节点不要开始的节点序列就是[1:]</p>
<p>对应两个数字序列，依次进行rob过程，最后再取这两个过程的最大值作为结果返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        head = self.helper(nums[:<span class="number">-1</span>])</span><br><span class="line">        tail = self.helper(nums[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(head,tail)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">             <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span>]*n</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-337-medium"><a href="#Leetcode-337-medium" class="headerlink" title="Leetcode 337 medium"></a>Leetcode 337 medium</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>示例 1:</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bfbwcv4ij30uo0c0t9i.jpg" alt="image-20191126142711223"></p>
<p>示例2：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bfe1ylhej30um0c8wfa.jpg" alt="image-20191126142918342"></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p> 2019年5月时候二面 头条实习生的题目，当时没写出来….</p>
</blockquote>
<p>之前的都是一维数组，来选择当前值是要还是不要，这里变成了树，树的好处就是可以通过递归来操作。</p>
<p>这里需要作出的选择是当前的根   是选择要还是不要</p>
<p>直接计算过程依靠递归也是从下到上完成的：即会先计算叶子节点然后逐层向上。</p>
<p>在当前节点时候，选择要或者不要的时候，下面的子节点已经计算好结果了</p>
<p>如果要当前节点的值：$要 = root.val + 左子节点不要 + 右子节点不要$</p>
<p>如果不要当前节点的值：$不要 = max(左要的值，左不要的值)+max(右要的值，右不要的值)$</p>
<p>不要当前节点的意思就是 当前root不要，那么该root可要获取的最大值就是 左最大+右最大</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        res = self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> max(res[<span class="number">0</span>],res[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        res = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># res[0] 表示不要根   res[1] 表示要根</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">				<span class="comment"># 不要根的值</span></span><br><span class="line">        res[<span class="number">0</span>] = max(left[<span class="number">0</span>],left[<span class="number">1</span>])+max(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 要根的值</span></span><br><span class="line">        res[<span class="number">1</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root.val</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>核心就是 res[不要根，要根] 的使用，相当于给每个树节点都有了一个数组，来进行存放不同情况的值</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-62-不同路径</title>
    <url>/2019/11/20/leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga7jzz42kuj30b4053gll.jpg" alt="img"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<p>向右 -&gt; 向右 -&gt; 向下</p>
<p>向右 -&gt; 向下 -&gt; 向右</p>
<p>向下 -&gt; 向右 -&gt; 向右</p>
</blockquote>
<p>示例 2:<br>&gt;</p>
<blockquote>
<p>输入: m = 7, n = 3<br>输出: 28</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>基于dp思想，其实就是对于第i行，第j列的点有多少种方案。</p>
<p>因为移动只能向右或者向下，那么对于i,j点，只能来自于其上或者其左侧点，所以对于i,j点，的路径数:</p>
<script type="math/tex; mode=display">
dp[i][j] = d[i][j-1] + dp[i-1][j]</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-33-搜索旋转排序数组</title>
    <url>/2019/11/18/leetcode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p><strong>腾讯视频NLP实习面试二面算法题</strong></p>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例 1:</p>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4<br>示例 2:</p>
<p>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>刚看到题，想到了剑指offer里面的那个题【旋转数组中的最小数字】，当时的思路是想直接找，但是发现判断条件依赖于 中间那个断开的地方<br>如果找到断开（旋转的地方）就很好解决了<br>所以这个题相当于两步，先找数组中的最小数字，再根据返回的最小数 二分全部 or 二分左 or 二分右</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_rotate_index</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[pivot] &gt; nums[pivot + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> pivot + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> nums[pivot] &lt; nums[left]:</span><br><span class="line">                        right = pivot - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            Binary search</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[pivot] == target:</span><br><span class="line">                    <span class="keyword">return</span> pivot</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; nums[pivot]:</span><br><span class="line">                        right = pivot - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] == target <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        rotate_index = find_rotate_index(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if target is the smallest element</span></span><br><span class="line">        <span class="keyword">if</span> nums[rotate_index] == target:</span><br><span class="line">            <span class="keyword">return</span> rotate_index</span><br><span class="line">        <span class="comment"># if array is not rotated, search in the entire array</span></span><br><span class="line">        <span class="keyword">if</span> rotate_index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> search(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> target &lt; nums[<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># search on the right side</span></span><br><span class="line">            <span class="keyword">return</span> search(rotate_index, n - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># search on the left side</span></span><br><span class="line">        <span class="keyword">return</span> search(<span class="number">0</span>, rotate_index)</span><br></pre></td></tr></table></figure>
<h3 id="更优的解法"><a href="#更优的解法" class="headerlink" title="更优的解法"></a>更优的解法</h3><p>不去找间断点，直接通过情况分类来处理</p>
<ul>
<li>前半部有序（指的是[3,4,5,6,7,0,12]，中间划开前面是[3,4,5,6]有序，后边是[7,0,1,2]不完全有序）<ul>
<li>target落在有序序列，即left—-mid中，则查找这个范围所以right = mid-1</li>
<li>target落在无序序列，即mid—right中，则left = mid+1</li>
</ul>
</li>
<li>后半部有序（指的是[6,7,0,1,2,3,4,5],中间划开，前面是[6,7,0,1]不完全有序，后边是[2,3,4,5]有序）<ul>
<li>target落在无序序列，即left—-mid中，则查找这个范围所以right = mid-1</li>
<li>target落在有序序列，即mid—right中，则left = mid+1</li>
</ul>
</li>
</ul>
<p><strong>策略更像分治</strong>通过将一个旋转数组，划分成了一个有序数组和一个新的旋转数组，那么只需要继续解决这两个问题即可。</p>
<blockquote>
<p>eg: 【6,7,0,1,2,3,4,5】一次划分后：新的旋转数组[6,7,0,1]和一个有序数组[,2,3,4,5]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[left]:  <span class="comment"># 前半部有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]: <span class="comment"># target落在有序序列</span></span><br><span class="line">                    right = mid <span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:																<span class="comment"># target 落在非有序序列</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-1-两数之和</title>
    <url>/2019/11/17/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>python 使用字典来减少遍历时间</p>
<p><strong>关键点</strong></p>
<ul>
<li>往字典存的过程是动态的从前向后的，也就是说 后边的每一次查找，其前面元素都放进字典里面了</li>
<li>也对应了题目要求：不能重复利用这个数组中同样的元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> nums == <span class="literal">None</span> <span class="keyword">or</span> nums == []:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            err = target - value</span><br><span class="line">            <span class="keyword">if</span> err <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> [d[err], index]</span><br><span class="line">            <span class="comment"># 不在就加入字典</span></span><br><span class="line">            d[value] = index</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2019/11/16/test/</url>
    <content><![CDATA[<p>This is a test markdown</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>日常awk命令汇总</title>
    <url>/2019/11/04/awk/</url>
    <content><![CDATA[<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>适用于文本处理和报表生成（是一种一旦学会了就会成为您的==战略代码库==的重要部分语言:laughing:）</p>
<p>awk处理文件的过程是一行一行读取并处理的，总是先去匹配pattern（模式），如果匹配成功就是执行action。</p>
<p>一句完整的awk指令也是由这两个部分组成的。</p>
<p>awk的print命令</p>
<p>普通输出，$0对应整个当前行，或者pritn “”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk '&#123; print $0 &#125;' /etc/passwd</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk -F <span class="string">":"</span> <span class="string">'&#123; print $1 " " $6 &#125;'</span> /etc/passwd</span></span><br><span class="line">这条命令对应，使用":"分割，并取分割后的第一位、第六位。（计数从1开始的）</span><br><span class="line">/etc/passwd 内的内容格式如下，使用:分割后，</span><br><span class="line">mengdi:x:10395:1001::/home/mengdi:/bin/bash</span><br><span class="line">mengdi  x  10395  1001  _  /home/mengdi:/bin/bash</span><br><span class="line">输出第1、6位，输出结果就是 mengdi /home/mengdi:/bin/bash</span><br><span class="line"></span><br><span class="line">解释$0， 上面$1 和 $6对应输出的是第一第六位，如果换成$0，则输出的就是整行文件。</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F <span class="string">":"</span>就是格式化分解，以：为分解符号</span></span><br><span class="line">上面的例子还可以通过格式化进行输出</span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F <span class="string">":"</span> <span class="string">'&#123; print "username: " $1 "\t\tuid:" $3 &#125;'</span> /etc/passwd</span></span><br><span class="line">上面这种输出就是格式化输出，加上自定义字符串以及变量。</span><br></pre></td></tr></table></figure>
<p>-F实际上是设置了FS变量分隔符，也可以通过外部脚步设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    FS=":"</span><br><span class="line">&#125;</span><br><span class="line">&#123;print $1&#125;</span><br></pre></td></tr></table></figure>
<p>awk 也可以像shell一样 编写脚本文件，然后来运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -f progfile     optional list of input files</span><br><span class="line">progfile 就是脚本程序</span><br></pre></td></tr></table></figure>
<h3 id="打印特定字段"><a href="#打印特定字段" class="headerlink" title="打印特定字段"></a>打印特定字段</h3><p>NF 表示字段数量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;print NF, $1, $NF&#125;</span><br><span class="line">会打印每行的字段数量，第一个字段的值，最后一个字段的值</span><br></pre></td></tr></table></figure>
<p><strong>计算和打印字段</strong></p>
<h3 id="按照某列条件筛选"><a href="#按照某列条件筛选" class="headerlink" title="按照某列条件筛选"></a>按照某列条件筛选</h3><p>按照第四列条件进行筛选， 如果第四列的值&lt;100 那么输出 该行全部内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F "\t" '$4&lt;100 &#123;print$0&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="按列合并数据"><a href="#按列合并数据" class="headerlink" title="按列合并数据"></a>按列合并数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'NR==FNR&#123;a[$1]=$0&#125;NR&gt;FNR&#123;print $1" "a[$2]&#125;' file2 file1</span><br></pre></td></tr></table></figure>
<p>应用成功的场景：</p>
<blockquote>
<p>data2_abolo是 从数据库拉回的数据，其数量&lt;原始数据，因为部分从数据库中 拉不到<br>目的就是让两个文件 按照docid 进行合并</p>
</blockquote>
<p>知识点：</p>
<ul>
<li><p>NR表示从最开始运行到现在处理的记录总行数</p>
</li>
<li><p>FNR表示当前文件的当前处理行数</p>
</li>
<li><p>NR==FNR 表示正在读取的是第一个文件，含义就是  当前处理总行数和 当前文件的处理行数相等</p>
</li>
<li><p>a[$1]=$0 表示把第一个文件的一行内容 都放入 数组a中。这个过程可以以一个例子来理解：</p>
<blockquote>
<p>一行内容 为 id+name：1234  xiaoming</p>
<p>那么执行a[$1]=$0 就相当于   a[‘1234’] = xiaoming</p>
<p>与其说是数组，不如说是字典 更加形象</p>
</blockquote>
</li>
<li><p>NR&gt;FNR 则表示 当前处理总行数 &gt; 当前文件行数  （第二个文件了）</p>
</li>
<li><p>执行判断，在读第二个文件时候，如果$1 in a  就是 第二个文件的 第一列的 内容 如果在a这个字典中的话，就输出print $0, a[$1]，即输出第二个文件的全部以及 存在字典a中的所有内容；否则只输出第二个文件的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F"\t" 'NR==FNR&#123;a[$1]=$0;next&#125; NR&gt;FNR&#123;if($1 in a)print $0, a[$1]; else print $0&#125;' data2_abolo  data2&gt; tttt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="按列求和"><a href="#按列求和" class="headerlink" title="按列求和"></a>按列求和</h3><p>场景：统计所有文件的行数的平均数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 统计文件数</span></span><br><span class="line">ls -l |wc |awk '&#123;total = $1&#125;;&#123;print total-1&#125; '</span><br><span class="line">100</span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算总数</span></span><br><span class="line">wc *|awk '&#123;sum += $1&#125;;END &#123;print sum/100&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="按列求平均值"><a href="#按列求平均值" class="headerlink" title="按列求平均值"></a>按列求平均值</h3><p>上面的 场景也可以用一条awk 来实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc *.txt|awk '&#123;sum += $1&#125;;END &#123;print sum/NR&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="改变输入输出分隔符"><a href="#改变输入输出分隔符" class="headerlink" title="改变输入输出分隔符"></a>改变输入输出分隔符</h3><p>FS : 输入字段分隔符，默认空格。</p>
<p>RS : 输入行分隔符，默认\n。</p>
<p>OFS : 输出字段分隔符，默认空格。</p>
<p>ORS : 输出行分隔符，默认\n。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;FS="\n";RS="";ORS=""&#125;&#123;for(x=1;x&lt;=NF;x++)&#123;print $x"\t"&#125; print "\n"&#125;' ./t.txt</span><br></pre></td></tr></table></figure>
<h3 id="按某列数值排序"><a href="#按某列数值排序" class="headerlink" title="按某列数值排序"></a>按某列数值排序</h3><p>（百度信息流一面问题）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;</span><br><span class="line">FS="|"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">ary[$</span><span class="bash">14,NR]=<span class="variable">$0</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">nrw=asorti(ary, newary)</span><br><span class="line">for(i=1;i&lt;=nrw;i++)</span><br><span class="line">print ary[newary[i]]</span><br><span class="line">&#125;' test.log |tail -n 10</span><br></pre></td></tr></table></figure>
<h3 id="将某列删除"><a href="#将某列删除" class="headerlink" title="将某列删除"></a>将某列删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk ‘$5=null;$0’ filename  &gt;</span><br></pre></td></tr></table></figure>
<p>将第5列置为null 也就是删去 保留其他列输出<code>$0</code></p>
<h3 id="给所有行加行号"><a href="#给所有行加行号" class="headerlink" title="给所有行加行号"></a>给所有行加行号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk ‘$0=NR"\t"$0’ filename</span><br></pre></td></tr></table></figure>
<p>awk 处理两个件的问题</p>
<p><a href="https://blog.csdn.net/song865850387/article/details/79761287" target="_blank" rel="noopener">https://blog.csdn.net/song865850387/article/details/79761287</a></p>
<p><a href="https://awk.readthedocs.io/en/latest/chapter-one.html" target="_blank" rel="noopener">https://awk.readthedocs.io/en/latest/chapter-one.html</a> 优先</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/shell/awk/awk-1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/shell/awk/awk-1/</a></p>
<p><a href="https://blog.csdn.net/shangboerds/article/details/49427535" target="_blank" rel="noopener">https://blog.csdn.net/shangboerds/article/details/49427535</a></p>
<p>awk 总结 +很多 使用例子</p>
<p><a href="https://www.cnblogs.com/jython/p/5224217.html" target="_blank" rel="noopener">https://www.cnblogs.com/jython/p/5224217.html</a></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
</search>
