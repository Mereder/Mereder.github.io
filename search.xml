<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面试过程中的概率问题</title>
    <url>/2020/07/27/%E9%9D%A2%E7%BB%8F/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="同一个圆上随机选3点，构成锐角三角形的概率"><a href="#同一个圆上随机选3点，构成锐角三角形的概率" class="headerlink" title="同一个圆上随机选3点，构成锐角三角形的概率"></a>同一个圆上随机选3点，构成锐角三角形的概率</h3>]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>基础算法/股票问题</title>
    <url>/2020/07/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="仅一次交易"><a href="#仅一次交易" class="headerlink" title="仅一次交易"></a>仅一次交易</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_val = float(<span class="string">'inf'</span>)</span><br><span class="line">        max_pro = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_val = min(price,min_val)</span><br><span class="line">            max_pro = max(max_pro,price-min_val)       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_pro</span><br></pre></td></tr></table></figure>
<h3 id="无限制交易"><a href="#无限制交易" class="headerlink" title="无限制交易"></a>无限制交易</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 贪心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt;= prices[i<span class="number">-1</span>]:</span><br><span class="line">                total+=prices[i]-prices[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
<h3 id="仅限制2笔"><a href="#仅限制2笔" class="headerlink" title="仅限制2笔"></a>仅限制2笔</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int T_i20 = <span class="number">0</span>;</span><br><span class="line">        int T_i21 = Integer.MIN_VALUE;</span><br><span class="line">        int T_i10 = <span class="number">0</span>;</span><br><span class="line">        int T_i11 = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            T_i20 = Math.max(T_i20,T_i21+prices[i]);</span><br><span class="line">            T_i21 = Math.max(T_i21,T_i10-prices[i]);</span><br><span class="line">            T_i10 = Math.max(T_i10,T_i11+prices[i]);</span><br><span class="line">            T_i11 = Math.max(T_i11,-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T_i20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="K笔交易"><a href="#K笔交易" class="headerlink" title="K笔交易"></a>K笔交易</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices <span class="keyword">or</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时，也可以直接把超大的k替换为数组的一半，就不用写额外的贪心算法函数</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; n//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.greedy(prices)</span><br><span class="line">        </span><br><span class="line">        dp, res = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], []</span><br><span class="line">        <span class="comment"># dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票</span></span><br><span class="line">        <span class="comment"># 设定在卖出时加1次交易次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>], dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> j:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="comment"># 「所有交易次数最后一天不持有股票」的集合的最大值即为问题的解</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            res.append(dp[n<span class="number">-1</span>][m][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理k过大导致超时的问题，用贪心解决</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greedy</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                res += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="含冷冻期"><a href="#含冷冻期" class="headerlink" title="含冷冻期"></a>含冷冻期</h3>]]></content>
  </entry>
  <entry>
    <title>项目总结/QLQ用户体验</title>
    <url>/2020/07/25/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/QLQ%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h3 id="Situations"><a href="#Situations" class="headerlink" title="Situations"></a>Situations</h3><p>由于历史演变原因，系统在线qlq暴露出来很多问题不能很好的满足凤巢新的用户体验标准对建模的要求：</p>
<ul>
<li>不能形成良好的客户优化良性互动</li>
<li>过度依赖广告创意维度特征，落地页引入严重不足，不能满足其建模的物理意义。</li>
<li></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>激活函数</title>
    <url>/2020/07/25/ML/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="为什么要用激活函数"><a href="#为什么要用激活函数" class="headerlink" title="为什么要用激活函数"></a>为什么要用激活函数</h3><p>对于深度学习中的神经网络，如何没有非线性激活函数，那么再深的网络也是退化到线性关系的。举例说明：</p>
<script type="math/tex; mode=display">
无激活函数 \\
F(x) = w_3(w_2(w_1x+b_1)+b_2)+b_3... \\
展开即为： \\
F(x) = w_3w_2w_1x + w_3w_2b_1+w_3b_2+b_3</script><h3 id="各个激活函数以及其导数"><a href="#各个激活函数以及其导数" class="headerlink" title="各个激活函数以及其导数"></a>各个激活函数以及其导数</h3><p>sigmoid：</p>
<script type="math/tex; mode=display">
f(z) = \frac{1}{1+e^{-wx+b}} = \frac{e^{wx+b}}{1+e^{wx+b}} \\
导数为： f(z)^{’} = f(z)(1-f(z))</script><h3 id="各个激活函数的优缺点"><a href="#各个激活函数的优缺点" class="headerlink" title="各个激活函数的优缺点"></a>各个激活函数的优缺点</h3><p>sigmoid 和 tanx 都是 中心附近增速快 ，两端增速慢。</p>
<p>导致</p>
<p>导致的问题就是 容易发生梯度爆炸和梯度消失，</p>
<p>relu 解决了梯度爆炸问题，但是引入了dead node 的问题，就是因为 负数部分无法激活，一旦参数进入了负数 该节点死掉。</p>
<p>所以有了 leaky relu，也就是让负数部分不完全无激活，而是给定了一个斜率较小的 激活方式。</p>
<p>以及 gelu，leaky relu 需要人工去调整负数区域激活的情况，所以gelu 使用用参数来去调整，让其学习。</p>
<h3 id="激活函数使用场景"><a href="#激活函数使用场景" class="headerlink" title="激活函数使用场景"></a>激活函数使用场景</h3>]]></content>
  </entry>
  <entry>
    <title>Leetcode-655-输出二叉树</title>
    <url>/2020/07/01/Leetcode/leetcode-655-%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="655-输出二叉树"><a href="#655-输出二叉树" class="headerlink" title="655 输出二叉树"></a>655 输出二叉树</h3><p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p>
<p>行数 m 应当等于给定二叉树的高度。<br>列数 n 应当总是奇数。<br>根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。<br>每个未使用的空间应包含一个空的字符串””。<br>使用相同的规则输出子树。<br>示例 1:</p>
<p>输入:<br>     1<br>    /<br>   2<br>输出:<br>[[“”, “1”, “”],<br> [“2”, “”, “”]]<br>示例 2:</p>
<p>输入:<br>     1<br>    / \<br>   2   3<br>    \<br>     4<br>输出:<br>[[“”, “”, “”, “1”, “”, “”, “”],<br> [“”, “2”, “”, “”, “”, “3”, “”],<br> [“”, “”, “4”, “”, “”, “”, “”]]<br>示例 3:</p>
<p>输入:<br>      1<br>     / \<br>    2   5<br>   /<br>  3<br> /<br>4<br>输出:<br>[[“”,  “”,  “”, “”,  “”, “”, “”, “1”, “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“”,  “”,  “”, “2”, “”, “”, “”, “”,  “”,  “”,  “”,  “5”, “”, “”, “”]<br> [“”,  “3”, “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“4”, “”,  “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]]<br>注意: 二叉树的高度在范围 [1, 10] 中。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目不难，都是跟树相关的基础知识</p>
<ul>
<li>求树高</li>
<li>根据树高求满二叉树节点个数</li>
<li>递归先序遍历 填槽（有分治思想在里面）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printTree</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 1. 求树高</span></span><br><span class="line">        depth = self.depth(root)</span><br><span class="line">        m = depth</span><br><span class="line">        <span class="comment"># 2. 观察题目，列就是 满二叉树的所有节点个数</span></span><br><span class="line">        n = <span class="number">2</span>**depth<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 3。 初始化结果集， 先序遍历填</span></span><br><span class="line">        res = [[<span class="string">""</span>]*(n) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment"># 4. 带左右边界的 先序遍历</span></span><br><span class="line">        self.helper(res, <span class="number">0</span>, <span class="number">0</span>, n, root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, res, depth, left, right, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        res[depth][mid] = str(root.val)</span><br><span class="line">        <span class="comment"># 有种分治的感觉</span></span><br><span class="line">        self.helper(res, depth+<span class="number">1</span>, left, mid<span class="number">-1</span>, root.left)</span><br><span class="line">        self.helper(res, depth+<span class="number">1</span>, mid+<span class="number">1</span>, right, root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left = self.depth(root.left)</span><br><span class="line">        right = self.depth(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-739-每日温度</title>
    <url>/2020/07/01/Leetcode/leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739 每日温度"></a>739 每日温度</h3><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<p><strong>单调栈</strong></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> T:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        n  = len(T)</span><br><span class="line">        res = [<span class="number">0</span>]*n</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[i] &gt; T[stack[<span class="number">-1</span>]]:</span><br><span class="line">                top = stack.pop()</span><br><span class="line">                res[top] = i - top</span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>树的基本操作</title>
    <url>/2020/07/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>使用栈来存放数据，但是栈内数据是单调的，以完成某种要求下的最优值</p>
<p>一般单调栈存储下标，</p>
<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><ul>
<li><h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4><blockquote>
<p>单调递增栈  栈内存放下标 出栈时 计算 宽度和广度</p>
</blockquote>
</li>
<li><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h4><p>单调递减栈，遇到较大则进行操作，否则进栈</p>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>单调栈</category>
      </categories>
  </entry>
  <entry>
    <title>python/生成器</title>
    <url>/2020/05/22/python/%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>yield 关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">  print()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>计算广告/基本资料</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E5%9F%BA%E6%9C%AC%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/8c591feb9fc4" target="_blank" rel="noopener">https://www.jianshu.com/p/8c591feb9fc4</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1132251" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1132251</a></p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-152-乘积最大数组</title>
    <url>/2020/04/13/Leetcode/leetcode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>考虑负数出现的情况，使用cur_max 和cur_min分别记录最大值和最小值。如果有负数情况，最小值会是负的。</p>
</blockquote>
<h2 id="乘积最大数组"><a href="#乘积最大数组" class="headerlink" title="乘积最大数组"></a>乘积最大数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。</p>
<p>示例 1:</p>
<p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p>
<p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        cur_max = <span class="number">0</span></span><br><span class="line">        cur_min = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                cur_max,cur_min = cur_min,cur_max</span><br><span class="line">            cur_max = max(cur_max*nums[i],nums[i])</span><br><span class="line">            cur_min = min(cur_min*nums[i],nums[i])</span><br><span class="line">            res = max(res,cur_max)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        cur_max = <span class="number">0</span></span><br><span class="line">        cur_min = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            t = cur_max</span><br><span class="line">            cur_max = max(cur_max*nums[i],nums[i],cur_min*nums[i])</span><br><span class="line">            cur_min = min(cur_min*nums[i],nums[i],t*nums[i])</span><br><span class="line">            res = max(res,cur_max)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-57-插入区间</title>
    <url>/2020/04/13/Leetcode/leetcode-57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="插入区间"><a href="#插入区间" class="headerlink" title="插入区间"></a>插入区间</h2><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<p>示例 1:</p>
<p>输入: intervals = [[1,3],[6,9]], newInterval = [2,5]<br>输出: [[1,5],[6,9]]<br>示例 2:</p>
<p>输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>输出: [[1,2],[3,10],[12,16]]<br>解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/insert-interval" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-interval</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>重点是找到重合的区域：</p>
<blockquote>
<p>重合的区域，那就有 待插入区间的左侧在 某个区间内部，</p>
<p>待插入区间的右侧在某个区间内部。</p>
<p>问题转化为去找两个满足条件的区间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">while</span> cur &lt; n <span class="keyword">and</span> newInterval[<span class="number">0</span>] &gt; intervals[cur][<span class="number">1</span>]:</span><br><span class="line">        ...</span><br><span class="line">        cur += <span class="number">1</span></span><br><span class="line">如果待插入的区间最左侧大于区间的右侧，那么就下一个，直到找到存在相交的区间</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">while</span> cur &lt; n <span class="keyword">and</span> newInterval[<span class="number">1</span>] &gt;= intervals[cur][<span class="number">0</span>]:</span><br><span class="line">        ...</span><br><span class="line">基本原理同上。</span><br></pre></td></tr></table></figure>
<p>对于找到的重合区间怎么做呢，所以找这些所有重合区间的最左端 和 最右端，合并为一个区间</p>
<p>所以使用了一个 临时变量 $tmp  = [newInterval[0],newInterval[1]]$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        n = len(intervals)</span><br><span class="line">				<span class="comment"># cur 跳出时候 指向的正是 相交的区间</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt; n <span class="keyword">and</span> newInterval[<span class="number">0</span>] &gt; intervals[cur][<span class="number">1</span>]:</span><br><span class="line">            res.append(intervals[cur])</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        tmp = [newInterval[<span class="number">0</span>],newInterval[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur &lt; n <span class="keyword">and</span> newInterval[<span class="number">1</span>] &gt;= intervals[cur][<span class="number">0</span>]:</span><br><span class="line">            tmp[<span class="number">0</span>] = min(intervals[cur][<span class="number">0</span>],tmp[<span class="number">0</span>])</span><br><span class="line">            tmp[<span class="number">1</span>] = max(intervals[cur][<span class="number">1</span>],tmp[<span class="number">1</span>])</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        res.append(tmp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur &lt; n:</span><br><span class="line">            res.append(intervals[cur])</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>SwordOffer/二叉搜索树与双向链表</title>
    <url>/2020/04/12/SwordOffer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-236-二叉树的最低公共祖先</title>
    <url>/2020/04/11/Leetcode/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="二叉树的最低公共祖先"><a href="#二叉树的最低公共祖先" class="headerlink" title="二叉树的最低公共祖先"></a>二叉树的最低公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdq7b9wjdyj305k05aa9z.jpg" alt="img"></p>
<p>示例 1:</p>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>示例 2:</p>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>注意限制条件！！！</p>
<blockquote>
<p>所有节点都是唯一的</p>
<p>p,q不同且一定存在</p>
</blockquote>
<p>上面两个比较强的条件限制，所以可以避开一些情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">   	<span class="keyword">if</span> root==p <span class="keyword">or</span> root == q:</span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="comment"># 左边是None，说明左边没有P也没有Q</span></span><br><span class="line">      <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="comment"># 同上</span></span><br><span class="line">      <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:  <span class="comment"># p,q在 root的左右两边</span></span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>SwordOffer/二叉搜索树的最近公共祖先</title>
    <url>/2020/04/11/SwordOffer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode-190-颠倒二进制</title>
    <url>/2020/04/11/Leetcode/leetcode-190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<h2 id="颠倒二进制"><a href="#颠倒二进制" class="headerlink" title="颠倒二进制"></a>颠倒二进制</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p>示例 1：</p>
<p>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。<br>示例 2：</p>
<p>输入：11111111111111111111111111111101<br>输出：10111111111111111111111111111111<br>解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</p>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p>
<p>进阶:<br>如果多次调用这个函数，你将如何优化你的算法？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-bits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-bits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本想法，就是一位一位的处理，将低位的放到高位，所以有这样一个基本关系<code>低位的i</code> 对应<code>高位的31-i,i从0开始</code>。所以需要每次将数字的最低位跟1比较，判断然后再右移。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        p = <span class="number">31</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">             tmp = (n&amp;<span class="number">1</span>) &lt;&lt; p</span><br><span class="line">             n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">             res += tmp</span><br><span class="line">             p -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="高级思路"><a href="#高级思路" class="headerlink" title="高级思路"></a>高级思路</h3><p>分治思想:</p>
<p>基本的框架就是：</p>
<p>所以自顶向下就是先交换高16位和低16位，然后再交换每个16位里面的高8位，低8位</p>
<p>…</p>
<p>然后交换每个2位中的高1位和低1位。</p>
<p>主要用了两个</p>
<p><img src="https://pic.leetcode-cn.com/c57a82424197ba1f4091a67cc4a6c575b35dcc0bf9d077415838d3b22d4b1ff3-file_1585801736118" alt="来自官方题解"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        n = (n&gt;&gt;<span class="number">16</span>) | (n&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        n = (n&amp;(<span class="number">0xff00ff00</span>))&gt;&gt;<span class="number">8</span> | (n&amp;(<span class="number">0x00ff00ff</span>))&lt;&lt;<span class="number">8</span></span><br><span class="line">        n = (n&amp;<span class="number">0xf0f0f0f0</span>)&gt;&gt;<span class="number">4</span> | (n&amp;(<span class="number">0x0f0f0f0f</span>))&lt;&lt;<span class="number">4</span></span><br><span class="line">        n = (n&amp;<span class="number">0xcccccccc</span>)&gt;&gt;<span class="number">2</span> | (n&amp;(<span class="number">0x33333333</span>))&lt;&lt;<span class="number">2</span></span><br><span class="line">        n = (n&amp;<span class="number">0xaaaaaaaa</span>)&gt;&gt;<span class="number">1</span> | (n&amp;(<span class="number">0x55555555</span>))&lt;&lt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>二进制中1的个数</title>
    <url>/2020/04/11/SwordOffer/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-40-组合总和II</title>
    <url>/2020/04/06/Leetcode/leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/</url>
    <content><![CDATA[<h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]<br>示例 2:</p>
<p>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>注意细节问题：</p>
<ul>
<li>没有额外说明都是无重复的数，所以可能存在重复的元素</li>
<li>每个数字在组合中只能使用一次</li>
<li>解集中不能包含重复的元素</li>
</ul>
<p>针对细节问题的处理：</p>
<ul>
<li>可能存在重复的元素，那么需要使用预排序，这样重复的元素会挨到一起，如果重复的元素在同一层，显然是会出现重复情况的，所以同一层时候对于同一个元素，我们只选第一个，对于后边重复的都弃用</li>
<li>数字只能使用一次，那么下一次开始的位置就需要在当前位置的+1位（这样连visited 辅助数组都不需要了）</li>
<li>前面两个处理，保证了解集中不会出现重复的元素。</li>
</ul>
<p>对于问题1的处理，我们举个例子方便理解：什么叫做同一层，</p>
<blockquote>
<p>[6,2,2,2,2,2] target = 8</p>
<p>排序后: [2,2,2,2,6]</p>
<p>结果是 [[2,6],[2,2,2,2]]</p>
<p>对于第一层选了1个2，那么下一层可以从[2,2,2,6]中进行选择,且只能选一个，对于选了6，那么结果就是[2,6]</p>
<p>对于第二层也选了2，那么下一层可以从[2,2,6]中进行选择，</p>
<p>….  当4个2都选完后，构成一个解[2,2,2,2] ，从一棵树的角度来看的，这4个2是在不同的层</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        stack = []</span><br><span class="line">        self.res = []</span><br><span class="line">        self.helper(candidates,stack,target,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, candidates,stack,target,start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            self.res.append(stack.copy())</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">elif</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> idx &gt; start <span class="keyword">and</span> candidates[idx] == candidates[idx<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                stack.append(candidates[idx])</span><br><span class="line">                self.helper(candidates,stack,target-candidates[idx],idx+<span class="number">1</span>)</span><br><span class="line">                stack.pop()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-72-编辑距离</title>
    <url>/2020/04/06/Leetcode/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<p>示例 1：</p>
<p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)<br>示例 2：</p>
<p>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为什么选择dp？</p>
<p>这个是存在最优子问题结构的，比如示例给出的<code>horse</code>和 <code>ros</code>，其中包含的子问题就是<code>hors</code> 和<code>ros</code>的编辑距离，当然也可以是<code>horse</code>和<code>ro</code>的编辑距离。子问题解决了再看最终的<code>horse</code>和<code>ros</code>的情况。由上面分析也可以知道，由于word1 和word2都需要考虑他们的子串对应的情况，所以是个二维dp。</p>
<p>其次就是dp 情况的说明：</p>
<blockquote>
<p>$dp[i][j]$表示的word1 前i个字符和word2的前j个字符对应的编辑距离（最少操作次数）</p>
<p>状态转移方程呢？</p>
<p>当 word1第i个字符 == word2第j个字符，那么说明这个位置不用处理，编辑距离就等于 各前一个字符处的情况，即：$dp[i][j] = d[i-1][j-1]$</p>
<p>当 word1第i个字符 ！= word2第j个字符，那么存在3种情况，分别为 插入、删除、替换。</p>
<p>因为问题是 最少的操作从word1变到word2，</p>
<p>所以插入操作就是在前i-1个字符基础上插入一个字符得到当前的，即$dp[i][j] = dp[i1-][j]$</p>
<p>对应删除操作是指，删除当前i所对应的字符，对应的就是$dp[i][j] = dp[i][j-1]$</p>
<p>对应替换操作，就是将i对应的字符换成j对应的字符，那么就是$dp[i][j] = dp[i-1][j-1]$</p>
<p>而我们要求的是最少操作次数，所以需要看上面三种情况 哪个情况的操作次数最少。</p>
<p>$dp[i][j] =min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j]) + 1$</p>
<p>最后的<code>+1</code>是指上面操作都需要一次操作</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 搞明白dp 的含义</span></span><br><span class="line">        <span class="comment"># dp[i][j] 表示 word1 前i个字符变到  word2前j个字符 需要的操作次数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word1 <span class="keyword">or</span> <span class="keyword">not</span> word2:</span><br><span class="line">            <span class="keyword">return</span> len(word1) <span class="keyword">or</span> len(word2)</span><br><span class="line">        n1 = len(word1)</span><br><span class="line">        n2 = len(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>自我介绍</title>
    <url>/2020/04/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>抓住自己擅长的地方和领域，引导面试官往自己的领域靠近。</p>
<p>我叫孟迪，本科就读于北京交通大学计算机与科学专业，现在就读于北京大学软件工程专业，研究生二年级。想要应聘的是软件开发工程师实习生，更确切的是做算法工程相关的职位。我之前有过两份算法实习的经历，一份是在网易新闻做NLP相关的工作，主要任务是构建新闻内容质量生态，涉及打三俗、正文优化等工作。最近的这份实习是在京东做电商的搜索排序工作，主要负责的rerank 模块从0到1的构建过程。两份算法工程师的实习都是偏工程实践的，不是算法研究的那种。即为了解决什么样的问题，可以将什么样的算法进行应用，以及是否能达到预期标准，是否能满足系统的要求。我自己对实践一个比较新的算法，应用到实际的生产数据中，能够work并且能够满足客户的需求，非常感兴趣。</p>
]]></content>
  </entry>
  <entry>
    <title>项目分析——STAR方法</title>
    <url>/2020/04/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/STAR%E8%A1%8C%E4%B8%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="STAR-方法"><a href="#STAR-方法" class="headerlink" title="STAR 方法"></a>STAR 方法</h2><p>STAR是一种结构化的方法，来回答基于行为的面试问题，再根据您描述的场景、任务、行动和结果展开讨论。详情如下：</p>
<p> （来源于亚马逊的<a href="https://www.amazon.jobs/zh/landing_pages/in-person-interview" target="_blank" rel="noopener">现场面试准备</a>）</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>描述你之前所经历的一次情况，或者你需要完成的一件任务。为面试官提供足够的细节来了解情况里的复杂性。您所描述的例子可以来自您之前的工作，学校作业，志愿者活动或任何相关事件。</p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>您朝着什么目标努力？</p>
<h3 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h3><p>描述您针对有关情况所采取的行动，并提供足够的细节；阐述时请将重点放在您的身上。 你采取了哪些具体步骤？ 你的具体的贡献是什么？ 注意，描述时请不要将焦点偏至您团队或小组的贡献。让我们了解您的个人贡献阐述行动时，请使用 “我” 而不是 “我们”</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>描述您的行动所得的结果，无需谦虚，并且将属于您的成就讲述出来。发生了什么？ 事情是如何结束的？ 您获得了什么成就？ 您学习到了什么？ 如果适宜，请提供指标或数据的示例。</p>
<p>考虑您自己在领导力准则方面的成功和失败。准备具体的例子来体现您的专业知识，并展示你在这个过程中如何冒险，成功，失败和成长。亚马逊最成功的一些项目是从失败的项目中脱颖而出的。失败是成功之母，是创新的必经之路。是必须经历的途径。我们了解这一点，并相信我们应该尽早尝试，失败，然后改进，直到成功。</p>
]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode/leetcode周赛183场</title>
    <url>/2020/04/05/Leetcode/leetcode%E5%91%A8%E8%B5%9B183%E5%9C%BA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode-937-重新排列日志文件</title>
    <url>/2020/04/05/Leetcode/leetcode-937-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="重新排列日志文件"><a href="#重新排列日志文件" class="headerlink" title="重新排列日志文件"></a>重新排列日志文件</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意的理解，实际上就是重新定义一个排序规则</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-1192-查找集群内的关键链接</title>
    <url>/2020/04/04/Leetcode/leetcode-1192-%E6%9F%A5%E6%89%BE%E9%9B%86%E7%BE%A4%E5%86%85%E5%85%B3%E9%94%AE%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="查找集群内的关键链接"><a href="#查找集群内的关键链接" class="headerlink" title="查找集群内的关键链接"></a>查找集群内的关键链接</h2><p>力扣数据中心有 n 台服务器，分别按从 0 到 n-1 的方式进行了编号。</p>
<p>它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 connections 是无向的。</p>
<p>从形式上讲，connections[i] = [a, b] 表示服务器 a 和 b 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p>
<p>「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p>
<p>请你以任意顺序返回该集群内的所有 「关键连接」。</p>
<p>示例 1：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdq6sxul29j30fc0frdgn.jpg" alt="img"></p>
<p>输入：n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]<br>输出：[[1,3]]<br>解释：[[3,1]] 也是正确的。</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 10^5<br>n-1 &lt;= connections.length &lt;= 10^5<br>connections[i][0] != connections[i][1]<br>不存在重复的连接</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/critical-connections-in-a-network" target="_blank" rel="noopener">https://leetcode-cn.com/problems/critical-connections-in-a-network</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据关键链接的定义，其实要找的是一条路径，可以完全连接起来整个图，这个路径里面有些边的缺失会导致不能完全连接，那么这个边就是 <code>关键链接</code></p>
<p>解题思路借鉴于<code>Tarjan</code>算法，重点在于两个辅助数组的使用。</p>
<p><code>dfn</code>用来记录当前节点的顺序值，该值是唯一的而且一旦确定不能修改</p>
<p><code>low</code>用来记录最早可以遍历到当前节点的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">criticalConnections</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 创建图</span></span><br><span class="line">        self.nodes = [<span class="number">0</span>]*n</span><br><span class="line">        self.edges = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        self.dfn = [<span class="number">0</span>]*n</span><br><span class="line">        self.low = [float(<span class="string">'inf'</span>)]*n</span><br><span class="line">        self.visited = [<span class="literal">False</span>]*n</span><br><span class="line"></span><br><span class="line">        self.res = []</span><br><span class="line">        self.time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> con <span class="keyword">in</span> connections:</span><br><span class="line">            self.edges[con[<span class="number">0</span>]].append(con[<span class="number">1</span>])</span><br><span class="line">            self.edges[con[<span class="number">1</span>]].append(con[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        self.tanjan(<span class="number">0</span>,<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tanjan</span><span class="params">(self,cur,parent)</span>:</span></span><br><span class="line">        self.time += <span class="number">1</span></span><br><span class="line">        self.dfn[cur] = self.time</span><br><span class="line">        self.low[cur] = self.time</span><br><span class="line">        self.visited[cur] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> self.edges[cur]:</span><br><span class="line">            <span class="keyword">if</span> nxt == parent:</span><br><span class="line">                <span class="keyword">continue</span>    </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.visited[nxt]:</span><br><span class="line">                self.tanjan(nxt,cur)</span><br><span class="line">                self.low[cur] = min(self.low[cur],self.low[nxt])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> self.low[nxt] &gt; self.dfn[cur]:</span><br><span class="line">                    self.res.append([cur,nxt]) </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.low[cur] = min(self.low[cur],self.dfn[nxt])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode/Leetcode-65-有效的数字</title>
    <url>/2020/04/03/Leetcode/Leetcode-65-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode-289-生命游戏</title>
    <url>/2020/04/02/Leetcode/leetcode-289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="生命游戏"><a href="#生命游戏" class="headerlink" title="生命游戏"></a>生命游戏</h2>]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-10-正则表达式匹配</title>
    <url>/2020/04/02/Leetcode/leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p>
<p>输入:<br>s = “aa”<br>p = “a<em>“<br>输出: true<br>解释: 因为 ‘</em>‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3:</p>
<p>输入:<br>s = “ab”<br>p = “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。<br>示例 4:</p>
<p>输入:<br>s = “aab”<br>p = “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5:</p>
<p>输入:<br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先用递归的思路，对于题目的理解会很深入，虽然超时不能完成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 只需要关系模式串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># 先匹配第一个 包含    字母匹配 和  .匹配</span></span><br><span class="line">        fistMatch = s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">'.'</span>&#125;</span><br><span class="line">        <span class="comment"># 再匹配 * 的问题</span></span><br><span class="line">        <span class="keyword">if</span> len(p)&gt;=<span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="comment"># 如果*代表的字符为0个，则直接跳过模式串的 ch* 继续比较剩下的模式串和主串</span></span><br><span class="line">            <span class="comment"># 如果*代表可以匹配一个或多个，则先匹配一个，即主串移动一个，模式串不动</span></span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s,p[<span class="number">2</span>:]) <span class="keyword">or</span> (bool(fistMatch) <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:],p))  <span class="comment"># 	</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 如果下一个字符不是*   则将主串和模式串都移动一次。</span></span><br><span class="line">            <span class="keyword">return</span> bool(fistMatch) <span class="keyword">and</span>  self.isMatch(s[<span class="number">1</span>:],p[<span class="number">1</span>:]) <span class="comment"># 都向前一步</span></span><br></pre></td></tr></table></figure>
<p>动态规划</p>
<p><code>dp[i][j]的含义，表示主串的前i个和模式串的前j个是否匹配，注意！！！这里i,j表示的是  前几个比如前3个，则指的是0，1，2 不包含3。</code></p>
<p>为什么这样呢？因为<code>dp[i][j]是我们要求的状态</code>,但是前面需要有一个空串的状态，实际上i=1的时候，在dp矩阵中才是字符串第一个字符，那么对应到字符串上 就是0的位置，所以是<code>i-1</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        </span><br><span class="line">        m = len(s)</span><br><span class="line">        n = len(p)</span><br><span class="line">        dp = [[<span class="literal">False</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">"*"</span> <span class="keyword">and</span> j &gt;= <span class="number">2</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span> <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> p[j<span class="number">-1</span>] != <span class="string">'*'</span>:</span><br><span class="line">                        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> p[j<span class="number">-1</span>] <span class="keyword">in</span> &#123;s[i<span class="number">-1</span>], <span class="string">'.'</span>&#125;:</span><br><span class="line">                            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 主串匹配了一个，模式串不动</span></span><br><span class="line">                        <span class="keyword">if</span> p[j<span class="number">-2</span>] <span class="keyword">in</span> &#123;s[i<span class="number">-1</span>],<span class="string">'.'</span>&#125;:</span><br><span class="line">                            dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i<span class="number">-1</span>][j]</span><br><span class="line">                        <span class="comment"># 匹配了0个，所以模式串去掉2个</span></span><br><span class="line">                        <span class="keyword">if</span> j &gt;= <span class="number">2</span>: </span><br><span class="line">                            dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i][j<span class="number">-2</span>]</span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-1111-有效括号的嵌套深度</title>
    <url>/2020/04/01/Leetcode/leetcode-1111-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="有效括号的嵌套深度"><a href="#有效括号的嵌套深度" class="headerlink" title="有效括号的嵌套深度"></a>有效括号的嵌套深度</h2><p>有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。</p>
<p>嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。</p>
<p>有效括号字符串类型与对应的嵌套深度计算方法如下图所示：</p>
<p>给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。</p>
<p>不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。<br>A 或 B 中的元素在原字符串中可以不连续。<br>A.length + B.length = seq.length<br>深度最小：max(depth(A), depth(B)) 的可能取值最小。<br>划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下：</p>
<p>answer[i] = 0，seq[i] 分给 A 。<br>answer[i] = 1，seq[i] 分给 B 。<br>如果存在多个满足要求的答案，只需返回其中任意 一个 即可。</p>
<p>示例 1：</p>
<p>输入：seq = “(()())”<br>输出：[0,1,1,1,1,0]<br>示例 2：</p>
<p>输入：seq = “()(())()”<br>输出：[0,0,0,1,1,0,1,1]<br>解释：本示例答案不唯一。<br>按此输出 A = “()()”, B = “()()”, max(depth(A), depth(B)) = 1，它们的深度最小。<br>像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = “()()()”, B = “()”, max(depth(A), depth(B)) = 1 。 </p>
<p>提示：</p>
<p>1 &lt; seq.size &lt;= 10000</p>
<p>有效括号字符串：</p>
<p>仅由 “(“ 和 “)” 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。<br>下述几种情况同样属于有效括号字符串：</p>
<ol>
<li>空字符串</li>
<li>连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串</li>
<li>嵌套，可以记作 (A)，其中 A 是有效括号字符串<br>嵌套深度：</li>
</ol>
<p>类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：</p>
<ol>
<li>s 为空时，depth(“”) = 0</li>
<li>s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串</li>
<li>s 为嵌套情况，depth(“(“ + A + “)”) = 1 + depth(A)，其中 A 是有效括号字符串</li>
</ol>
<p>例如：””，”()()”，和 “()(()())” 都是有效括号字符串，嵌套深度分别为 0，1，2，而 “)(“ 和 “(()” 都不是有效括号字符串。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2020/03/31/SwordOffer/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p>
<p>限制：</p>
<p>2 &lt;= n &lt;= 100000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本思路，拿个set()挨个筛就好了，如果没在就放进去，如果在里面直接返回即可。</p>
<p>时间复杂度<code>O(N)</code>,空间复杂度<code>o(N)</code></p>
<p>更优的思路：</p>
<p>注意题目给出的一个条件：数字都在0~n-1之中，那么说明我们数组本身的下标就可以拿来用了。</p>
<p>原理：如果一个数只存在一次，那么该数对应的下标位置只能是他自己。</p>
<p>我们做的操作相当于让每个数都回到其对应位置。</p>
<blockquote>
<p>举个例子：</p>
<p>[2,3,1,0,1]</p>
<p>首先 nums[0] 是2,  2!=0, 交换 nums[0],nums[2]的值： [1,3,2,0,1]</p>
<p>继续nums[0] 是1，1!=0, 交换 nums[0],nums[1]的值：[3,1,2,0,1]</p>
<p>继续nums[0]是3，3!=0, 交换nums[0],nums[3]的值：[0,1,2,3,1]</p>
<p>继续nums[0]是0, i+1  继续nums[1]是1，nums[2]是2，nums[3]是3</p>
<p>nums[4] 是1，4!=1，交换nums[1],nums[4]的值，但是发现 nums[4] == nums[1] 则返回即可</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 已经就位 则 下一个</span></span><br><span class="line">            <span class="keyword">if</span> i == nums[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># idx 是待归位数字</span></span><br><span class="line">                idx = nums[i]</span><br><span class="line">                <span class="keyword">if</span> idx == nums[idx]: <span class="comment"># 如果待归位的位置上数字与待归位数字相同 则返回即可</span></span><br><span class="line">                    <span class="keyword">return</span> nums[idx]</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 交换值</span></span><br><span class="line">                    nums[i],nums[idx] = nums[idx],nums[i]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1162-地图分析</title>
    <url>/2020/03/31/Leetcode/leetcode-1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p>
<p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p>
<p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p>
<p>示例 1：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdcemjsihij305502fq2y.jpg" alt="img"></p>
<p>输入：[[1,0,1],[0,0,0],[1,0,1]]<br>输出：2<br>解释：<br>海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。<br>示例 2：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdcemrmp9sj305402fq2y.jpg" alt="img"></p>
<p>输入：[[1,0,0],[0,0,0],[0,0,0]]<br>输出：4<br>解释：<br>海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。</p>
<p>提示：</p>
<p>1 &lt;= grid.length == grid[0].length &lt;= 100<br>grid[i][j] 不是 0 就是 1</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible" target="_blank" rel="noopener">https://leetcode-cn.com/problems/as-far-from-land-as-possible</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>多源BFS，标准做法。</p>
<p>而且这里的曼哈顿距离实际上就是 x便宜+y便宜</p>
<p>由于是求最终的 最大的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        q = []</span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    q.append((i,j))</span><br><span class="line">        dx = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line">        dy = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]  </span><br><span class="line">        last = (<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        hasOceon = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x,y = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                n_x,n_y = x+dx[i],y+dy[i]</span><br><span class="line">                <span class="keyword">if</span> n_x&lt;<span class="number">0</span> <span class="keyword">or</span> n_x&gt;=m <span class="keyword">or</span> n_y &lt;<span class="number">0</span> <span class="keyword">or</span> n_y &gt;=n <span class="keyword">or</span> grid[n_x][n_y]!=<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                hasOceon = <span class="literal">True</span></span><br><span class="line">                grid[n_x][n_y] = grid[x][y] + <span class="number">1</span></span><br><span class="line">                q.append((n_x,n_y)) </span><br><span class="line">            last = (x,y)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span>  hasOceon:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> grid[last[<span class="number">0</span>]][last[<span class="number">1</span>]]<span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>SwordOffer/圆圈中最后剩下的数字</title>
    <url>/2020/03/30/SwordOffer/%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode-周赛-182场</title>
    <url>/2020/03/29/Leetcode/leetcode%E5%91%A8%E8%B5%9B182%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="周赛182场"><a href="#周赛182场" class="headerlink" title="周赛182场"></a>周赛182场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/find-lucky-integer-in-an-array/" target="_blank" rel="noopener">找出数组中的幸运数</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/count-number-of-teams/" target="_blank" rel="noopener">统计作战单位数</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/design-underground-system/" target="_blank" rel="noopener">设计地铁系统</a><br><code>8 分</code> - <a href="https://leetcode-cn.com/problems/find-all-good-strings/" target="_blank" rel="noopener">找到所有好字符串</a></p>
<h3 id="T1：找出幸运数字"><a href="#T1：找出幸运数字" class="headerlink" title="T1：找出幸运数字"></a>T1：找出幸运数字</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先统计再查找</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLucky</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        d = defaultdict(int)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            d[num] += <span class="number">1</span></span><br><span class="line">        res = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> key,val <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">if</span> key == val:</span><br><span class="line">                res = max(res,key)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>时间复杂度 <code>O(N)</code>，空间复杂度<code>O(N)</code></p>
<h3 id="T2：统计作战单位"><a href="#T2：统计作战单位" class="headerlink" title="T2：统计作战单位"></a>T2：统计作战单位</h3><p>当时没有做出来，把问题想复杂了，甚至想到了1,3,6,10。。。这个序列：</p>
<blockquote>
<p>3个递增排列结果：1</p>
<p>4个的结果为：1+3</p>
<p>5个的结果为：1+3+6</p>
<p>6个的结果为：1+3+6+10…</p>
</blockquote>
<p>其实这里面已经包含了正确解法的思路。</p>
<p>根据原题意，其实就是找递增序列3个3个进行组合的个数</p>
<p>我们使用DP数组，来表示当前位置前面有几个比当前位置小的数。</p>
<p>举例说明：</p>
<blockquote>
<p>[1,2,3,4]</p>
<p>dp = [0,1,2,4]</p>
<p>dp[0] = 0表示前面没有比他小的数，也说明这个是序列的开始</p>
<p>dp[1] = 1表示前面有一个比他小的数，也说明这个说可以作为3个组合里面中间的那个，所以如果后边有比这个大的，则可以组成一个作战单位</p>
<p>dp[2] = 2 前面有2个比他小的数，前面有2个都比他小，他作为3个数中间那个，前面有2种选择，如果后边再有一个大的，则可以组成 2种作战单位</p>
<p>dp[3] = 3前面有3个比他小的数，如果他作为作战序列中间的，前面有3种选择，如果后边再有一个更大的当结尾，则可以有 3种作战序列</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTeams</span><span class="params">(self, rating: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(rating)</span>:</span></span><br><span class="line">            dp = [<span class="number">0</span>]*len(rating)</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(rating)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                    <span class="keyword">if</span> rating[i] &gt; rating[j]:</span><br><span class="line">                        dp[i] += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> dp[j] &gt; <span class="number">0</span>:</span><br><span class="line">                            res += dp[j]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(rating)+ helper(rating[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p>时间复杂度<code>O(N^2)</code> 空间复杂度<code>O(N)</code></p>
<h3 id="T3：设计地铁系统"><a href="#T3：设计地铁系统" class="headerlink" title="T3：设计地铁系统"></a>T3：设计地铁系统</h3><p>主要是使用数据结构的问题吧。</p>
<p>基本思路就是上车时候把乘客信息加入，下车时候，根据下车信息 以及该乘客的上车信息，将结果加入历史记录，方便之后算平均时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,id,startS,t)</span>:</span></span><br><span class="line">        self.id = id</span><br><span class="line">        self.startS = startS</span><br><span class="line">        self.startT = t</span><br><span class="line">        self.endS = <span class="string">''</span></span><br><span class="line">        self.endT = <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.passengers = &#123;&#125;</span><br><span class="line">        self.time = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIn</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># route create</span></span><br><span class="line">        <span class="keyword">if</span> stationName <span class="keyword">not</span> <span class="keyword">in</span> self.time:</span><br><span class="line">            self.time[stationName] = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        self.passengers[id] = Route(id,stationName,t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOut</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> id <span class="keyword">not</span> <span class="keyword">in</span> self.passengers:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        startS,startT = self.passengers[id].startS,self.passengers[id].startT</span><br><span class="line">        <span class="keyword">del</span> self.passengers[id]</span><br><span class="line">        endS = stationName</span><br><span class="line">        endT = t</span><br><span class="line">        <span class="comment"># route finish</span></span><br><span class="line">        <span class="keyword">if</span> endS <span class="keyword">not</span> <span class="keyword">in</span> self.time[startS]:</span><br><span class="line">            self.time[startS][endS] = [endT-startT]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.time[startS][endS].append(endT-startT)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAverageTime</span><span class="params">(self, startStation: str, endStation: str)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> startStation <span class="keyword">not</span> <span class="keyword">in</span> self.time <span class="keyword">or</span>  endStation <span class="keyword">not</span> <span class="keyword">in</span> self.time[startStation]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">        s = sum(self.time[startStation][endStation])</span><br><span class="line">        le = len(self.time[startStation][endStation])</span><br><span class="line">        res = s / le</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = UndergroundSystem()</span></span><br><span class="line"><span class="comment"># obj.checkIn(id,stationName,t)</span></span><br><span class="line"><span class="comment"># obj.checkOut(id,stationName,t)</span></span><br><span class="line"><span class="comment"># param_3 = obj.getAverageTime(startStation,endStation)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-673-最长递增子序列的个数</title>
    <url>/2020/03/29/Leetcode/leetcode-673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="最长递增子序列的个数"><a href="#最长递增子序列的个数" class="headerlink" title="最长递增子序列的个数"></a>最长递增子序列的个数</h2><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p>示例 1:</p>
<p>输入: [1,3,5,4,7]<br>输出: 2<br>解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。<br>示例 2:</p>
<p>输入: [2,2,2,2,2]<br>输出: 5<br>解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。<br>注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>之前求最长递增子序列，使用动态规划，用来记录以当前元素作为结尾的最长递增子序列的长度。</p>
<p>这个比较特殊的一点就是还需要额外记录可能形成的最长递增子序列的个数。</p>
<p>举例：</p>
<blockquote>
<p>[1,3,5,4,7] 如果只算最长递增子序列的长度，返回结果4。这个4是指 结果为[1,3,5,7] or [1,3,4,7]</p>
<p>那么最长递增子序列的个数就是2</p>
</blockquote>
<p>所以我们还需要记录下一当前元素结尾时的个数是多少。</p>
<blockquote>
<p>[1,3,5,4,7]</p>
<p>当遍历到i=1 时候，个数是1，因为只有一个递增子序列[1,3]</p>
<p>当遍历到i=2的时候，个数仍然是1，因为只有一个递增子序列为[1,3,5]</p>
<p>当遍历到i=3的时候，个数仍然是1，因为此时有递增子序列[1,3,4] 或者 [1,3,5]</p>
<p>当遍历到i=4的时候，由于7&gt;5， 当j遍历到5时候，更新cnt[i] = 1 表示当前最长递增子序列个数为1，且为(1,3,5,7)，当j遍历到5的时候，此时7&gt;4,但是两个的cnt值都是1，但是以7结尾长度是4，以4结尾的长度是3，所以以7结尾的计数结果应该加上以4结尾的计数结果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        length = [<span class="number">1</span>]*len(nums)</span><br><span class="line">        cnt = [<span class="number">1</span>] * len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    <span class="comment">######## 关键操作  ##########</span></span><br><span class="line">                    <span class="keyword">if</span> length[j] &gt;= length[i]:</span><br><span class="line">                        length[i] = length[j] + <span class="number">1</span></span><br><span class="line">                        cnt[i] = cnt[j]</span><br><span class="line">                    <span class="keyword">elif</span> length[j] + <span class="number">1</span> == length[i]: <span class="comment"># 已经有过</span></span><br><span class="line">                        cnt[i] += cnt[j]</span><br><span class="line">                    <span class="comment">############################</span></span><br><span class="line">        max_len = max(length)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        print(length)</span><br><span class="line">        print(cnt)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(length)):</span><br><span class="line">            <span class="keyword">if</span> length[i] == max_len:</span><br><span class="line">                res += cnt[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>基础算法/基础算法总结</title>
    <url>/2020/03/29/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://fuxuemingzhu.blog.csdn.net/article/details/101900729" target="_blank" rel="noopener">https://fuxuemingzhu.blog.csdn.net/article/details/101900729</a></p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-165-比较版本号</title>
    <url>/2020/03/28/Leetcode/leetcode-165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h2><p>比较两个版本号 version1 和 version2。<br>如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。</p>
<p>你可以假设版本字符串非空，并且只包含数字和 . 字符。</p>
<p> . 字符不代表小数点，而是用于分隔数字序列。</p>
<p>例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p>
<p>你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p>
<p>示例 1:</p>
<p>输入: version1 = “0.1”, version2 = “1.1”<br>输出: -1<br>示例 2:</p>
<p>输入: version1 = “1.0.1”, version2 = “1”<br>输出: 1<br>示例 3:</p>
<p>输入: version1 = “7.5.2.4”, version2 = “7.5.3”<br>输出: -1<br>示例 4：</p>
<p>输入：version1 = “1.01”, version2 = “1.001”<br>输出：0<br>解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。<br>示例 5：</p>
<p>输入：version1 = “1.0”, version2 = “1.0.0”<br>输出：0<br>解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。</p>
<p>提示：</p>
<p>版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。<br>版本字符串不以点开始或结束，并且其中不会有两个连续的点。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/compare-version-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/compare-version-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>以<code>.</code>划分，按照这个进行split，然后只需要诸位进行比较就可以了</p>
<p>这里有个小trick  就是之前做两个数加法（数是以链表形式给出的）</p>
<blockquote>
<p>如果下一个位置为None，可以给一个值为0进行表示</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareVersion</span><span class="params">(self, version1: str, version2: str)</span> -&gt; int:</span></span><br><span class="line">        v1 = version1.split(<span class="string">'.'</span>)</span><br><span class="line">        v2 = version2.split(<span class="string">'.'</span>)</span><br><span class="line">        </span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; len(v1) <span class="keyword">or</span> p2 &lt;len(v2):</span><br><span class="line">            <span class="keyword">if</span> p1&lt;len(v1):</span><br><span class="line">                x = int(v1[p1])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> p2&lt;len(v2):</span><br><span class="line">                y = int(v2[p2])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> x &lt; y:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">elif</span> x &gt; y:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetocde-93-复原IP地址</title>
    <url>/2020/03/28/Leetcode/leetcode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>示例:</p>
<p>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/restore-ip-addresses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/restore-ip-addresses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>刚开始想的是DFS，逐个遍历。后来想了下，IP地址就是用<code>.</code>划分成4个part，<code>.</code>的选取是很方便和快捷的。</p>
<p>只需要逐个放置<code>.</code>，后面放置的<code>.</code>依赖于前面的放置位置就可以了。</p>
<p>!!!  注意限制条件比较多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">4</span> <span class="keyword">or</span> len(s) &gt; <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i_1 <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">            p_1 = s[:i_1]</span><br><span class="line">            aft_1 = s[i_1:]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.check(p_1):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> i_2 <span class="keyword">in</span> range(i_1+<span class="number">1</span>,i_1+<span class="number">4</span>):</span><br><span class="line">                p_2 = s[i_1:i_2]</span><br><span class="line">                aft_2 = s[i_2:]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.check(p_2):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> i_3 <span class="keyword">in</span> range(i_2+<span class="number">1</span>,i_2+<span class="number">4</span>):</span><br><span class="line">                    p_3 = s[i_2:i_3]</span><br><span class="line">                    p_4 = s[i_3:]</span><br><span class="line">                    <span class="keyword">if</span> self.check(p_3) <span class="keyword">and</span> self.check(p_4):</span><br><span class="line">                        res.append(p_1+<span class="string">'.'</span>+p_2+<span class="string">'.'</span>+p_3+<span class="string">'.'</span>+p_4)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self,p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> p[<span class="number">0</span>]==<span class="string">'0'</span> <span class="keyword">and</span> len(p) &gt; <span class="number">1</span>:  <span class="comment">## 处理 '1.010.1.1'这种情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="number">0</span>&lt;=int(p)&lt;= <span class="number">255</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-914-卡牌分组</title>
    <url>/2020/03/27/Leetcode/leetcode-914-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h2 id="卡牌分组"><a href="#卡牌分组" class="headerlink" title="卡牌分组"></a>卡牌分组</h2><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<p>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;= 2 时返回 true。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards" target="_blank" rel="noopener">https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基础思路想的是暴力破解，首先需要对各个数的长度进行遍历，得到他们的计数。然后从计数最少的情况开始，进行分组，如果不能计数下一个继续进行分组。</p>
<p>举个例子：计数之后可能的个数有 2，3，4，5…</p>
<p>那就先按照2个进行分组，看看可不可以，可以返回True，不可以则用3继续进行。</p>
<p>时间复杂度<code>o(N^2)</code></p>
<p>其实上面的过程中，我们发现，如果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasGroupsSizeX</span><span class="params">(self, deck: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(deck) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        d = defaultdict(int)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> deck:</span><br><span class="line">            d[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        g = d[deck[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> key,val <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">if</span> key == deck[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            g = math.gcd(g,val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> g &gt;=<span class="number">2</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-922-按奇偶排序</title>
    <url>/2020/03/27/Leetcode/leetcode-922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="按奇偶排序"><a href="#按奇偶排序" class="headerlink" title="按奇偶排序"></a>按奇偶排序</h2><p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<p>示例：</p>
<p>输入：[4,2,5,7]<br>输出：[4,5,2,7]<br>解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</p>
<p>提示：</p>
<p>2 &lt;= A.length &lt;= 20000<br>A.length % 2 == 0<br>0 &lt;= A[i] &lt;= 1000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-array-by-parity-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一定要记得<strong>题目限制很严格</strong></p>
<p>即一半奇数，另一半是偶数。</p>
<p>那也就意味着，如果奇数位置上都是奇数了，偶数位置一定是偶数</p>
<p>双指针，一个奇数位，一个偶数位，对于偶数位置上不是偶数，则每次都是遍历奇数位置，找到不是奇数的位置进行交换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParityII</span><span class="params">(self, A: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">      odd = <span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> even <span class="keyword">in</span> range(<span class="number">0</span>,len(A),<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> A[even]%<span class="number">2</span> == <span class="number">1</span>: <span class="comment"># 偶数位置出现奇数</span></span><br><span class="line">          <span class="keyword">while</span> A[odd]%<span class="number">2</span> !=<span class="number">0</span>:  <span class="comment"># 直到找到奇数位置是偶数  跳出</span></span><br><span class="line">            odd += <span class="number">2</span></span><br><span class="line">          <span class="comment"># 进行交换</span></span><br><span class="line">          A[odd],A[even] = A[even],A[odd]</span><br><span class="line">      <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>翻转链表</title>
    <url>/2020/03/27/SwordOffer/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 5000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思考时候还是不要从第一个节点考虑，直接跳到中间某一个步骤开始</p>
<blockquote>
<p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p>
<p>假设已经得到了: 3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;NULL</p>
<p>请问如何继续操作</p>
<ol>
<li>需要维护一个p指针，此时指向1</li>
<li>需要一个head指针，指向3</li>
<li>然后操作3-&gt;2-&gt;1-&gt;5-&gt;NULL</li>
<li>然后把4拿到前面 4-&gt;3-&gt;2-&gt;1-&gt;5-&gt;NULL</li>
<li>记得更新指针head 到4</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p.next:</span><br><span class="line">            tmp = p.next</span><br><span class="line">            p.next = tmp.next</span><br><span class="line">            tmp.next = head</span><br><span class="line">            head = tmp</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习面试题目汇总</title>
    <url>/2020/03/26/%E9%9D%A2%E7%BB%8F/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="BN什么作用？如何实现"><a href="#BN什么作用？如何实现" class="headerlink" title="BN什么作用？如何实现"></a>BN什么作用？如何实现</h3><p><a href="https://zhuanlan.zhihu.com/p/33173246?utm_source=wechat_timeline&amp;utm_medium=social&amp;utm_oi=27943216611328&amp;from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33173246?utm_source=wechat_timeline&amp;utm_medium=social&amp;utm_oi=27943216611328&amp;from=timeline&amp;isappinstalled=0</a></p>
<h3 id="说一说常用的优化器"><a href="#说一说常用的优化器" class="headerlink" title="说一说常用的优化器"></a>说一说常用的优化器</h3><p><a href="https://zhuanlan.zhihu.com/p/32230623" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32230623</a></p>
<h3 id="常用激活函数和优缺点"><a href="#常用激活函数和优缺点" class="headerlink" title="常用激活函数和优缺点"></a>常用激活函数和优缺点</h3><ul>
<li><p>sigmoid</p>
<p>一般用在输出或者门控结构上，求导麻烦</p>
</li>
<li><p>tanh</p>
</li>
<li><p>relu</p>
</li>
<li><p>Leaky relu</p>
</li>
<li><p>Prelu</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>经典机器学习面试题目汇总</title>
    <url>/2020/03/26/%E9%9D%A2%E7%BB%8F/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="LR和SVM的异同点"><a href="#LR和SVM的异同点" class="headerlink" title="LR和SVM的异同点"></a>LR和SVM的异同点</h3><p>相同点：</p>
<ul>
<li>都是分类模型，且都是判别式模型（生成一个判别函数）</li>
<li>基础模型都是线性模型，（不考虑核函数）</li>
<li>监督学习模型</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>Loss计算的不同也就决定了根本的不同。LR是从概率角度出发，使用极大似然函数来估计值，认为样本为1的概率可以估计出来。SVM是几何间隔最大化，认为存在最大分类间隔面</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7pe1c4p7j310o0g477t.jpg" alt="image-20200326223418240"> </p>
</li>
<li><p>SVM只考虑局部的点（支持向量）而LR会考虑全局的点。那么就存在问题了</p>
<p>如果类别不均衡的话，对于SVM来说，只要支持向量足够找到划分的分类面即可。而对于LR来说，会导致出现学偏的问题。所以需要先对label进行均衡</p>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>美团推荐算法面经</title>
    <url>/2020/03/25/%E9%9D%A2%E7%BB%8F/%E7%BE%8E%E5%9B%A2%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>主要的使用的方法（rerank的模型），目的是实现多样性，但是好像模型里面并没有什么东西来保证能实现多样性。（没有多样性的loss， 只有多样性的特征但是不确定能起到多大的作用）</p>
<p>基础知识</p>
<p>BN操作（BatchNormalization） 原理，效果，如何操作的</p>
<p>xgboost的基本原理 </p>
<p>写题：</p>
<p>给一个方针，从右上角开始到左下角，一次输出平行于主对角线以及主对角线上的值。</p>
<p>思路很简单，因为主对角线上面是一种计算思路，主对角线以下是另一种思路</p>
<p>对于主对角线以上存在关系：`同一条线上：j-i = 固定值（1,…..n-1） </p>
<p>对于主对角线：<code>i-j=0   -&gt; i=j</code></p>
<p>对于主对角线以下存在关系：`同一条线上：i-j = 固定值（1,…..n-1）  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self,arr,n)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 上半部 以及主对角线</span></span><br><span class="line">    <span class="keyword">for</span> err <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        j = err - i</span><br><span class="line">        <span class="keyword">if</span>  <span class="number">0</span>&lt;=j&lt;n:</span><br><span class="line">          res.append(arr[i][j])</span><br><span class="line">    <span class="comment"># 下半部 </span></span><br><span class="line">    <span class="keyword">for</span> err <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        i = err - j</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;n:</span><br><span class="line">          res.append(arr[i][j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>。。。真的是 紧张什么…这个垃圾题，分分钟写完，面试时候写了20分钟。。。我。。。感觉挂了</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-892-三维形体的表面积</title>
    <url>/2020/03/25/Leetcode/leetcode-892-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="三维形体的表面积"><a href="#三维形体的表面积" class="headerlink" title="三维形体的表面积"></a>三维形体的表面积</h2><p>在 N <em> N 的网格上，我们放置一些 1 </em> 1 * 1  的立方体。</p>
<p>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。</p>
<p>请你返回最终形体的表面积。</p>
<p>示例 1：</p>
<p>输入：[[2]]<br>输出：10<br>示例 2：</p>
<p>输入：[[1,2],[3,4]]<br>输出：34<br>示例 3：</p>
<p>输入：[[1,0],[0,2]]<br>输出：16<br>示例 4：</p>
<p>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：32<br>示例 5：</p>
<p>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：46</p>
<p>提示：</p>
<p>1 &lt;= N &lt;= 50<br>0 &lt;= grid[i][j] &lt;= 50</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surface-area-of-3d-shapes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始上来考虑的是，使用投影方法，左右前后，四个方向投影，能看到的就是一侧的表面积，对于上下，分别加上不等于0的地方。</p>
<p>但是上面解法解决不了<code>[[1,1,1],[1,0,1],[1,1,1]]</code>中间被挖空了的问题。</p>
<p>下面的解法实际上就是搭积木的方法，一块块搭上去，每搭一块就处理一次跟之前积木存在重合的面积</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">surfaceArea</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] != <span class="number">0</span>:</span><br><span class="line">                    ans += grid[i][j]*<span class="number">4</span>+<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    ans -= min(grid[i][j],grid[i][j<span class="number">-1</span>])*<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    ans -= min(grid[i<span class="number">-1</span>][j],grid[i][j])*<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-904-水果成篮问题</title>
    <url>/2020/03/24/Leetcode/leetcode-904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/</url>
    <content><![CDATA[<h2 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h2><p>在一排树中，第 i 棵树产生 tree[i] 型的水果。<br>你可以从你选择的任何树开始，然后重复执行以下步骤：</p>
<ul>
<li>1.把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。</li>
<li>2.移动到当前树右侧的下一棵树。如果右边没有树，就停下来。</li>
</ul>
<p>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</p>
<p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。<br>用这个程序你能收集的水果总量是多少？</p>
<p>示例 1：</p>
<p>输入：[1,2,1]<br>输出：3<br>解释：我们可以收集 [1,2,1]。<br>示例 2：</p>
<p>输入：[0,1,2,2]<br>输出：3<br>解释：我们可以收集 [1,2,2].<br>如果我们从第一棵树开始，我们将只能收集到 [0, 1]。<br>示例 3：</p>
<p>输入：[1,2,3,2,2]<br>输出：4<br>解释：我们可以收集 [2,3,2,2].<br>如果我们从第一棵树开始，我们将只能收集到 [1, 2]。<br>示例 4：</p>
<p>输入：[3,3,3,1,2,1,1,2,3,3,4]<br>输出：5<br>解释：我们可以收集 [1,2,1,1,2].<br>如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 个水果。</p>
<p>提示：</p>
<p>1 &lt;= tree.length &lt;= 40000<br>0 &lt;= tree[i] &lt; tree.length</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fruit-into-baskets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fruit-into-baskets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口！！！</p>
<p>自己是没有想到用滑动窗口的…现在也还是不太清楚如何判断使用。感觉上只要是序列的从左向右解决问题，都可以用滑动窗口试试。</p>
<blockquote>
<ul>
<li>1.把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。</li>
<li>2.移动到当前树右侧的下一棵树。如果右边没有树，就停下来。 </li>
</ul>
</blockquote>
<p>题目给的要求也很…滑动窗口…</p>
<p>下面是题解，主要点都在注释当中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree: List[int])</span> -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span> <span class="comment"># 窗口左边界</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        d = defaultdict(int) <span class="comment"># 用来记录窗口内的情况</span></span><br><span class="line">        <span class="keyword">for</span> right,val <span class="keyword">in</span> enumerate(tree):</span><br><span class="line">            d[val] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> len(d) &gt;= <span class="number">3</span>: <span class="comment"># 如果窗口内的水果种类超过3 那么就需要进行收缩</span></span><br><span class="line">                d[tree[left]] -= <span class="number">1</span> <span class="comment"># 左侧水果个数 -1 </span></span><br><span class="line">                <span class="keyword">if</span> d[tree[left]] == <span class="number">0</span>: <span class="comment"># 如果左侧的水果都减没了 就删掉</span></span><br><span class="line">                    <span class="keyword">del</span> d[tree[left]]  </span><br><span class="line">                </span><br><span class="line">                left += <span class="number">1</span> <span class="comment"># 每次操作，左边界收缩</span></span><br><span class="line">            res = max(res,right-left+<span class="number">1</span>)  <span class="comment"># 最终的结果就是看中间哪一段  的窗口长度最长</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-120-三角形最小路径和</title>
    <url>/2020/03/23/Leetcode/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h2 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>说明：</p>
<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/triangle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/triangle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划，而且思路很经典，看完之后突然回想起之前的做LSTM+CRF的维特比算法，也是这个思想</p>
<p>相比于解决这个题，一个标准的动态规划的思路是更好的。之前都是上来就去定义状态，找状态转移方程，发现并没有那么好找。俗话说得好，万物皆<strong>套娃</strong>。大部分的dp问题都是由于DFS时间复杂度过高，进而转向带记忆优化的DFS，再进而优化为迭代的DP算法</p>
<h4 id="蛮干"><a href="#蛮干" class="headerlink" title="蛮干"></a>蛮干</h4><p>思路很简单，就是每次岔开左和右，取两者最小的值。</p>
<p>需要注意的点是，因为给定结构的特殊性，递归结束只需要判断  到达最后一层即可。由于每一次col都是原值或者+1到达下一层，不会越界的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(level, col)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> triangle[level][col]</span><br><span class="line"></span><br><span class="line">            left = dfs(level+<span class="number">1</span>,col)</span><br><span class="line">            right = dfs(level+<span class="number">1</span>,col+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> min(left,right)+triangle[level][col]</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd44t2hx6tj30i205st8o.jpg" alt="image-20200323202521345"></p>
<h4 id="带记忆的DFS"><a href="#带记忆的DFS" class="headerlink" title="带记忆的DFS"></a>带记忆的DFS</h4><p>思路也很简单就是将没有算过的直接计算，然后存到mem里面，如果算过了就直接拿出来即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        mem = [[<span class="literal">None</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(level, col)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> mem[level][col] != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> mem[level][col]</span><br><span class="line">            <span class="keyword">if</span> level == n<span class="number">-1</span>:</span><br><span class="line">                mem[level][col] = triangle[level][col]</span><br><span class="line">                <span class="keyword">return</span> mem[level][col]</span><br><span class="line"></span><br><span class="line">            left = dfs(level+<span class="number">1</span>,col)</span><br><span class="line">            right = dfs(level+<span class="number">1</span>,col+<span class="number">1</span>)</span><br><span class="line">            mem[level][col] = min(left,right)+triangle[level][col]</span><br><span class="line">            <span class="keyword">return</span> mem[level][col]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>其实从这个记忆化的DFS就可以感受到DP算法的韵味了。</p>
<p>这里面的每一次计算都有着一个递推公式，或者说是状态转移方程</p>
<p>$mem[level][col] = min(left,right)+triangle[level][col] = min(dfs(level+1,col),dfs(level+1,col+1)) + tri[level][col]$</p>
<p>其中的level 表示层数，col表示列数，简化为i,j</p>
<p>$mem[i][j] = min(mem[i+1][j],mem[i+1][j+1]) + triangle[i][j]$</p>
<p>上面的公式是<strong>由底向上</strong>的，完全根据dfs 过程推出来的</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>下面按照DFS过程写出动态规划的解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由下至上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        mem = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        mem[n<span class="number">-1</span>] = triangle[n<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                mem[i][j] = min(mem[i+<span class="number">1</span>][j],mem[i+<span class="number">1</span>][j+<span class="number">1</span>]) + triangle[i][j]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> mem[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>里面有一行去DFS过程极其相似，那就是$mem[i][j] = min(mem[i+1][j],mem[i+1][j+1]) + triangle[i][j]$</p>
<p>上面算法的时间复杂度和空间复杂度都是 <code>o(N^2)</code>的，但是我们发现里面的mem数组实际上利用效率很低，我们每次只使用上下两行的。其余都没有关系。</p>
<h4 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h4><p>这里使用了一个1维度的数组每次都是更新这一个数组就好了。</p>
<p>这是因为每次我们替换j位置的值，都是先根据之前该位置的值求得进行替换的，所以中间不会发生交叉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        mem = triangle[n<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                mem[j] = min(mem[j],mem[j+<span class="number">1</span>]) + triangle[i][j]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> mem[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>！！！既然每次都是替换自己位置的值，那我们使用数组本身就好了 何必再开一个数组呢</p>
<h4 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                triangle[i][j] = min(triangle[i+<span class="number">1</span>][j],triangle[i+<span class="number">1</span>][j+<span class="number">1</span>]) + triangle[i][j]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>(然而 lc官方评测实际不如上一个)</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-990-等式方程</title>
    <url>/2020/03/23/Leetcode/leetcode-990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="等式方程"><a href="#等式方程" class="headerlink" title="等式方程"></a>等式方程</h2><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：[&quot;b==a&quot;,&quot;a==b&quot;]</span><br><span class="line">输入：true</span><br><span class="line">解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= equations.length &lt;= 500</code></li>
<li><code>equations[i].length == 4</code></li>
<li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li>
<li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li>
<li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>利用<code>并查集</code>的思想，题目很简单，相等的就是联通的，将他们合并在一起，不等的就不用合并。</p>
<p>所以算法流程：</p>
<ul>
<li>先将相等的等式进行合并，得到并查集的结果</li>
<li>再根据不等的等式进行find，若出现两个不等且联通则出现问题，返回False</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,N)</span>:</span></span><br><span class="line">        self.parent = [<span class="number">0</span>]*N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            self.parent[i] = i</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 路径压缩 以 确保 调用find(x)的过程不会退化到 o（n）</span></span><br><span class="line">        <span class="keyword">while</span> x != self.parent[x]:</span><br><span class="line">            self.parent[x] = self.parent[self.parent[x]]</span><br><span class="line">            x = self.parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        <span class="comment"># 简单的合并，如果高级一点使用 一个size数组，将较小的挂到较大的根下</span></span><br><span class="line">        self.parent[root_x] = root_y</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isConnected</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: List[str])</span> -&gt; bool:</span></span><br><span class="line">        uf = UnionFind(<span class="number">26</span>)</span><br><span class="line">        <span class="comment"># 1. 先判断相等的，进行 union</span></span><br><span class="line">        <span class="keyword">for</span> eq <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> eq[<span class="number">1</span>] == <span class="string">'='</span>:</span><br><span class="line">                x = ord(eq[<span class="number">0</span>])-ord(<span class="string">'a'</span>)</span><br><span class="line">                y = ord(eq[<span class="number">3</span>])-ord(<span class="string">'a'</span>)</span><br><span class="line">                uf.union(x,y)</span><br><span class="line">        <span class="comment"># 2. 再判断不等的，进行find 并检验结果</span></span><br><span class="line">        <span class="keyword">for</span> eq <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> eq[<span class="number">1</span>] == <span class="string">'!'</span>:</span><br><span class="line">                x = ord(eq[<span class="number">0</span>])-ord(<span class="string">'a'</span>)</span><br><span class="line">                y = ord(eq[<span class="number">3</span>])-ord(<span class="string">'a'</span>)</span><br><span class="line">                <span class="keyword">if</span> x == y: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> uf.isConnected(x,y):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-周赛-181场</title>
    <url>/2020/03/22/Leetcode/leetcode%E5%91%A8%E8%B5%9B181%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="周赛181场"><a href="#周赛181场" class="headerlink" title="周赛181场"></a>周赛181场</h2>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-双周赛-22场</title>
    <url>/2020/03/22/Leetcode/leetcode%E5%91%A8%E8%B5%9B-%E5%8F%8C22%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="双周赛22场"><a href="#双周赛22场" class="headerlink" title="双周赛22场"></a>双周赛22场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/find-the-distance-value-between-two-arrays/" target="_blank" rel="noopener">两个数组间的距离值</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/cinema-seat-allocation/" target="_blank" rel="noopener">安排电影院座位</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/sort-integers-by-the-power-value/" target="_blank" rel="noopener">将整数按权重排序</a><br><code>7 分</code> - <a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/" target="_blank" rel="noopener">3n 块披萨</a></p>
<p>:crossed_fingers:   第一次在规定时间内做出来3个题，纪念下！！！:stuck_out_tongue_winking_eye:</p>
<h3 id="两个数组间的距离值"><a href="#两个数组间的距离值" class="headerlink" title="两个数组间的距离值"></a>两个数组间的距离值</h3><p>根据题意，双循环实现即可，由于数据范围不是很大，暴力方法。时间复杂度<code>O(N^2)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheDistanceValue</span><span class="params">(self, arr1: List[int], arr2: List[int], d: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr1)):</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr2)):</span><br><span class="line">                <span class="keyword">if</span> abs(arr1[i]-arr2[j]) &lt;= d:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="T2-安排电影院座位"><a href="#T2-安排电影院座位" class="headerlink" title="T2:安排电影院座位"></a>T2:安排电影院座位</h3><p>上来就开了一个辅助矩阵帮助判断，但是数据量太大了，内存直接爆掉了。</p>
<p>根据给的数据提示：</p>
<blockquote>
<ul>
<li><code>1 &lt;= n &lt;= 10^9</code></li>
<li><code>1 &lt;= reservedSeats.length &lt;= min(10*n, 10^4)</code>  这里！！！ </li>
<li><code>reservedSeats[i].length == 2</code></li>
<li><code>1 &lt;= reservedSeats[i][0] &lt;= n</code></li>
<li><code>1 &lt;= reservedSeats[i][1] &lt;= 10</code></li>
<li>所有 <code>reservedSeats[i]</code> 都是互不相同的。</li>
</ul>
</blockquote>
<p>预定座位数组内元素的个数最大就是<code>10^4</code>所以从这个数组下手。这个数组给的是预定了座位，整个电影院可以最多坐下的4人家庭数量为<code>n*2,n为行数</code>，去掉被预定出去导致不能4人连坐的位置，剩余的值就是解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfFamilies</span><span class="params">(self, n: int, reservedSeats: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 每行都是只需要判断三个位置即可 2-5   4-7  6-9</span></span><br><span class="line">        seats = sorted(reservedSeats,key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        res = <span class="number">2</span>*n</span><br><span class="line">        one_line = [<span class="number">0</span>]*<span class="number">11</span></span><br><span class="line">        <span class="keyword">for</span> seat <span class="keyword">in</span> seats:</span><br><span class="line">            x,y = seat[<span class="number">0</span>],seat[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> x == row:</span><br><span class="line">                one_line[y] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> row != <span class="number">0</span>:</span><br><span class="line">                    res -= self.cal(one_line)</span><br><span class="line">                one_line = [<span class="number">0</span>]*<span class="number">11</span></span><br><span class="line">                row = x</span><br><span class="line">                one_line[y] = <span class="number">1</span></span><br><span class="line">        res -= self.cal(one_line)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(self,one)</span>:</span></span><br><span class="line">        <span class="comment"># 2,3,.....9 这8个位置 如果都没有被预定 则不用减</span></span><br><span class="line">        <span class="keyword">if</span> sum(one[<span class="number">2</span>:<span class="number">10</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 中间可以坐的位置 有3种方案，其中某一个方案可行，都会导致该行 只能坐一种方案</span></span><br><span class="line">        <span class="keyword">elif</span> sum(one[<span class="number">2</span>:<span class="number">6</span>]) == <span class="number">0</span> <span class="keyword">or</span> sum(one[<span class="number">4</span>:<span class="number">8</span>]) == <span class="number">0</span> <span class="keyword">or</span> sum(one[<span class="number">6</span>:<span class="number">10</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度分析：之前有个排序算法，<code>O(NlogN)</code> 后面有个遍历过程<code>O(N)</code>,总的时间复杂度是<code>O(NlogN)</code></p>
<p>其实可以优化到<code>O(N)</code>，看其他人的解法里面使用了<code>dict</code> ，先遍历加入<code>dict</code>，确保同行的都在一个key里面， 再遍历dict 进行使用。</p>
<h3 id="T3-将整数按照权重排序"><a href="#T3-将整数按照权重排序" class="headerlink" title="T3:将整数按照权重排序"></a>T3:将整数按照权重排序</h3><p>求权重的方法就是带备忘录的dfs，不方便直接用dp的原因是不知道这个数组具体有多大，下一个值是否存在。所以用了<code>字典</code>来存储已经计算过的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKth</span><span class="params">(self, lo: int, hi: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        self.mem = &#123;&#125;</span><br><span class="line">        self.mem[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        self.mem[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        self.mem[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        self.mem[<span class="number">3</span>] = <span class="number">7</span></span><br><span class="line">        </span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lo,hi+<span class="number">1</span>):</span><br><span class="line">            steps = self.countSteps(i)</span><br><span class="line">            arr.append([steps,i])</span><br><span class="line">        </span><br><span class="line">        arr = sorted(arr,key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> arr[k<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSteps</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> self.mem:</span><br><span class="line">            <span class="keyword">return</span> self.mem[num]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">                self.mem[num] = self.countSteps(num//<span class="number">2</span>)+<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> self.mem[num]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.mem[num] = self.countSteps(num*<span class="number">3</span>+<span class="number">1</span>)+<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> self.mem[num]</span><br></pre></td></tr></table></figure>
<h3 id="T4-3n-块披萨"><a href="#T4-3n-块披萨" class="headerlink" title="T4:3n 块披萨"></a>T4:3n 块披萨</h3><p>自己的思路就是暴力dfs，模拟自己选披萨任何一块的可能情况，对应自己选完一次也帮Alice和Bob进行选择，选择好的披萨进行标记已经遍历。<strong>超时</strong>（实际上case 才过了 15/69）  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSizeSlices</span><span class="params">(self, slices: List[int])</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        self.mx = <span class="number">0</span></span><br><span class="line">        mine = []</span><br><span class="line">        visited = [<span class="number">0</span>]*len(slices)</span><br><span class="line">        self.dfs(slices,visited,mine)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.mx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,slices,visited,mine)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sum(visited) == len(slices):</span><br><span class="line">            self.mx = max(self.mx,sum(mine))</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(slices)):</span><br><span class="line">            <span class="keyword">if</span> visited[idx] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 遍历标记</span></span><br><span class="line">                mine.append(slices[idx])</span><br><span class="line">                visited[idx] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 顺时针的下一个</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(idx+<span class="number">1</span>,idx+len(slices)):</span><br><span class="line">                    <span class="keyword">if</span> visited[k%len(slices)] == <span class="number">0</span>:</span><br><span class="line">                        visited[k%len(slices)] = <span class="number">1</span></span><br><span class="line">                        Alice = k%len(slices)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 逆时针</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(idx+len(slices)<span class="number">-1</span>,idx<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> visited[k%len(slices)] == <span class="number">0</span>:</span><br><span class="line">                        visited[k%len(slices)] = <span class="number">1</span></span><br><span class="line">                        Bob = k%len(slices)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                self.dfs(slices,visited,mine)</span><br><span class="line">                <span class="comment"># 回溯</span></span><br><span class="line">                mine.pop()</span><br><span class="line">                visited[idx] = <span class="number">0</span></span><br><span class="line">                visited[Alice] = <span class="number">0</span></span><br><span class="line">                visited[Bob] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>为什么会超时呢？</p>
<blockquote>
<p>暴力回溯的情况下，假如共有9块披萨 取 1 3 5 和 5 3 1 是属于同样的选择，原本我们只需要选最有益的，但是暴力回溯会依次遍历这两种情况，产生大量的冗余计算，时间复杂度过高 <code>O(N!)</code></p>
</blockquote>
<h4 id="进阶思路"><a href="#进阶思路" class="headerlink" title="进阶思路"></a>进阶思路</h4><p>！！！ <strong>转化为 非连续数列的最值问题  -&gt; 打家劫舍问题！！！</strong></p>
<p>虽然题目描述披萨是个圈，但是还是数列，只不过需要注意第一个元素和最后一个元素是互斥的就可以了。</p>
<p>那么问题就变成了：如果在这个数列里面我可以取一定次数的值，但是不可以连续取值，怎么取可以使我的取值最大。</p>
<ul>
<li>为什么是一定次数的：因为3n个披萨，你最多只能取 n//3 次</li>
<li>为什么是不连续的：因为有条件限制，你取了第i个那么i-1和i+1 都会被分掉</li>
</ul>
<p>还有一个问题，没有解决首位互斥的问题，这时候想到打家劫舍第三题，就是一个环啊。那我们只需要分两次来进行求值</p>
<ul>
<li>当首位置可以选的时候，去掉尾</li>
<li>当尾部可选的时候，去掉首部</li>
</ul>
<p>我们来看下，本题的状态是什么，然后如何转移的：</p>
<script type="math/tex; mode=display">
d[i][j] = max\{d[i-1][0...j-2]\} + slices[j]</script><p>$d[i][j]$其中的i表示拿i次披萨，j表示第j块，即第i次拿起第j块披萨的最大值是多少。转移方程中有一个<code>0...j-2</code>表示取值为：0，1，2，3…j-2 。对于状态转移方程，举个例子来方便理解：</p>
<blockquote>
<p> 当i=2,j=5的时候，表示第2次取第5块披萨时，我们需要看一下</p>
<p>第1次取第0块披萨、第1块披萨、第j-2(5-2=3) 块披萨时候的最大值，在加上本次即将取得第5块披萨</p>
<p>即 $d[2][5] = max(d[1][0],d[1][1],d[1][2],d[1][3]) + slices[5]$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSizeSlices</span><span class="params">(self, slices: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.row = len(slices)//<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">        self.n  = len(slices) - <span class="number">1</span></span><br><span class="line">        one = self.getMax(slices,<span class="number">0</span>,self.n) <span class="comment"># 只看首部不看尾部</span></span><br><span class="line">        two = self.getMax(slices,<span class="number">1</span>,self.n+<span class="number">1</span>)  <span class="comment"># 只看尾部不看首部</span></span><br><span class="line">        <span class="keyword">return</span> max(one,two)  <span class="comment"># 取二者的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMax</span><span class="params">(self,slices,start,end)</span>:</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*self.n <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.row)]</span><br><span class="line">        tmp = slices[start:end]</span><br><span class="line">        cur_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,self.row):</span><br><span class="line">            pre_max = <span class="number">0</span> <span class="comment"># 上一次拿的时候最大的</span></span><br><span class="line">            <span class="keyword">for</span>  j <span class="keyword">in</span> range(self.n):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= <span class="number">2</span>:</span><br><span class="line">                  <span class="comment"># 这个pre_max相当于PK台,始终保留前面情况的最大值</span></span><br><span class="line">                    pre_max = max(dp[i<span class="number">-1</span>][j<span class="number">-2</span>],pre_max) </span><br><span class="line">                dp[i][j] = pre_max + tmp[j]</span><br><span class="line">                cur_max = max(dp[i][j], cur_max)</span><br><span class="line">        <span class="keyword">return</span> cur_max</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-328-奇偶链表</title>
    <url>/2020/03/21/Leetcode/leetcode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br>示例 2:</p>
<p>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL<br>说明:</p>
<p>应当保持奇数节点和偶数节点的相对顺序。<br>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>真的是，以为很简单，想一遍写对真的太难了…还是自己太弱了</p>
<p>先说下自己的错误思路以及问题在哪</p>
<p>分别拿一个<code>dummy node</code>当奇偶链表的头结点，然后再把两个链表一拼接，就ok了</p>
<p>这样时间复杂度也是<code>o(N)</code>，空间复杂度是<code>o(1)</code>（额外使用了4个指针）</p>
<p>思路其实是没有问题的，但是进了链表的大坑——同一个链表分开操作。</p>
<p>直白讲就是，链表直接使用的就是引用，操作了就是操作了，那么后边再操作就不是最初的链表了</p>
<p>下面的<strong>错误</strong>解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        odd = ListNode(<span class="number">-1</span>)</span><br><span class="line">        even = ListNode(<span class="number">-2</span>)</span><br><span class="line">        odd.next = head</span><br><span class="line">        even.next = head.next</span><br><span class="line">				<span class="comment"># 企图构建一个奇数链表</span></span><br><span class="line">        p_odd = odd.next</span><br><span class="line">        <span class="keyword">while</span> p_odd <span class="keyword">and</span> p_odd.next:</span><br><span class="line">            p_odd.next = p_odd.next.next</span><br><span class="line">            p_odd = p_odd.next</span><br><span class="line">        <span class="comment">#######！！！！！！！！！！！！！！#######</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        问题就在这，上边操作后，链表已经不是原来的head了，而我还当</span></span><br><span class="line"><span class="string">        原来的head再进行偶数链表构建。XXX</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">				<span class="comment"># 企图构建一个偶数链表</span></span><br><span class="line">        p_even = even.next</span><br><span class="line">        <span class="keyword">while</span> p_even <span class="keyword">and</span> p_even.next:</span><br><span class="line">            p_even.next = p_even.next.next</span><br><span class="line">            p_even = p_even.next</span><br><span class="line"></span><br><span class="line">        p_odd.next = even.next</span><br><span class="line">        <span class="keyword">return</span> odd</span><br></pre></td></tr></table></figure>
<h3 id="正确且简单解法"><a href="#正确且简单解法" class="headerlink" title="正确且简单解法"></a>正确且简单解法</h3><p>再链表上同时操作奇偶，需要注意的细节问题是：处理肯定先奇数再偶数，<code>p_even</code>指针始终靠后一点，所以循环的判断条件是判定，偶数或者偶数的下一个是否存在</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        even = head.next</span><br><span class="line">        p_even = even</span><br><span class="line">        p_odd = head</span><br><span class="line">        <span class="comment"># 一次同时来操作两个节点，最后的判断就是 even 因为even 后操作</span></span><br><span class="line">        <span class="keyword">while</span> p_even <span class="keyword">and</span> p_even.next:</span><br><span class="line">            p_odd.next = p_even.next</span><br><span class="line">            p_odd = p_odd.next</span><br><span class="line">            p_even.next = p_odd.next</span><br><span class="line">            p_even = p_even.next </span><br><span class="line">                    </span><br><span class="line">        p_odd.next = even</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>topK问题</title>
    <url>/2020/03/21/SwordOffer/%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>经典面试题目：主要利用快排的<code>partition</code> 以及 堆排两种方式来完成</p>
<h4 id="快排方案"><a href="#快排方案" class="headerlink" title="快排方案"></a>快排方案</h4><p>原理： 快排一次可以确定一个数的最终位置，那么根据位置和k进行比较则可以在不完全排序好整个数组的前提下，排好前k个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="keyword">if</span> n == k:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = self.partition(arr,left,right)</span><br><span class="line">            <span class="keyword">if</span> mid == k:</span><br><span class="line">                <span class="keyword">return</span> arr[:k]</span><br><span class="line">            <span class="keyword">elif</span> mid &lt; k :</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr,left,right)</span>:</span></span><br><span class="line">        pivot = arr[left]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right]&gt;= pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            arr[left],arr[right] = arr[right], arr[left]</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt; pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            arr[left],arr[right] = arr[right], arr[left]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p>方案分析：每次<code>partition</code>操作都是<code>O(N)</code>的时间复杂度，最优情况就是一次partition恰好找到第k个位置，则前K个就是topk小。最坏的情况就是每一次选出来的位置，不是最大就是最小，界限始终在两侧递减1，这样最终需要遍历完整个数组才能找到K，时间复杂度为<code>O(N^2)</code>,平均的话 说不好，因为不是严格的快排序那种二分去找的。 </p>
<h3 id="堆排方案"><a href="#堆排方案" class="headerlink" title="堆排方案"></a>堆排方案</h3><p>维护一个大根堆，用来获取最小的前k个值，为什么用大根堆呢？</p>
<p>大根堆每次调整后，都将堆内最大的元素放到堆顶，如果新进来的元素比堆顶元素小，那么就把堆顶元素换成该元素，同时再进行一次从top到bottom的调整，这样最大的元素又一次被调整到堆顶，继续前面的过程。</p>
<p>最终堆内留下来的就是最小的K个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k ==<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        topk = [v <span class="keyword">for</span> v <span class="keyword">in</span> arr[:k]]</span><br><span class="line">        <span class="comment"># 使普通的二叉 成为 有序的 大根堆</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k//<span class="number">2</span><span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            self.heapAdjust(topk,i,k<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k,len(arr)):</span><br><span class="line">            <span class="comment"># 每次竞争掉堆顶</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt;= topk[<span class="number">0</span>]:</span><br><span class="line">                topk[<span class="number">0</span>] = arr[i]</span><br><span class="line">                self.heapAdjust(topk,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> topk</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapAdjust</span><span class="params">(self,heap,start,end)</span>:</span></span><br><span class="line">        root = start</span><br><span class="line">        child = root*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> child &lt;= end:</span><br><span class="line">            <span class="keyword">if</span> child+<span class="number">1</span> &lt;= end <span class="keyword">and</span> heap[child+<span class="number">1</span>] &gt; heap[child]:</span><br><span class="line">                child += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> heap[root] &lt; heap[child]:</span><br><span class="line">                heap[root],heap[child] = heap[child],heap[root]</span><br><span class="line">                root = child</span><br><span class="line">                child = root*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度分析：最坏情况就是<code>o(nlogn)</code> 对于数字需要进行完全的遍历<code>o(N)</code>，而每一次遍历都需要进行logN的操作。最优情况就是<code>O(N)</code>，也就是遍历过程不存在堆的调整，其实说白了就是最初加入堆的K个元素就是topK.</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>顺指针打印矩阵</title>
    <url>/2020/03/21/SwordOffer/%E9%A1%BA%E6%8C%87%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 划定边界</span></span><br><span class="line">        left,right,top,bottom = <span class="number">0</span>,len(matrix[<span class="number">0</span>])<span class="number">-1</span>,<span class="number">0</span>,len(matrix)<span class="number">-1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 从左至右遍历到头 (top 收缩)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 从上到下进行遍历 （右侧收缩）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(top,bottom+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 从右向左进行遍历 （bottom 收缩）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(right,left<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> bottom &lt; top: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 从下到上进行遍历 （左侧收缩）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(bottom,top<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right: <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-365-水壶问题</title>
    <url>/2020/03/21/Leetcode/leetcode-365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="水壶问题（智力题）"><a href="#水壶问题（智力题）" class="headerlink" title="水壶问题（智力题）"></a>水壶问题（智力题）</h2><p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<p><strong>示例 1:</strong> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg" target="_blank" rel="noopener"><em>“Die Hard”</em> example</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x = 3, y = 5, z = 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x = 2, y = 6, z = 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>作为程序员的思路，遍历所有可能的情况，看这些情况是否可能成立</p>
<p>对于这个题主要是看x桶和y桶这两个桶的状态，以及对应的操作</p>
<p>对于每次进行操作，我们都有以下几种操作方式</p>
<ol>
<li>把 x 桶 装满</li>
<li>把 y 桶装满</li>
<li>把 x 桶清空</li>
<li>把 y 桶清空</li>
<li>把 x桶的水倒入y桶，<strong>直到x倒空  or y 被倒满</strong></li>
<li>把 y 桶的水倒入x桶，<strong>直到y倒空 or x 被倒满</strong></li>
</ol>
<p>起始状态就是 x=0,y=0。对于每个状态，我们都可以进行如上的6种操作进行状态改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span><span class="params">(self, x: int, y: int, z: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x + y &lt; z:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        seen = set([])</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            r_x,r_y = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> r_x == z <span class="keyword">or</span> r_y ==z <span class="keyword">or</span> r_x+r_y == z:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 如果已经出现过这种组合了，且没有return True 那说明这个状态没用，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (r_x,r_y) <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            seen.add((r_x,r_y))</span><br><span class="line">            <span class="comment"># 1. 把 x 桶倒满</span></span><br><span class="line">            stack.append((x,r_y))</span><br><span class="line">            <span class="comment"># 2. 把 y 桶倒满</span></span><br><span class="line">            stack.append((r_x,y))</span><br><span class="line">            <span class="comment"># 3. 把 x 清空</span></span><br><span class="line">            stack.append((<span class="number">0</span>,r_y))</span><br><span class="line">            <span class="comment"># 4. 把 y 清空</span></span><br><span class="line">            stack.append((r_x,<span class="number">0</span>)) </span><br><span class="line">            <span class="comment"># 5 把 x 倒入 y中 直到 x倒空 或者 y倒满  y-r_y 表示剩余可以倒入的</span></span><br><span class="line">            stack.append((r_x-min(r_x,y-r_y),r_y+min(r_x, y-r_y)))</span><br><span class="line">            <span class="comment"># 6 把 y 倒入 x 中，直到 y 倒空 或者 x 倒满</span></span><br><span class="line">            stack.append((r_x+min(x-r_x,r_y),r_y-min(x-r_x,r_y)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h3><p>而贝祖定理告诉我们，$ax+by=z$  有解当且仅当 <code>z</code> 是 <code>x</code>,<code>y</code> 的最大公约数的倍数。因此我们只需要找到 <code>x</code>,<code>y</code>的最大公约数并判断 <code>z</code> 是否是它的倍数即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span><span class="params">(self, x: int, y: int, z: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x + y &lt; z:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> y == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> z == <span class="number">0</span> <span class="keyword">or</span> x + y == z</span><br><span class="line">        <span class="keyword">return</span> z % math.gcd(x, y) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>记下答案吧…</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-223-矩形面积</title>
    <url>/2020/03/19/Leetcode/leetcode-223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="矩形面积"><a href="#矩形面积" class="headerlink" title="矩形面积"></a>矩形面积</h2><p>在<strong>二维</strong>平面上计算出两个<strong>由直线构成的</strong>矩形重叠后形成的总面积。</p>
<p>每个矩形由其左下顶点和右上顶点坐标表示，如图所示。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcyk5314sij30f208g0sm.jpg" alt="Rectangle Area"></p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -3, 0, 3, 4, 0, -1, 9, 2</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 假设矩形面积不会超出 <strong>int</strong> 的范围。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是计算交集部分的面积，然后让两个矩形面积相加再减去交集面积即可。</p>
<p>重点是交集部分如何进行计算。</p>
<p>如果有交集，那么交集矩形的左  边，肯定是两个矩形左  边  最大的那条边，交集矩形的右 边 ，肯定是两个矩形的右 边 最小的那条边。同理可以得到交集矩形的上下  边。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">computeArea</span><span class="params">(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int)</span> -&gt; int:</span></span><br><span class="line">        rectangle_a = (C-A)*(D-B)  <span class="comment"># 求 矩形1</span></span><br><span class="line">        rectangle_b = (G-E)*(H-F)  <span class="comment"># 求 矩形2</span></span><br><span class="line">        <span class="comment"># 一定用max(0,xxx) 是因为不想交的话 会出现负值 </span></span><br><span class="line">        width = max(<span class="number">0</span>,min(C,G)-max(A,E))  <span class="comment"># 根据左右边  求 宽度</span></span><br><span class="line">        height = max(<span class="number">0</span>,min(D,H)-max(B,F)) <span class="comment"># 根据上下边  求 高度</span></span><br><span class="line">        <span class="keyword">return</span> rectangle_a+rectangle_b-width*height</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-836-矩形重叠</title>
    <url>/2020/03/18/Leetcode/leetcode-836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
    <content><![CDATA[<h2 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a>矩形重叠</h2><p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。</p>
<p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>
<p>给出两个矩形，判断它们是否重叠并返回结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>两个矩形 <code>rec1</code> 和 <code>rec2</code> 都以含有四个整数的列表的形式给出。</li>
<li>矩形中的所有坐标都处于 <code>-10^9</code> 和 <code>10^9</code> 之间。</li>
<li><code>x</code> 轴默认指向右，<code>y</code> 轴默认指向上。</li>
<li>你可以仅考虑矩形是正放的情况。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单题，在于题目给的条件太多了。矩形正放置，不会出现倾斜的情况。</p>
<p>只需要考虑四个情况即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">                  <span class="comment">###############</span></span><br><span class="line">                  <span class="comment">#     上      #</span></span><br><span class="line">                  <span class="comment">###############</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############    ###############   ###################</span></span><br><span class="line"><span class="comment">#      左    #    #             #   #       右         # </span></span><br><span class="line"><span class="comment">##############    ##############    ###################</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">##############</span></span><br><span class="line">                  <span class="comment">#      下    #</span></span><br><span class="line">                  <span class="comment">##############</span></span><br></pre></td></tr></table></figure>
<p>根据这四个情况进行四种判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isRectangleOverlap</span><span class="params">(self, rec1: List[int], rec2: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 以2作为中心矩形</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>]         <span class="comment">#  1 在 2 上</span></span><br><span class="line">                    <span class="keyword">or</span> rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>]      <span class="comment">#  1 在 2  右</span></span><br><span class="line">                    <span class="keyword">or</span> rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>]      <span class="comment">#  1 在 2 下</span></span><br><span class="line">                    <span class="keyword">or</span> rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>])     <span class="comment">#  1 在 2 左</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>排序模块的Reranker</title>
    <url>/2020/03/18/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/Rerank/</url>
    <content><![CDATA[<h2 id="实习阶段项目总结"><a href="#实习阶段项目总结" class="headerlink" title="实习阶段项目总结"></a>实习阶段项目总结</h2><p>保护部分隐私内容（京东内部业务），只针对技术进行总结。</p>
<p>正好最近要准备亚麻的面试：</p>
<blockquote>
<ul>
<li>Amazon interviewers use a behavioral interview technique known as STAR. You will be asked to describe a Situation you were in, Task you had to do, Actions you personally undertook in that situation and the Results you achieved from these actions. The behavioral questions will relate specifically to our Leadership Principles and you are likely to cover technical elements in relation to the role in your answers.</li>
</ul>
</blockquote>
<p>所以项目总结会采用STAR的形式进行，对应分析一个项目的Situations、Target、Actions、Results</p>
<h3 id="为什么要做rerank（Stiuations）"><a href="#为什么要做rerank（Stiuations）" class="headerlink" title="为什么要做rerank（Stiuations）"></a>为什么要做rerank（Stiuations）</h3><p>主要分为业务背景 和 技术背景来谈</p>
<h4 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h4><p>实现rerank 的目的：提高个性化，提高uv价值</p>
<p>前期有的业务都是基于 RNN的形式：效率低，只能串行；距离相距较远的两个item的相关性不能很好的刻画；</p>
<p>还有一个创新的地方是加入用户的个性化</p>
<h4 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h4><p>现有的实验策略主要是通过规则限制来进行的。比如去已读，去重，品牌打散（10个里面不允许出现3个及以上）来保证结果的多样性。较多的人为干预一定程度上破坏了数据分布，或者说没有遵循数据本身所反馈出来的情况。其次rerank之前是有一些算法提出来的，但是算法效率不是很高，对系统性能要求也比较高，现在有比较好的方法，一方面算法效率比较高，另一方面深度学习有新的创新也值得在电商场景下进行使用。</p>
<p>基于业务和技术背景，值得在整个系统上添加一个新的rerank模块进行使用。</p>
<blockquote>
<p>现有的rerank机制是接在精排后边的，主要是满足业务策略和构建好的生态吧。目的可能有很多，去已读，去重，打散，保证多样性等。我们这次项目主要是做重排，以实现现有系统的结果多样性，更多是为了生态考虑。实际工作中，使用规则，一定程度上能满足需求，eg：打散（前10出至少3种不同的）等。但是规则的问题在于，做事情不soft，强行操作。所以需要一点比较soft的处理办法。</p>
</blockquote>
<h3 id="目标（Target）"><a href="#目标（Target）" class="headerlink" title="目标（Target）"></a>目标（Target）</h3><p>对于公司的最终业务目标：保证基本的业务指标不下降的前提下，提高系统的检索结果的多样性，对于内部的话，正式员工是有指标的，全年的目标是，业务指标（uv价值是指GMV/客户数）和多样性指标各3%的相对提升。</p>
<p>现阶段的主要目标，就是能够协助建立起这个系统，并且系统能够有效可靠的运行。包括能够建立正常的数据流，模型的正常训练迭代，模型的预测，模型的评测，模型可以在线上进行severing（线上架构能够抗的住），线上线下结果的一致性</p>
<h3 id="采取的措施（Actions）"><a href="#采取的措施（Actions）" class="headerlink" title="采取的措施（Actions）"></a>采取的措施（Actions）</h3><p>前期工作:方案调研，具体实现哪个方案，mentor基本完成了。</p>
<p>主要分为：数据的获取，模型的实现与实验，效果的评测</p>
<p>确定了目标方案，就是参考（Personal Reranking  for recommendation）论文的一些技巧，然后在我们场景下进行实现。</p>
<ul>
<li><p>数据的获取</p>
<p>主要通过hive/pig 脚本构建数据pipeline，因为是listwise的，数据的构成有些特殊，需要将同一个pvid对应的所有item都group到一起，query  user 特征共享，item特征不同。</p>
</li>
<li><p>模型的实现经历了</p>
<p>1.两个阶段，一个阶段是在keras上进行模型的实现与实验，涉及定长（推荐列表长度为定长30），以及不定长版本（搜索场景下返回的不同，其实最终还是定长的，但是对于不满足长度的需要做一些处理）的实现。</p>
<p>2.第二个阶段就是将keras 版本的代码迁移至内部的分布式计算框架上。代码其实相当于重新设计了。受限于数据输入shape的限制。keras 版本时候 数据的输入时3d的（batch,seq_len,dim）这样的组成，其中的seq_len 就是一个推荐列表的长度。但是内部的框架，仅支持(batch,dim) 这样的形式，需要再一次对代码进行修改。由于transformer 自身是对3d很友好的，所以转换到2d上还是比较麻烦的。</p>
<p>3.一些细节问题，loss 的计算是有问题的会出现震荡情况，也是由于不定长所导致的。这个目前也还在解决，但是影响不是很大，也能达到一个比较好的效果。</p>
</li>
<li><p>效果评测</p>
<p>离线评测主要是两个指标，一个是auc，一个是多样性指标，这个我们选用的是熵值。熵值越大，表示多样性越好。主要用来计算品牌多样性。</p>
</li>
</ul>
<h3 id="结果（Result）"><a href="#结果（Result）" class="headerlink" title="结果（Result）"></a>结果（Result）</h3><p>简历上的实验指标是有问题的，当时的实验结果发生了特征穿越的问题。因为模型里面使用了Transformer，而使用Transformer要用的一个特征就是pos，然后进行pos-encoding。</p>
<p>目前使用离线指标相对提升2.5%。auc从0.861提升到0.8828。多样性指标目前是不太确定效果的。</p>
<h3 id="一些可以优化的点"><a href="#一些可以优化的点" class="headerlink" title="一些可以优化的点"></a>一些可以优化的点</h3><ul>
<li>loss计算的问题，而且目前是通过softmax 给一个list内全部item进行打分</li>
<li>personal vec  这个 是使用的预训练的。</li>
</ul>
<h3 id="相关指标"><a href="#相关指标" class="headerlink" title="相关指标"></a>相关指标</h3><p>PV(访问量)：即Page View, 具体是指网站的是页面浏览量或者点击量。</p>
<p>UV(独立访客)：即Unique Visitor,访问您网站的一台电脑客户端为一个访客。根据IP地址来区分访客数，在一段时间内重复访问，也算是一个UV。</p>
<p>UV价值=销售额/访客数。意思是每位访客带来多少销售额。</p>
<h1 id="最大边缘相关（Maximal-Marginal-Relevance，MMR）对文档重排序"><a href="#最大边缘相关（Maximal-Marginal-Relevance，MMR）对文档重排序" class="headerlink" title="最大边缘相关（Maximal Marginal Relevance，MMR）对文档重排序"></a>最大边缘相关（Maximal Marginal Relevance，MMR）对文档重排序</h1><p>采用MMR（Maximal Marginal Relevance）算法对文档diverse ranking。</p>
<p>  <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdinygf8osj30j508mt8v.jpg" alt="img"></p>
<p>从MMR的公式中可以看出，diverse ranking的实现是权衡Query与Document相关性和Document间的冗余性的结果。</p>
<p>用MMR进行文档重定序的计算方法：</p>
<ol>
<li><p>用常用IR方法取得前K个文档记Dr= IR(C, Q, K)</p>
</li>
<li><p>选max sim(di ε D , Q)作为第一个文档，即让Ranked = <di></p>
</li>
<li><p>Let D= D\{di}，从中去掉这个元素</p>
</li>
<li><p>While D is not empty, do:</p>
</li>
</ol>
<p>a. Find di withmax MMR(Q, D, Ranked)</p>
<p>b. Let Ranked = Ranked append di</p>
<p>c. Let D= D\{di}</p>
<p>算法思想：</p>
<p>1、先根据Query和Document的相似度给出包含k个文档的集合D；</p>
<p>2、先在集合D中选取一篇与Query最为相似的文档d加入重排序集合R，在D中去掉d；</p>
<p>3、对D中所有的文档计算MMR值，分值最大文档d的加入R，并在D中去掉d；</p>
<p>4、重复步骤3，直到D为空，此时集合R即为重排序后的有序集合。</p>
]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-灯泡开关问题总结</title>
    <url>/2020/03/17/%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="灯泡开关问题1"><a href="#灯泡开关问题1" class="headerlink" title="灯泡开关问题1"></a>灯泡开关问题1</h2>]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-周赛-179场</title>
    <url>/2020/03/17/Leetcode/leetcode%E5%91%A8%E8%B5%9B179%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="周赛179场"><a href="#周赛179场" class="headerlink" title="周赛179场"></a>周赛179场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener">生成每种字符都是奇数个的字符串</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/bulb-switcher-iii/" target="_blank" rel="noopener">灯泡开关 III</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/" target="_blank" rel="noopener">通知所有员工所需的时间</a><br><code>6 分</code> - <a href="https://leetcode-cn.com/problems/frog-position-after-t-seconds/" target="_blank" rel="noopener">T 秒后青蛙的位置</a></p>
<h3 id="T1：-生成每种字符都是奇数个的字符串"><a href="#T1：-生成每种字符都是奇数个的字符串" class="headerlink" title="T1： 生成每种字符都是奇数个的字符串"></a>T1： 生成每种字符都是奇数个的字符串</h3><p>思路就是：奇数的话返回 奇数个’a’，偶数的话返回n-1个’b’，加一个’a‘</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTheString</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'a'</span>*(n<span class="number">-1</span>)+<span class="string">'b'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'a'</span>*n</span><br></pre></td></tr></table></figure>
<h3 id="T2-灯泡开关"><a href="#T2-灯泡开关" class="headerlink" title="T2:灯泡开关"></a>T2:灯泡开关</h3><p>灯泡开关系列问题 :<a href="">灯泡开关</a></p>
<h3 id="T3：-通知所有员工的时间"><a href="#T3：-通知所有员工的时间" class="headerlink" title="T3：  通知所有员工的时间"></a>T3：  通知所有员工的时间</h3><p>上来就想dfs的，写完之后超时了。发现问题在于，每次我的dfs搜索空间都是所有员工，其实只需要搜索自己的下属就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfMinutes</span><span class="params">(self, n: int, headID: int, manager: List[int], informTime: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.nxt = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># 需要先将每个人的下属放进来</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> manager[i] == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            self.nxt[manager[i]].append(i)</span><br><span class="line">        res = self.helper(headID,manager,informTime)+informTime[headID]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,headID,manager,informTime)</span>:</span></span><br><span class="line">        cur_time = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每次搜索自己的下属就可以了</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> self.nxt[headID]:</span><br><span class="line">            t = self.helper(child,manager,informTime)+informTime[child]</span><br><span class="line">            cur_time = max(cur_time,t)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur_time</span><br></pre></td></tr></table></figure>
<p>BFS思路差不多，主要也是每次入队的时候，</p>
<p>还有就是从下向上进行的操作，只需要找到最底层的员工，从他们开始一直追溯到boss，所需的时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) &#123;</span><br><span class="line">        //最终结果</span><br><span class="line">        int res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i =<span class="number">0</span>;i&lt;manager.length;i++)&#123;</span><br><span class="line">            //判断是否为结束点，剪枝</span><br><span class="line">            <span class="keyword">if</span>(informTime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                //临时值</span><br><span class="line">                int temp = <span class="number">0</span>;</span><br><span class="line">                int index=i;</span><br><span class="line">                //向上遍历</span><br><span class="line">                <span class="keyword">while</span>(index!=<span class="number">-1</span>)&#123;</span><br><span class="line">                    temp+=informTime[index];</span><br><span class="line">                    index=manager[index];</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的排列</title>
    <url>/2020/03/15/SwordOffer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。 </p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>示例:</p>
<p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p>
<p>限制：</p>
<p>1 &lt;= s 的长度 &lt;= 8</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯算法的基本case例题</p>
<p>注意细节问题：如果存在重复元素，那么就会存在重复的排列情况，这里比较简单的使用<code>set</code>进行了去重，如果不使用<code>set</code>的话，需要对字符串排序，然后再在遍历过程中进行控制，如果相同则跳过的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res = set([])</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="comment"># s = sorted(s)</span></span><br><span class="line">        visited = [<span class="literal">False</span>]*len(s)</span><br><span class="line">        self.dfs(res,stack,visited,s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,res,stack,visited,s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(stack) == len(s):</span><br><span class="line">            res.add(<span class="string">''</span>.join(stack))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="comment"># if i &gt;0 and s[i] == s[i-1] and not visited[i]:</span></span><br><span class="line">            <span class="comment">#     continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">                stack.append(s[i])</span><br><span class="line"></span><br><span class="line">                self.dfs(res,stack,visited,s)</span><br><span class="line"></span><br><span class="line">                visited[i] = <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的逆序对数</title>
    <url>/2020/03/15/SwordOffer/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="数组中的逆序对数"><a href="#数组中的逆序对数" class="headerlink" title="数组中的逆序对数"></a>数组中的逆序对数</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p> 示例 1:</p>
<p>输入: [7,5,6,4]<br>输出: 5</p>
<p>限制：</p>
<p>0 &lt;= 数组长度 &lt;= 50000</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较经典的题目，之前一直记得总体解决方案是通过 归并排序来实现的。</p>
<p>但是自己python 盲写了一遍并没有成功AC…</p>
<p>还是细节地方没有考虑好：</p>
<ul>
<li>遍历顺序：<code>从大到小进行遍历比较</code></li>
<li>cnt 计数 每次加上的值是<code>right-mid</code>的个数</li>
<li>！！！ 每次merger 操作之后记得将  新数组的值赋给原来的数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        arr = nums.copy()</span><br><span class="line">        res = self.split(nums,arr,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(self,nums,arr,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            arr[left] = nums[left]</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        left_res = self.split(nums,arr,left,mid)</span><br><span class="line">        right_res = self.split(nums,arr,mid+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历顺序： 都是从 左侧  和 右侧 的 尾部开始</span></span><br><span class="line">        l = mid</span><br><span class="line">        r = right</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        j = right</span><br><span class="line">        <span class="keyword">while</span> l &gt;= left <span class="keyword">and</span> r &gt;= mid+<span class="number">1</span>:  <span class="comment">## 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] &gt; nums[r]:</span><br><span class="line">                arr[j] = nums[l]</span><br><span class="line">                cnt += r-mid  <span class="comment">#### 加上的个数</span></span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr[j] = nums[r]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= left:</span><br><span class="line">            arr[j] = nums[l]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &gt;= mid+<span class="number">1</span>:</span><br><span class="line">            arr[j] = nums[r]</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="comment">####  重置数组啊！！！</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">            nums[k] = arr[k]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left_res+right_res+cnt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-695-岛屿的最大面积</title>
    <url>/2020/03/15/Leetcode/leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p>
<p>示例 1:</p>
<p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p>
<p>示例 2:</p>
<p>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。</p>
<p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没啥好说的，直接dfs 遍历有<code>1</code>相连接的区域，优化的点在于，统计过的岛屿可以直接置为<code>0</code> 避免重复统计同一片岛屿</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    tmp = self.dfs(grid,i,j,m,n)</span><br><span class="line">                    mx = max(tmp,mx)    </span><br><span class="line">        <span class="keyword">return</span> mx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">dfs</span><span class="params">(self,grid,i,j,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> j &lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;= m <span class="keyword">or</span> j &gt;=n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        cnt += self.dfs(grid,i<span class="number">-1</span>,j,m,n)</span><br><span class="line">        cnt += self.dfs(grid,i+<span class="number">1</span>,j,m,n)</span><br><span class="line">        cnt += self.dfs(grid,i,j<span class="number">-1</span>,m,n)</span><br><span class="line">        cnt += self.dfs(grid,i,j+<span class="number">1</span>,m,n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p>时间复杂度是 $O(M*N)$，其中的M表示网格图的行数，N表示网格图的列数。 实际表示的含义就是每个点都遍历了一次。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-周赛-180场</title>
    <url>/2020/03/15/Leetcode/leetcode%E5%91%A8%E8%B5%9B180%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="周赛"><a href="#周赛" class="headerlink" title="周赛"></a>周赛</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/" target="_blank" rel="noopener">矩阵中的幸运数</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener">设计一个支持增量操作的栈</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" target="_blank" rel="noopener">将二叉搜索树变平衡</a><br><code>6 分</code> - <a href="https://leetcode-cn.com/problems/maximum-performance-of-a-team/" target="_blank" rel="noopener">最大的团队表现值</a></p>
<h3 id="矩阵中的幸运数"><a href="#矩阵中的幸运数" class="headerlink" title="矩阵中的幸运数"></a>矩阵中的幸运数</h3><p>暴力破解，给的条件限制不大</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">luckyNumbers</span> <span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                val = matrix[i][j]</span><br><span class="line">                <span class="keyword">if</span> self.isLucky(val,i,j,m,n,matrix):</span><br><span class="line">                    res.append(val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLucky</span><span class="params">(self,val,i,j,m,n,matrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val == min(matrix[i]): <span class="comment"># 一行的最小值</span></span><br><span class="line">            mx = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> range(m):</span><br><span class="line">                mx = max(matrix[row][j],mx)</span><br><span class="line">            <span class="keyword">if</span> mx == val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度….严格来讲这个有<code>O(N^3)</code>之多…</p>
<h3 id="设计一个支持增量操作的栈"><a href="#设计一个支持增量操作的栈" class="headerlink" title="设计一个支持增量操作的栈"></a>设计一个支持增量操作的栈</h3><p>模拟题， 注意下实现细节就好啦</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxSize: int)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        self.capacity = maxSize</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.cnt &lt; self.capacity:</span><br><span class="line">            self.stack.append(x)</span><br><span class="line">            self.cnt+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.cnt &lt;= <span class="number">0</span>:</span><br><span class="line">            rt =  <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rt = self.stack.pop()</span><br><span class="line">            self.cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rt</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, k: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt;= self.cnt:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                self.stack[i] += val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.cnt):</span><br><span class="line">                self.stack[i] += val</span><br><span class="line"><span class="comment"># Your CustomStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CustomStack(maxSize)</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># obj.increment(k,val)</span></span><br></pre></td></tr></table></figure>
<p>分析下时间复杂度：</p>
<p><code>pop</code>：时间复杂度为<code>o(1)</code></p>
<p><code>push</code>：时间复杂度<code>o(1)</code></p>
<h3 id="将二叉树变平衡"><a href="#将二叉树变平衡" class="headerlink" title="将二叉树变平衡"></a>将二叉树变平衡</h3><p>想到了当时平衡二叉搜索树的调整过程，但是印象中那个操作太难了。。。</p>
<p>本题：二叉树搜索树的中序遍历就是有序数组，根据有序数组构建平衡搜索二叉树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balanceBST</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 中序遍历的结果是 有序的</span></span><br><span class="line">        <span class="comment"># 平衡建树 就是让左右两部分尽量个数均匀</span></span><br><span class="line">        self.nums = []</span><br><span class="line">        self.visitBST(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(self.nums)<span class="number">-1</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(self.nums[mid])</span><br><span class="line">        root.left = self.buildBST(root,left,mid<span class="number">-1</span>)</span><br><span class="line">        root.right = self.buildBST(root,mid+<span class="number">1</span>,right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildBST</span><span class="params">(self,root,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        node = TreeNode(self.nums[mid])</span><br><span class="line">        node.left = self.buildBST(node,left,mid<span class="number">-1</span>)</span><br><span class="line">        node.right = self.buildBST(node,mid+<span class="number">1</span>,right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visitBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        self.visitBST(root.left)</span><br><span class="line">        self.nums.append(root.val)</span><br><span class="line">        self.visitBST(root.right)</span><br></pre></td></tr></table></figure>
<h3 id="最大的团队表现值"><a href="#最大的团队表现值" class="headerlink" title="最大的团队表现值"></a>最大的团队表现值</h3><p>先将efficiency按照降序排列，然后从前向后遍历，每次都计算并更新res的值</p>
<p>使用<code>优先队列</code>可以再遍历过程中，如果speed小于队首，则跳过，否则将speed 最小的先出队，再加入一个新的speed。</p>
<p>（主要的思想是贪心，但是为啥这样是有效的需要证明….）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPerformance</span><span class="params">(self, n: int, speed: List[int], efficiency: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        cls = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            cls.append((efficiency[i],speed[i]))</span><br><span class="line">        </span><br><span class="line">        cls = sorted(cls,key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        q = []</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &lt; k:</span><br><span class="line">                heapq.heappush(q,cls[i][<span class="number">1</span>])</span><br><span class="line">                s += cls[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q[<span class="number">0</span>] &lt; cls[i][<span class="number">1</span>]:</span><br><span class="line">                    s -= heapq.heappop(q)</span><br><span class="line">                    s += cls[i][<span class="number">1</span>]</span><br><span class="line">                    heapq.heappush(q,cls[i][<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># heapq.heappush(q,cls[i][1])</span></span><br><span class="line">            <span class="comment"># s += cls[i][1]</span></span><br><span class="line">            <span class="comment"># if len(q) &gt; k:</span></span><br><span class="line">            <span class="comment">#     s -= heapq.heappop(q)</span></span><br><span class="line">            res = max(res, s*cls[i][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-333-最大BST树</title>
    <url>/2020/03/15/Leetcode/leetcode-333-%E6%9C%80%E5%A4%A7BST%E6%A0%91/</url>
    <content><![CDATA[<h2 id="最大BST树"><a href="#最大BST树" class="headerlink" title="最大BST树"></a>最大BST树</h2><p>给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，其中最大指的是子树节点数最多的。</p>
<p>注意:<br>子树必须包含其所有后代。</p>
<p>示例:</p>
<p>输入: [10,5,15,1,8,null,7]</p>
<p>   10<br>   / \<br>  5  15<br> / \   \<br>1   8   7</p>
<p>输出: 3<br>解释: 高亮部分为最大的 BST 子树。<br>     返回值 3 在这个样例中为子树大小。<br>进阶:<br>你能想出用 O(n) 的时间复杂度解决这个问题吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/largest-bst-subtree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-bst-subtree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>见到这个题的时候，瞬间想到了之前做过的一次双周赛的题目：<a href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/" target="_blank" rel="noopener">1373. 二叉搜索子树的最大键值和</a></p>
<p>本质思想都是 树节点的回溯以及判断 是否是BST的过程。</p>
<p>以往判断一棵树是不是BST返回的信息只需要是True or False</p>
<p>这里每次返回的信息只告诉你（info，left_boundary，right_boundary），如果满足BST会对 <code>info</code>字段进行更新，如果不满足则会返回 <strong>(info,  minInt,  maxInt)</strong> 来表示只要包含此节点的树都不可能成为BST。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestBSTSubtree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        final = self.isBST(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBST</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        return (info, left_boundary, right_boundary)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="comment"># 对于空节点，是可以任意节点的子节点的  所以 让左边最大，右边界最小</span></span><br><span class="line">            <span class="comment"># 可以 满足 下面 对BST的判断</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>))</span><br><span class="line">        </span><br><span class="line">        left_res = self.isBST(root.left)</span><br><span class="line">        right_res = self.isBST(root.right)</span><br><span class="line">				</span><br><span class="line">        <span class="comment"># 判断左子树的最大值 小于 根； 右子树的最小值  大于 根  则为BST</span></span><br><span class="line">        <span class="keyword">if</span> left_res[<span class="number">2</span>] &lt; root.val  <span class="keyword">and</span>  root.val &lt; right_res[<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 本题 info: 最大个数，当然这里可以换成 最大和  最大值 最小值 等 其他信息</span></span><br><span class="line">            s = <span class="number">1</span> + left_res[<span class="number">0</span>] + right_res[<span class="number">0</span>]</span><br><span class="line">            self.res = max(self.res,s)</span><br><span class="line">            <span class="keyword">return</span> (s,min(left_res[<span class="number">1</span>],root.val), max(right_res[<span class="number">2</span>],root.val))</span><br><span class="line">				<span class="comment">#  跟空节点截然相反，如果一个根不可以是BST，那么返回这个根 左边是最小， 右边 最大 </span></span><br><span class="line">        <span class="comment">#  这样  回溯都上面任何一个包含此节点 根 都不可能为 BST</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, float(<span class="string">'-inf'</span>),float(<span class="string">'inf'</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-300-最长上升子序列</title>
    <url>/2020/03/15/Leetcode/leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>复习要点：</p>
<p>子序列是可以不连续的，子串必须连续</p>
<p>dp 理解dp所表示的含义：以当前作为结尾的最长上升子序列的长度</p>
</blockquote>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h4><p>建立一个dp数组，来保存最长上升子序列的长度。<code>dp[i]</code> 表示的就是<code>第i个</code>数作为最长上升子序列的结尾时，对应的长度。那么dp[i]的更新依赖于前面所有<code>nums[j]&lt;nums[i]</code>的值更新 $dp[i] = max\{dp[0],dp[1]…dp[i-1]\} + 1$</p>
<p>实际含义就是，前面所有比nums[i]小的数，都是以nums[i]为结尾的最长上升子序列的一部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>]* len(nums)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt; len(nums):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; cur:</span><br><span class="line">                <span class="keyword">if</span> nums[cur] &gt; nums[j]:</span><br><span class="line">                    dp[cur] = max(dp[cur],dp[j]+<span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            res = max(res,dp[cur])</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>相当于两次遍历，时间复杂度为$o(n^2)$， 空间复杂度为 <code>o(n)</code></p>
<h3 id="进阶思路"><a href="#进阶思路" class="headerlink" title="进阶思路"></a>进阶思路</h3><h4 id="dp-二分查找"><a href="#dp-二分查找" class="headerlink" title="dp+二分查找"></a>dp+二分查找</h4>]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1073-字符串的最大公因子</title>
    <url>/2020/03/12/Leetcode/leetcode-1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</url>
    <content><![CDATA[<h2 id="字符串的最大公因子"><a href="#字符串的最大公因子" class="headerlink" title="字符串的最大公因子"></a>字符串的最大公因子</h2><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p>
<p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p>
<p>示例 1：</p>
<p>输入：str1 = “ABCABC”, str2 = “ABC”<br>输出：”ABC”<br>示例 2：</p>
<p>输入：str1 = “ABABAB”, str2 = “ABAB”<br>输出：”AB”<br>示例 3：</p>
<p>输入：str1 = “LEET”, str2 = “CODE”<br>输出：””</p>
<p>提示：</p>
<p>1 &lt;= str1.length &lt;= 1000<br>1 &lt;= str2.length &lt;= 1000<br>str1[i] 和 str2[i] 为大写英文字母</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-common-divisor-of-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>自己的思路就是暴力穷举，如果存在这样字符串X，那一定是众多可行的解中最长的。所以考虑从后向前遍历，如果有满足的直接返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        n = min(len(str1),len(str2))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> (len(str1)%i)==<span class="number">0</span> <span class="keyword">and</span> (len(str2)%i)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> str1[:i]*(len(str1)//i) == str1 <span class="keyword">and</span> str1[:i]*(len(str2)//i) == str2:</span><br><span class="line">                    <span class="keyword">return</span> str1[:i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<h3 id="更好的思路"><a href="#更好的思路" class="headerlink" title="更好的思路"></a>更好的思路</h3><p>对于上面的暴力方法，我们可以发现<code>len(str1)%i==0 and len(str2)%i==0</code>实际上就是在找最大公约数的过程，那我们可以直接求出来一个最大公约数，然后直接check 能不能成立。 这里面存在着该问题正确性的证明。<br>详细证明可以参考 <a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/zi-fu-chuan-de-zui-da-gong-yin-zi-by-leetcode-solu/" target="_blank" rel="noopener"> 官方题解</a></p>
<p>证明的大概思路就是子问题套娃，如果存在一个x前缀串成立，那么就必然存在x’ 是最大公约数使问题成立。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        candidate_len = math.gcd(len(str1), len(str2))</span><br><span class="line">        candidate = str1[: candidate_len]</span><br><span class="line">        <span class="keyword">if</span> candidate * (len(str1) // candidate_len) == str1 <span class="keyword">and</span> candidate * (len(str2) // candidate_len) == str2:</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<h3 id="最优思路"><a href="#最优思路" class="headerlink" title="最优思路"></a>最优思路</h3><p>既然存在一个字符串x能同时呗str1 和str2进行整除，那str1和str2肯定有且仅包含字符串x。那么<code>str1+str2</code>的字符串和肯定也是只有x的。<code>str1+str2 == str2+str1</code>不管前后顺序，他们都是只有字符串x的。所以如果这个条件成立，那么肯定存在这样的解，如果不成立，那肯定不存在，直接返回空。</p>
<p>成立的话，根据前面解法的分析，直接返回最大公因数即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        candidate_len = math.gcd(len(str1), len(str2))</span><br><span class="line">        candidate = str1[: candidate_len]</span><br><span class="line">        <span class="keyword">if</span> str1 + str2 == str2 + str1:</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-1013-将数组分成和相等的三个部分</title>
    <url>/2020/03/11/Leetcode/leetcode-1013-%E5%88%86%E6%88%903%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="将数组分成和相等的三个部分"><a href="#将数组分成和相等的三个部分" class="headerlink" title="将数组分成和相等的三个部分"></a>将数组分成和相等的三个部分</h2><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p>
<p>形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。</p>
<p>示例 1：</p>
<p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]<br>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1<br>示例 2：</p>
<p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]<br>输出：false<br>示例 3：</p>
<p>输入：[3,3,6,5,-2,2,5,1,-9,4]<br>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p>
<p>提示：</p>
<p>3 &lt;= A.length &lt;= 50000<br>-10^4 &lt;= A[i] &lt;= 10^4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Python 装饰器</title>
    <url>/2020/03/09/python/%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>这个东西看起来高大上，实际上就是函数套娃。:weary:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am doing some boring work before executing a_func()"</span>)</span><br><span class="line"> </span><br><span class="line">        a_func()</span><br><span class="line"> </span><br><span class="line">        print(<span class="string">"I am doing some boring work after executing a_func()"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to remove my foul smell"</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: "I am the function which needs some decoration to remove my foul smell"</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure>
<p>上面的例子虽然简单(两层套娃)，但是基本就是<strong>装饰器</strong>的使用流程。那么我们将其改变成装饰器来看下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Hey you! Decorate me!"""</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to "</span></span><br><span class="line">          <span class="string">"remove my foul smell"</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#the @a_new_decorator is just a short way of saying:</span></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br></pre></td></tr></table></figure>
<p>这里面还是有几个需要注意的点：</p>
<ul>
<li>装饰器函数里面还有一个wrapTheFunction()，这个内置函数的存在是方便在真正调用被装饰函数之前和之后也可以进行一些操作，同时让装饰器函数能够返回一个\<function\></li>
<li>分清楚返回的是函数<code>f</code>还是函数结果<code>f()</code></li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode/leetcode-322-零钱兑换</title>
    <url>/2020/03/08/Leetcode/leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>复习要点：</p>
<p>从DFS 到 记忆化DFS  到 dp过程</p>
</blockquote>
<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<p>输入: coins = [1, 2, 5], amount = 11<br>输出: 3<br>解释: 11 = 5 + 5 + 1<br>示例 2:</p>
<p>输入: coins = [2], amount = 3<br>输出: -1<br>说明:<br>你可以认为每种硬币的数量是无限的。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一：自顶向下搜索回溯（超时）"><a href="#方法一：自顶向下搜索回溯（超时）" class="headerlink" title="方法一：自顶向下搜索回溯（超时）"></a>方法一：自顶向下搜索回溯（超时）</h4><p>暴力搜索，时间复杂度较高</p>
<p>时间复杂度：<br>O(S^n)，在最坏的情况下，复杂度是硬币数量的指数 ，是因为每个硬币面值<code>c</code>有$\frac{s}{c}$个方案。</p>
<p>因此，可能的组合数为：</p>
<script type="math/tex; mode=display">
\frac{s}{c_1}*\frac{s}{c_2}*\frac{s}{c_3}</script><p>空间复杂度为O(n)，只要来自递归调用栈的深度。</p>
<blockquote>
<p> eg：coins = [1, 2, 5], amount = 11</p>
<p> 基本思路就是<br> f(11) = min({f(11-1)},{f(11-2)},{f(11-5)})=min(f(10),f(9),f(6))</p>
<p> 然后再递归去计算<code>f(10),f(9),f(9)</code>如果画出来递归树，可以看到有非常多的重复计算。</p>
</blockquote>
<h4 id="方法二：记忆化搜索（拿缓存来存储已经计算过的数）"><a href="#方法二：记忆化搜索（拿缓存来存储已经计算过的数）" class="headerlink" title="方法二：记忆化搜索（拿缓存来存储已经计算过的数）"></a>方法二：记忆化搜索（拿缓存来存储已经计算过的数）</h4><p>经典的记忆化方法就是拿一个数组来存储，数组大小为总金额，如果某些地方计算过，则直接查表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原始查表方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.mem = [<span class="number">0</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.helper(coins,amount)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,coins,rem)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> rem &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> rem == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先查表，如果已经计算过则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> self.mem[rem] != <span class="number">0</span>: <span class="keyword">return</span> self.mem[rem]</span><br><span class="line">				<span class="comment"># 当前没有被计算过，则需要计算当前rem钱数所需要的最小硬币数</span></span><br><span class="line">        tmp_min = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="comment"># 尝试每种硬币数方案</span></span><br><span class="line">            res = self.helper(coins,rem-coin)</span><br><span class="line">            <span class="comment"># 取硬币数最少方案</span></span><br><span class="line">            <span class="keyword">if</span> res &gt;=<span class="number">0</span> <span class="keyword">and</span> res &lt; tmp_min:</span><br><span class="line">                tmp_min = <span class="number">1</span>+res</span><br><span class="line">        <span class="comment"># 有解 则返回min  无解返回-1</span></span><br><span class="line">        self.mem[rem] = <span class="number">-1</span> <span class="keyword">if</span> tmp_min == float(<span class="string">'inf'</span>) <span class="keyword">else</span> tmp_min</span><br><span class="line">        <span class="keyword">return</span> self.mem[rem]</span><br></pre></td></tr></table></figure>
<p><strong>！！！！</strong></p>
<p>讨论区，看到的使用python屌炸的记忆化操作 <code>functools.lru_cache(amount)</code></p>
<p>使用一个装饰器，来实现高效缓存。</p>
<blockquote>
<p>functools.lru_cache的作用主要是用来做缓存，他能把相对耗时的函数结果进行保存，避免传入相同的参数重复计算。同时，缓存并不会无限增长，不用的缓存会被释放。 <a href="https://blog.csdn.net/wzqnls/article/details/78506022" target="_blank" rel="noopener">来源</a></p>
<p>functools.lru_cache(maxsize=128, typed=False)有两个可选参数，我们来看看他们分别代表的意义。</p>
<ul>
<li><p>maxsize代表缓存的内存占用值，超过这个值之后，就的结果就会被释放，然后将新的计算结果进行缓存,其值应当设为2的幂次</p>
</li>
<li><p>typed若为True，则会把不同的参数类型得到的结果分开保存 *</p>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line"><span class="meta">        @functools.lru_cache(amount)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(rem)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> rem &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> rem == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            mini = int(<span class="number">1e9</span>)</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> self.coins:</span><br><span class="line">                res = dp(rem - coin)</span><br><span class="line">                <span class="keyword">if</span> res &gt;= <span class="number">0</span> <span class="keyword">and</span> res &lt; mini:</span><br><span class="line">                    mini = res + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> mini <span class="keyword">if</span> mini &lt; int(<span class="number">1e9</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        self.coins = coins</span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>
<p>这里有个知识点就是<strong>装饰器</strong></p>
<p>装饰器说白了就是方便进行函数嵌套使用，不用真的去嵌套着写，需要嵌套的话用<code>@fun</code>来装饰即可。</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>只用一维dp也是优化后的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        dp = [<span class="number">0</span>]+[float(<span class="string">'inf'</span>)]*amount</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(coin,amount+<span class="number">1</span>):</span><br><span class="line">                dp[i] = min(dp[i],dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount]!=float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-239-滑动窗口的最大值</title>
    <url>/2020/03/07/Leetcode/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例:</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<p>提示：</p>
<p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>暴力方法</strong>：</p>
<p>每次移动到一个新的窗口都计算一次本窗口内的最大值，如果窗口大小是K，一共N个数，时间复杂度为<code>o(kn)</code></p>
<p><strong>管理下标+双端队列</strong></p>
<ul>
<li><p>管理下标</p>
<p>因为该方法(窗口里面)处理的并不是实际的值，而是值所在的下标，这样的好处在于可以判断出当某个值已经出了窗口的时候，可以及时对窗口内的最大值进行更新</p>
</li>
<li><p>双端队列（可以看做滑动窗口）</p>
<p>使用的是双端队列，好处在于新的值可以从后侧入队，已经失效的最大值，则可以从前出队，这样队列内仍然保持了是滑动窗口的最大值</p>
</li>
</ul>
<p><strong>关键操作</strong>：</p>
<p>队列并不是每一个数都会进队的，待进队的元素依次跟队内的其他元素进行比较，如果待进队元素大于队列中某一个元素，则说明该元素不会是滑动窗口的最大值，将该元素从<strong>后侧出队</strong>。直到队列内没有比待进队元素小的元素，或者队列为空了，则将待进队元素的<code>下标</code>从<strong>后侧入队</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">    <span class="keyword">while</span> maxQ <span class="keyword">and</span> nums[i] &gt;= nums[maxQ[<span class="number">-1</span>]]:</span><br><span class="line">        maxQ.pop()</span><br><span class="line">    maxQ.append(i)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<blockquote>
<p>nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</p>
<ol>
<li>i=0，此时maxQ 为空，则将下标0加入队列：  maxQ = [0]</li>
<li>i=1，由于3&gt;1，则将队列内元素出队： maxQ= []   此时为空  然后再将i=1入队</li>
<li>i=2，由于-1&lt;3，-1是不可能成为窗口最大值的，但是有可能成为后面窗口的最大值，所以仍然将其从后侧入队</li>
</ol>
<p>…基本的处理流程就是上面这样，这样每次滑动一次的时候，队列内的头元素都是上一个窗口的最大值</p>
<p>而且这样也保证了队列内的元素是基本有序且是降序。</p>
</blockquote>
<p>详细介绍看注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        maxQ = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> maxQ <span class="keyword">and</span> nums[i] &gt;= nums[maxQ[<span class="number">-1</span>]]:</span><br><span class="line">                maxQ.pop()</span><br><span class="line">            maxQ.append(i)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 右侧的数依次加入  i的含义是 每次加入的数的下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n):  </span><br><span class="line">            <span class="comment"># 先将上一个窗口最大值放入结果集</span></span><br><span class="line">            res.append(nums[maxQ[<span class="number">0</span>]])</span><br><span class="line">            <span class="comment"># 考虑待入队元素，下标为i的数</span></span><br><span class="line">            <span class="keyword">while</span> maxQ <span class="keyword">and</span> nums[i] &gt;= nums[maxQ[<span class="number">-1</span>]]:</span><br><span class="line">                maxQ.pop()</span><br><span class="line">            <span class="comment"># 当前最大值是否应该出队，如果失效 则应出队</span></span><br><span class="line">            <span class="keyword">if</span> maxQ <span class="keyword">and</span> i-maxQ[<span class="number">0</span>] == k:</span><br><span class="line">                maxQ.pop(<span class="number">0</span>)</span><br><span class="line">            maxQ.append(i)</span><br><span class="line">        <span class="comment"># 别忘了，每次都是添加上一个窗口的最大值，循环退出时，结果集加上一次窗口的最大值</span></span><br><span class="line">        res.append(nums[maxQ[<span class="number">0</span>]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="相似题目-队列的最大值"><a href="#相似题目-队列的最大值" class="headerlink" title="相似题目 队列的最大值"></a>相似题目 队列的最大值</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>示例 1：</p>
<p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p>
<p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p>
<p>限制：</p>
<p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>关键操作跟上面是一样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> self.deque <span class="keyword">and</span> self.deque[<span class="number">-1</span>] &lt; value:</span><br><span class="line">    self.deque.pop()</span><br></pre></td></tr></table></figure>
<p>MaxQueue这个数据结构，主要操作是<code>push_back</code>和<code>pop_front</code></p>
<ul>
<li><code>push_back</code>：也就是每次加入一个新的元素时候，需要进行的操作。如果待入队元素比之前队列内任何一个元素都大，那么直接将其他元素从deque中出队即可。只留下  一个最大元素</li>
<li><code>pop_front</code>：从前面出队的时候，只需要考虑出去的元素跟最大元素是不是相等就好了，如果相等那么最大队列里面的元素也需要进行出队。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.deque = queue.deque()</span><br><span class="line">        self.queue = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.deque[<span class="number">0</span>] <span class="keyword">if</span> self.deque <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.deque <span class="keyword">and</span> self.deque[<span class="number">-1</span>] &lt; value:</span><br><span class="line">            self.deque.pop()</span><br><span class="line">        self.deque.append(value)</span><br><span class="line">        self.queue.put(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.deque:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        ans = self.queue.get()</span><br><span class="line">        <span class="keyword">if</span> ans == self.deque[<span class="number">0</span>]:</span><br><span class="line">            self.deque.popleft()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MaxQueue()</span></span><br><span class="line"><span class="comment"># param_1 = obj.max_value()</span></span><br><span class="line"><span class="comment"># obj.push_back(value)</span></span><br><span class="line"><span class="comment"># param_3 = obj.pop_front()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-489-扫地机器人</title>
    <url>/2020/03/06/Leetcode/leetcode-489-%E6%89%AB%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<h2 id="扫地机器人"><a href="#扫地机器人" class="headerlink" title="扫地机器人"></a>扫地机器人</h2><p>房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。</p>
<p>扫地机器人提供4个API，可以向前进，向左转或者向右转。每次转弯90度。</p>
<p>当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。</p>
<p>请利用提供的4个API编写让机器人清理整个房间的算法。</p>
<blockquote>
<p>interface Robot {<br>  // 若下一个方格为空，则返回true，并移动至该方格<br>  // 若下一个方格为障碍物，则返回false，并停留在原地<br>  boolean move();</p>
<p> // 在调用turnLeft/turnRight后机器人会停留在原位置<br>  // 每次转弯90度<br>  void turnLeft();<br>  void turnRight();</p>
<p> // 清理所在方格<br> void clean();<br>}</p>
</blockquote>
<p>示例:</p>
<p>输入:</p>
<blockquote>
<p>room = [<br>  [1,1,1,1,1,0,1,1],<br>  [1,1,1,1,1,0,1,1],<br>  [1,0,1,1,1,1,1,1],<br>  [0,0,0,1,0,0,0,0],<br>  [1,1,1,1,1,1,1,1]<br>],<br>row = 1,<br>col = 3</p>
</blockquote>
<p>解析:<br>房间格栅用0或1填充。0表示障碍物，1表示可以通过。<br>机器人从row=1，col=3的初始位置出发。在左上角的一行以下，三列以右。<br>注意:</p>
<p>输入只用于初始化房间和机器人的位置。你需要“盲解”这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用4个给出的API解决问题。<br>扫地机器人的初始位置一定是空地。<br>扫地机器人的初始方向向上。<br>所有可抵达的格子都是相连的，亦即所有标记为1的格子机器人都可以抵达。<br>可以假定格栅的四周都被墙包围。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/robot-room-cleaner" target="_blank" rel="noopener">https://leetcode-cn.com/problems/robot-room-cleaner</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先都会想到用DFS+回溯，只不过这里额外多了个机器人接口，除了进行搜索操作外，还应该及时操作机器人，对应上搜索操作。</p>
<p>首先看普通的dfs</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.visited = set()</span><br><span class="line">    <span class="comment"># 上 右 下 左</span></span><br><span class="line">    self.rd = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    self.cd = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,robot,i=<span class="number">0</span>,j=<span class="number">0</span>,d=<span class="number">0</span>)</span>:</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 标记遍历</span></span><br><span class="line">    self.visited.add((i,j))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"> 				<span class="comment"># 四个方向选一个继续dfs</span></span><br><span class="line">        newr,newc = i + self.rd[k], j+self.cd[k]</span><br><span class="line">        <span class="comment"># 如果没有遍历过就进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (newr,newc) <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</span><br><span class="line">            <span class="comment"># 继续进行dfs</span></span><br><span class="line">            self.dfs(robot,newr,newc)</span><br></pre></td></tr></table></figure>
<p>对应本题，还需要考虑机器人的情况：</p>
<ul>
<li>机器人可以运动的方向有四个（上，下，左，右），不可能上一次考虑完<code>上</code>，下一次就去考虑<code>下</code>，机器人旋转需要按照顺时针（或逆时针方向）。</li>
<li>如果该遍历的地方已经进行了遍历，需要回退，在图上就简单的坐标操作就完成了回退，这里对于机器人还需要进行额外的回退操作。</li>
<li>机器人方向的一致性：即从当前点，进入到下一个点的时候，机器人的朝向应该是一致的，而返回时候方向恰好相反</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment"># This is the robot's control interface.</span></span><br><span class="line"><span class="comment"># You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment">#class Robot:</span></span><br><span class="line"><span class="comment">#    def move(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Returns true if the cell in front is open and robot moves into the cell.</span></span><br><span class="line"><span class="comment">#        Returns false if the cell in front is blocked and robot stays in the current cell.</span></span><br><span class="line"><span class="comment">#        :rtype bool</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def turnLeft(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Robot will stay in the same cell after calling turnLeft/turnRight.</span></span><br><span class="line"><span class="comment">#        Each turn will be 90 degrees.</span></span><br><span class="line"><span class="comment">#        :rtype void</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def turnRight(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Robot will stay in the same cell after calling turnLeft/turnRight.</span></span><br><span class="line"><span class="comment">#        Each turn will be 90 degrees.</span></span><br><span class="line"><span class="comment">#        :rtype void</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def clean(self):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        Clean the current cell.</span></span><br><span class="line"><span class="comment">#        :rtype void</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.visited = set()</span><br><span class="line">        <span class="comment"># 上 右 下 左    顺时针方向！！！</span></span><br><span class="line">        self.rd = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">        self.cd = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cleanRoom</span><span class="params">(self, robot)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type robot: Robot</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.dfs(robot)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,robot,i=<span class="number">0</span>,j=<span class="number">0</span>,d=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.visited.add((i,j))</span><br><span class="line">        robot.clean()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            new_d = (d+k) % <span class="number">4</span> <span class="comment"># 机器人方向的一致性</span></span><br><span class="line">            newr,newc = i + self.rd[new_d], j+self.cd[new_d]</span><br><span class="line">            <span class="keyword">if</span> (newr,newc) <span class="keyword">not</span> <span class="keyword">in</span> self.visited <span class="keyword">and</span> robot.move():</span><br><span class="line">                <span class="comment"># 内层 dfs 死掉 需要 回头</span></span><br><span class="line">                self.dfs(robot,newr,newc,new_d)</span><br><span class="line">                <span class="comment"># dfs跳出表示遍历完，机器人需要进行回退操作</span></span><br><span class="line">                self.back(robot)</span><br><span class="line">            robot.turnRight() <span class="comment"># 下一个位置  注意跟 newr,newc对应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 专门的回退操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self,robot)</span>:</span></span><br><span class="line">        <span class="comment"># 掉头</span></span><br><span class="line">        robot.turnRight()</span><br><span class="line">        robot.turnRight()</span><br><span class="line">        <span class="comment"># 回退</span></span><br><span class="line">        robot.move()</span><br><span class="line">        <span class="comment"># 重置方向 跟之前一样</span></span><br><span class="line">        robot.turnRight()</span><br><span class="line">        robot.turnRight()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-1103-分糖果II</title>
    <url>/2020/03/05/Leetcode/leetcode-1103-%E5%88%86%E7%B3%96%E6%9E%9CII/</url>
    <content><![CDATA[<h2 id="分糖果II"><a href="#分糖果II" class="headerlink" title="分糖果II"></a>分糖果II</h2><p>排排坐，分糖果。</p>
<p>我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。</p>
<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p>
<p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p>
<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>
<p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p>
<p>示例 1：</p>
<p>输入：candies = 7, num_people = 4<br>输出：[1,2,3,1]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3,0]。<br>第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。<br>示例 2：</p>
<p>输入：candies = 10, num_people = 3<br>输出：[5,2,3]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3]。<br>第四次，ans[0] += 4，最终数组变为 [5,2,3]。</p>
<p>提示：</p>
<p>1 &lt;= candies &lt;= 10^9<br>1 &lt;= num_people &lt;= 1000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/distribute-candies-to-people" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distribute-candies-to-people</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先看到10^9限制，可能暴力不可行，但是想了下，由于每次分的糖果都是递增的，所以并不是严格的10^9</p>
<blockquote>
<p>$等差数列求和 \frac{n(n+1)}{2}&lt;=candies$，这样解出来的n 应该是$\sqrt{candies}$级别的，同时需要初始化时候$O(N)$</p>
<p>则最终的时间复杂度为$O(max(\sqrt{G},N))$，其中G为糖果数，N为人数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, num_people: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> num_people &lt;=<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> candies &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]*num_people</span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        res = [<span class="number">0</span>]*num_people</span><br><span class="line">        <span class="keyword">while</span> candies &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num_people):</span><br><span class="line">                <span class="keyword">if</span> candies-num &gt;= <span class="number">0</span>:</span><br><span class="line">                    res[i] += num</span><br><span class="line">                    candies -= num</span><br><span class="line">                    num+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res[i] += candies</span><br><span class="line">                    candies = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>更加简短的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, num_people: int)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">0</span>] * num_people</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 巧妙的利用%  因为是在 num_people中循环</span></span><br><span class="line">        <span class="keyword">while</span> candies != <span class="number">0</span>:</span><br><span class="line">            ans[i % num_people] += min(i + <span class="number">1</span>, candies)</span><br><span class="line">            candies -= min(i + <span class="number">1</span>, candies)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="拓展解法"><a href="#拓展解法" class="headerlink" title="拓展解法"></a>拓展解法</h3><p><strong>该解法来自leetcode讨论区：官方提供的解法</strong></p>
<p>思路是先给第一个小朋友分配好所有他应得的，然后再给第二个。。。以此类推</p>
<p>那么怎么计算就是个数学问题了</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcierp42qlj30yy0rejup.jpg" alt="数学推导"></p>
<p>通过上面的操作可以得到<code>p</code>也就是会分配的次数，最后一次由于达不到p+1个糖果，所以最后一次就会被分配剩下所有的。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcievkri7bj31ai0lwgo7.jpg" alt="以C=29为例"></p>
<p>接下来就是计算如何分配，</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcif0hztaaj31aa0lugp3.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcj96el9buj311w0nmn07.jpg" alt="具体算法"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, num_people: int)</span> -&gt; List[int]:</span></span><br><span class="line">        n = num_people</span><br><span class="line">        <span class="comment"># how many people received complete gifts</span></span><br><span class="line">        p = int((<span class="number">2</span> * candies + <span class="number">0.25</span>)**<span class="number">0.5</span> - <span class="number">0.5</span>) </span><br><span class="line">        remaining = int(candies - (p + <span class="number">1</span>) * p * <span class="number">0.5</span>)</span><br><span class="line">        rows, cols = p // n, p % n</span><br><span class="line">        </span><br><span class="line">        d = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># complete rows</span></span><br><span class="line">            d[i] = (i + <span class="number">1</span>) * rows + int(rows * (rows - <span class="number">1</span>) * <span class="number">0.5</span>) * n</span><br><span class="line">            <span class="comment"># cols in the last row</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; cols:</span><br><span class="line">                d[i] += i + <span class="number">1</span> + rows * n</span><br><span class="line">        <span class="comment"># remaining candies        </span></span><br><span class="line">        d[cols] += remaining</span><br><span class="line">        <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-286-墙与门</title>
    <url>/2020/03/04/Leetcode/leetcode-286-%E5%A2%99%E4%B8%8E%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>复习要点</p>
</blockquote>
<h2 id="墙与门"><a href="#墙与门" class="headerlink" title="墙与门"></a>墙与门</h2><p>你被给定一个 m × n 的二维网格，网格中有以下三种可能的初始化值：</p>
<p>-1 表示墙或是障碍物<br>0 表示一扇门<br>INF 无限表示一个空的房间。然后，我们用 $2^{31} - 1 = 2147483647$ 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。<br>你要给每个空房间位上填上该房间到 最近 门的距离，如果无法到达门，则填 INF 即可。</p>
<p>示例：</p>
<p>给定二维网格：</p>
<p>INF  -1  0  INF<br>INF INF INF  -1<br>INF  -1 INF  -1<br>  0  -1 INF INF<br>运行完你的函数后，该网格应该变成：</p>
<p>  3  -1   0   1<br>  2   2   1  -1<br>  1  -1   2  -1<br>  0  -1   3   4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/walls-and-gates" target="_blank" rel="noopener">https://leetcode-cn.com/problems/walls-and-gates</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首选是BFS，因为这个跟距离门的远近有关，如果都跟门直接相连，那么距离就是1，所以确定基本思路是BFS</p>
<p>其次，使用<code>多源BFS</code>，意思也就是几个起点同时开始BFS，其实也不是完全严格意义的BFS，如果把他们看成树的话，他们是在同一层的，然后由这一层同时向下遍历。</p>
<p>这里有一个隐藏的思考点，在于多源同时BFS，那么距离某一个源最近的点肯定会先被修改值为距离，后面的源再遍历到这里的时候就已经有值了，而且再遍历到这个点时候的距离肯定大于等于该点已有的距离值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rooms:</span><br><span class="line">            <span class="keyword">return</span> rooms</span><br><span class="line">        dr = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        dc = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        m = len(rooms)</span><br><span class="line">        n = len(rooms[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 先把有门的地方都放进来，定义有门的地方path距离是0</span></span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> rooms[i][j] == <span class="number">0</span>:</span><br><span class="line">                    q.append((i,j,<span class="number">0</span>))</span><br><span class="line">        <span class="comment"># 多源同时进行BFS</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r,c,path = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                newr,newc = r+dr[i],c+dc[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=newr&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=newc&lt;n <span class="keyword">and</span> <span class="number">2147483647</span> == rooms[newr][newc]:</span><br><span class="line">                    rooms[newr][newc] = path+<span class="number">1</span></span><br><span class="line">                    q.append((newr,newc,path+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-994-腐烂的橘子</title>
    <url>/2020/03/04/Leetcode/leetcode-994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<blockquote>
<p>复习要点：</p>
<p>宽度优先遍历（或 多源BFS）：先将所有符合条件的点加入队列，然后再执行BFS</p>
</blockquote>
<h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p>
<p>示例 1：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gch90mxfttj310a07njs9.jpg" alt="img"></p>
<p>输入：[[2,1,1],[1,1,0],[0,1,1]]<br>输出：4<br>示例 2：</p>
<p>输入：[[2,1,1],[0,1,1],[1,0,1]]<br>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。<br>示例 3：</p>
<p>输入：[[0,2]]<br>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p>
<p>提示：</p>
<p>1 &lt;= grid.length &lt;= 10<br>1 &lt;= grid[0].length &lt;= 10<br>grid[i][j] 仅为 0、1 或 2</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotting-oranges" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看到提示的数据大小，基本可以判定暴力bfs可以求解的。说下暴力BFS的思路。</p>
<p>首先为什么要用BFS呢？ 一个烂橘子先感染周边橘子，然后周边橘子再向下感染。这个过程就是BFS的遍历过程呀，而BFS的迭代深度，就是腐烂需要的天数。</p>
<p>为什么叫暴力呢？因为不可能仅有一个腐烂橘子，可能一开始全局有多个腐烂的橘子，那就需要分别从多个腐烂橘子处进行一次BFS，这时候需要维护一个变量来存储状态<code>stats[i][j],i,j表示第几行第几列，某个数值来表示可能腐烂的天数，初始化为Inf</code>，每从某一个腐烂源进行BFS时候，都更新下stats的状态，让stats记录<code>最小值</code>，最终还需要再遍历一次stats，找到最大的天数，即为最终的腐烂天数。如果最终仍然有橘子的腐烂天数为<code>inf</code></p>
<h3 id="优秀的解题思路：多源BFS"><a href="#优秀的解题思路：多源BFS" class="headerlink" title="优秀的解题思路：多源BFS"></a>优秀的解题思路：多源BFS</h3><p>为什么叫多源呢？因为前面分析了，开局不可能只有一个烂橘子，所以需要找到最开始的所有烂橘子，然后同时从这些烂橘子开始进行BFS。</p>
<p>如何保证同时进行BFS呢？其实也不是严格意义的同时，只是这些乱橘子在同一层（同一天），我们把开局的时候算作第0天，那么先将所有烂橘子入队，也就是表示了第0天的烂橘子，当这些烂橘子都出队完成一次更新时候，新进来的烂橘子就都是第1天的。同理….一直到所有橘子都烂掉。</p>
<p>这里需要维持一个cnt变量，即新鲜橘子有多少个，当cnt为0时候可以跳出，返回结果，如果不为0则返回-1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orangesRotting</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 定义4个方向</span></span><br><span class="line">        dr = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        dc = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 先把烂橘子都入队</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">				<span class="comment"># 定义一个双端队列</span></span><br><span class="line">        q = deque()</span><br><span class="line">        cnt = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">                    q.append((i,j,<span class="number">0</span>))</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        m_dep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r,c,depth = q.popleft()</span><br><span class="line">            m_dep = max(m_dep,depth)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                newr,newc = r+dr[i],c+dc[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=newr&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=newc&lt;n <span class="keyword">and</span> grid[newr][newc]==<span class="number">1</span>:</span><br><span class="line">                    cnt-=<span class="number">1</span></span><br><span class="line">                    grid[newr][newc] = <span class="number">2</span></span><br><span class="line">                    q.append((newr,newc,depth+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> cnt != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> cnt == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> m_dep</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-986-区间列表的交集</title>
    <url>/2020/03/03/Leetcode/leetcode-986-%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h2 id="区间列表的交集"><a href="#区间列表的交集" class="headerlink" title="区间列表的交集"></a>区间列表的交集</h2><p>给定两个由一些闭区间组成的列表，每个区间列表都是成对不相交的，并且已经排序。</p>
<p>返回这两个区间列表的交集。</p>
<p>（形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。）</p>
<p>示例：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcg246xnt1j31as0cymxq.jpg" alt="img"></p>
<blockquote>
<p>输入：A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]<br>输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]<br>注意：输入和所需的输出都是区间对象组成的列表，而不是数组或列表。</p>
</blockquote>
<p>提示：</p>
<blockquote>
<p>0 &lt;= A.length &lt; 1000<br>0 &lt;= B.length &lt; 1000<br>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</p>
</blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/interval-list-intersections" target="_blank" rel="noopener">https://leetcode-cn.com/problems/interval-list-intersections</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次都要找到两个区间重合的地方：</p>
<blockquote>
<p>重合地方的判定：重合部分的起点是两个区间中起点的较大值，重合部分的终点是两个区间终点的较小值#，如果重合部分起点&lt;= 终点，存在重合 加入结果集</p>
</blockquote>
<p>找到重合地方之后需要进行移动，移动哪个的标准就是 之前相融合的两个区间，哪个区间终点小，就去掉</p>
<p>因为我们已经找到一个重合区间或者不存在重合，那么之后还需要再继续重复前面的工作，较小的区间永远都不会再跟后边有交集了 直接去掉较小的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intervalIntersection</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> j &lt; len(B):</span><br><span class="line">						<span class="comment"># 重合地方的判定 起点是两个区间起点的最大值，终点是两个区间的最小值</span></span><br><span class="line">            lo = max(A[i][<span class="number">0</span>],B[j][<span class="number">0</span>])</span><br><span class="line">            hi = min(A[i][<span class="number">1</span>],B[j][<span class="number">1</span>])</span><br><span class="line">						<span class="comment"># 重合部分起点&lt;= 终点，存在重合 加入结果集</span></span><br><span class="line">            <span class="keyword">if</span> lo &lt;= hi:</span><br><span class="line">                res.append([lo,hi])</span><br><span class="line">            <span class="comment"># 决定哪个区间进行移动</span></span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-382-链表随机节点</title>
    <url>/2020/03/02/Leetcode/leetcode-382-%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="链表随机节点"><a href="#链表随机节点" class="headerlink" title="链表随机节点"></a>链表随机节点</h2><p>给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。</p>
<p>进阶:<br>如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？</p>
<p>示例:</p>
<blockquote>
<p> // 初始化一个单链表 [1,2,3].<br>ListNode head = new ListNode(1);<br>head.next = new ListNode(2);<br>head.next.next = new ListNode(3);<br>Solution solution = new Solution(head);</p>
<p> // getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。<br>solution.getRandom();</p>
</blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-random-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-random-node</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把整个单链表看成是一个数据流，从数据流中进行采样</p>
<p><strong>蓄水池采样</strong>的核心是：</p>
<blockquote>
<p>假设当前正要读取第n个数据，则我们以1/n的概率留下该数据，否则留下前n-1个数据中的一个。</p>
<p>等概率证明：</p>
<p>对于只有一个数，概率就是1</p>
<p>对于2个数，则第一个先取到的概率为1，当第二个数来时，选择以1/2的概率保留，则总的来讲，取第一个数的概率为1*1/2，对于第二个数来讲，概率为1/2</p>
<p>…</p>
<p>对于n个数，有</p>
<p>第一个数：$1<em>\frac{1}{2}</em>\frac{2}{3} … *\frac{n-1}{n} = \frac{1}{n}$</p>
<p>第二个数：$\frac{1}{2}<em>\frac{2}{3} … </em>\frac{n-1}{n} = \frac{1}{n}$</p>
<p>…</p>
<p>第n个数：$\frac{1}{n}$</p>
<p>所以对于这n个数来说是等概率的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, head: ListNode)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @param head The linked list's head.</span></span><br><span class="line"><span class="string">        Note that the head is guaranteed to be not null, so it contains at least one node.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.linkedList = head</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns a random node's value.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 首元素被选中概率为1</span></span><br><span class="line">        r_data = self.linkedList.val</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        p = self.linkedList.next</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 决定是否随机替换掉</span></span><br><span class="line">            <span class="keyword">if</span> rd.randint(<span class="number">1</span>,cnt) == cnt:</span><br><span class="line">                r_data = p.val</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(head)</span></span><br><span class="line"><span class="comment"># param_1 = obj.getRandom()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>蓄水池采样</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-398-随机数索引（蓄水池采样）</title>
    <url>/2020/03/02/Leetcode/leetcode-398-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="随机数索引（蓄水池采样）"><a href="#随机数索引（蓄水池采样）" class="headerlink" title="随机数索引（蓄水池采样）"></a>随机数索引（蓄水池采样）</h2><p>给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。</p>
<p>注意：<br>数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。</p>
<p>示例:</p>
<p>int[] nums = new int[] {1,2,3,3,3};<br>Solution solution = new Solution(nums);</p>
<p>// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。<br>solution.pick(3);</p>
<p>// pick(1) 应该返回 0。因为只有nums[0]等于1。<br>solution.pick(1);</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/random-pick-index" target="_blank" rel="noopener">https://leetcode-cn.com/problems/random-pick-index</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>限制了不可以开辟额外空间，而且数字大小很大的话，最好是O（N）遍历</p>
<p><strong>蓄水池采样</strong>的核心是：</p>
<blockquote>
<p>假设当前正要读取第n个数据，则我们以1/n的概率留下该数据，否则留下前n-1个数据中的一个。</p>
<p>等概率证明：</p>
<p>对于只有一个数，概率就是1</p>
<p>对于2个数，则第一个先取到的概率为1，当第二个数来时，选择以1/2的概率保留，则总的来讲，取第一个数的概率为1*1/2，对于第二个数来讲，概率为1/2</p>
<p>…</p>
<p>对于n个数，有</p>
<p>第一个数：$1<em>\frac{1}{2}</em>\frac{2}{3} … *\frac{n-1}{n} = \frac{1}{n}$</p>
<p>第二个数：$\frac{1}{2}<em>\frac{2}{3} … </em>\frac{n-1}{n} = \frac{1}{n}$</p>
<p>…</p>
<p>第n个数：$\frac{1}{n}$</p>
<p>所以对于这n个数来说是等概率的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.nums)):</span><br><span class="line">            <span class="keyword">if</span> self.nums[i] == target:</span><br><span class="line">                <span class="comment"># 第一次遇到 概率就是 1嘛</span></span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    index = i</span><br><span class="line">                <span class="comment"># </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># random.randint 返回闭区间 [a,b]</span></span><br><span class="line">                    <span class="comment"># 选到cnt的概率为  1/cnt</span></span><br><span class="line">                    <span class="keyword">if</span> rd.randint(<span class="number">1</span>,cnt) == cnt:</span><br><span class="line">                        index = i</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.pick(target)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>蓄水池采样</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-周赛-178场</title>
    <url>/2020/03/01/Leetcode/leetcode%E5%91%A8%E8%B5%9B178%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="周赛——178场"><a href="#周赛——178场" class="headerlink" title="周赛——178场"></a>周赛——178场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">有多少小于当前数字的数字</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/rank-teams-by-votes/" target="_blank" rel="noopener">通过投票对团队排名</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/" target="_blank" rel="noopener">二叉树中的列表</a><br><code>7 分</code> - <a href="https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/" target="_blank" rel="noopener">使网格图至少有一条有效路径的最小代价</a></p>
<h3 id="T1-有多少小于当前数字的数字"><a href="#T1-有多少小于当前数字的数字" class="headerlink" title="T1 有多少小于当前数字的数字"></a>T1 有多少小于当前数字的数字</h3><p>看了下题目的数字限制</p>
<blockquote>
<ul>
<li><code>2 &lt;= nums.length &lt;= 500</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</blockquote>
<p>直接暴力求解了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m = len(nums)</span><br><span class="line">        res = [<span class="number">0</span>]*m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            res[i] = cnt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="T2-通过投票对团队进行排名"><a href="#T2-通过投票对团队进行排名" class="headerlink" title="T2 通过投票对团队进行排名"></a>T2 通过投票对团队进行排名</h3><p>模拟就好了，先对每个人的投票情况进行计数，这个地方考虑一个存储结构，我用的是字典</p>
<blockquote>
<p>每个key对应的value是一个list，list的长度取决于共有多少个团队</p>
<p>votes = [“ABC”,”ACB”,”ABC”,”ACB”,”ACB”]</p>
<p>dict = {</p>
<p>​    ‘A’:[5,0,0],</p>
<p>​    ‘B’:[0,2,3],</p>
<p>​    ‘C:[0,3,2]’</p>
<p>}</p>
</blockquote>
<p>统计好投票情况之后，再进行插排即可，插入排序的比较方法需要自己定义一下：</p>
<p>即按照约定的大小方法，如果得票较靠前则按票数排序，如果票一样则按照字典序排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rankTeams</span><span class="params">(self, votes: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="comment">#先统计 再 插排</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> votes <span class="keyword">or</span> len(votes[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        n = len(votes)</span><br><span class="line">        m = len(votes[<span class="number">0</span>])</span><br><span class="line">        d_cnt = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 完成统计</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                ch = votes[i][j]</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> d_cnt:</span><br><span class="line">                    d_cnt[ch][j] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> ch <span class="keyword">not</span> <span class="keyword">in</span> d_cnt:</span><br><span class="line">                    d_cnt[ch] = [<span class="number">0</span>]*m</span><br><span class="line">                    d_cnt[ch][j] = <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> ch,value <span class="keyword">in</span> d_cnt.items():</span><br><span class="line">            index = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">                res.append(ch)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># insert 插入在前面插入</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">                    tmp = res[i]</span><br><span class="line">                    <span class="keyword">if</span> self.less(tmp,ch,m,d_cnt):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        index = i</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">                res.append(ch)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.insert(index,ch)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">less</span><span class="params">(self,a,b,m,d_cnt)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> d_cnt[a][i] &gt; d_cnt[b][i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> d_cnt[a][i] == d_cnt[b][i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b &gt; a</span><br></pre></td></tr></table></figure>
<h3 id="T3-二叉树中的列表"><a href="#T3-二叉树中的列表" class="headerlink" title="T3 二叉树中的列表"></a>T3 二叉树中的列表</h3><p>思路很简单，先找到链表头结点对应的树中节点，然后再进行DFS进行匹配即可。</p>
<ul>
<li><p>链表头结点对应的树中节点</p>
<p>我用的bfs，如果当前节点值与链表头结点一样 则开始进入dfs</p>
</li>
<li><p>dfs进行匹配</p>
<p>限制一些规则，分别进行匹配即可</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubPath</span><span class="params">(self, head: ListNode, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        p = head</span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">while</span> p :</span><br><span class="line">            lst.append(p.val)</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        q = []</span><br><span class="line">        q.append(root)</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span>  q:</span><br><span class="line">            node = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.val == lst[<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># print(node)</span></span><br><span class="line">                flag = self.dfs_check(node,lst,<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_check</span><span class="params">(self,node,lst,index)</span>:</span></span><br><span class="line">        <span class="comment"># print(index)</span></span><br><span class="line">        <span class="keyword">if</span> index == len(lst):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.val != lst[index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.val == lst[index]:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        left = self.dfs_check(node.left,lst,index)</span><br><span class="line">        right = self.dfs_check(node.right,lst,index)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure>
<h3 id="T4-使网格图至少有一条有效路径的最小代价"><a href="#T4-使网格图至少有一条有效路径的最小代价" class="headerlink" title="T4 使网格图至少有一条有效路径的最小代价"></a>T4 使网格图至少有一条有效路径的最小代价</h3><p>比赛时候都没有来得及看。</p>
<p>看了大家分享的思路，貌似把整个问题转化成了一个<strong>图</strong>的问题</p>
<ul>
<li>如果当前位置 的指向，正好是将去遍历的下一个位置 那么其边的权重为0</li>
<li>如果不一样，则其边的权重为1 </li>
</ul>
<p>最终求的是至少有一条有效路径的最小代价，有效路径是指能从(0,0)到(n,n)。最小代价是指，所用的cost最少。最短路的感觉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 用来 记录 是否在队列里面 （而不是是否被遍历过。。）</span></span><br><span class="line">        vis = np.zeros_like(grid)</span><br><span class="line">        <span class="comment"># 用来 记录  最小cost</span></span><br><span class="line">        dist = np.ones_like(grid)*np.inf</span><br><span class="line">        <span class="comment"># 方向，这里有个trick  这个 顺序 跟题目 1，2，3，4 所表示的方向一致</span></span><br><span class="line">        dx = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">        dy = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        queue = []</span><br><span class="line">        queue.append((<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># BFS过程</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curx,cury = queue.pop(<span class="number">0</span>) <span class="comment">### 超时</span></span><br><span class="line">            vis[curx][cury] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">                nxt_x,nxt_y = curx+dx[i],cury+dy[i]</span><br><span class="line">                <span class="keyword">if</span> self.valid(nxt_x,nxt_y,m,n):</span><br><span class="line">                    <span class="keyword">if</span> grid[curx][cury] == i:</span><br><span class="line">                        tmp = dist[curx][cury]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tmp = dist[curx][cury]+<span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(nxt_x,nxt_y)</span></span><br><span class="line">                    <span class="comment">###  重点的地方！！！  如果当前可能产生的tmp cost 小于 dist 则更新</span></span><br><span class="line">                    <span class="keyword">if</span> tmp &lt; dist[nxt_x][nxt_y]:</span><br><span class="line">                        dist[nxt_x][nxt_y] = tmp</span><br><span class="line">                        <span class="comment">### 如果没有被遍历过 则按照BFS流程 加入到队列里面，如果已经在队列里面就不用管了</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> vis[nxt_x][nxt_y]:</span><br><span class="line">                            vis[nxt_x][nxt_y] = <span class="number">1</span></span><br><span class="line">                            queue.append((nxt_x,nxt_y))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> int(dist[m<span class="number">-1</span>][n<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(self,x,y,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> x&gt;=m <span class="keyword">or</span> y &gt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode</title>
    <url>/2020/03/01/Leetcode/leetcode%E5%91%A8%E8%B5%9B177%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="周赛——177场"><a href="#周赛——177场" class="headerlink" title="周赛——177场"></a>周赛——177场</h2>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-13-罗马数字转整数</title>
    <url>/2020/02/29/Leetcode/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<p>输入: “III”<br>输出: 3<br>示例 2:</p>
<p>输入: “IV”<br>输出: 4<br>示例 3:</p>
<p>输入: “IX”<br>输出: 9<br>示例 4:</p>
<p>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.<br>示例 5:</p>
<p>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/roman-to-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本上思路就是 模拟</p>
<p>一个字符一个字符的置换成对应的数，如果较小的出现在较大的前面，则进行减法，其余进行加法操作。</p>
<p>这样就产生了前一个和当前字符的概念，需要使用两个指针来记录前一个 和后一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        table = &#123;<span class="string">'M'</span>:<span class="number">1000</span>, </span><br><span class="line">                 <span class="string">'D'</span>:<span class="number">500</span>,</span><br><span class="line">                 <span class="string">'C'</span>:<span class="number">100</span>,</span><br><span class="line">                 <span class="string">'L'</span>:<span class="number">50</span>,</span><br><span class="line">                 <span class="string">'X'</span>:<span class="number">10</span>,</span><br><span class="line">                 <span class="string">'V'</span>:<span class="number">5</span>,</span><br><span class="line">                 <span class="string">'I'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre = table[s[<span class="number">0</span>]]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            cur = table[s[i]]</span><br><span class="line">            <span class="keyword">if</span> pre &lt; cur:</span><br><span class="line">                res -= pre</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += pre</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="comment"># 退出时候，最后一个 赋值为 pre 直接加</span></span><br><span class="line">        res += pre</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-28-实现strStr</title>
    <url>/2020/02/27/Leetcode/leetcode-28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr"></a>实现strStr</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        kmp = KMP(needle)</span><br><span class="line">        <span class="keyword">return</span> kmp.search(haystack)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pat)</span>:</span></span><br><span class="line">        self.p_len = len(pat)</span><br><span class="line">        self.dp = [[<span class="number">0</span>]*<span class="number">128</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.p_len)]</span><br><span class="line">        self.pat = pat</span><br><span class="line">				<span class="comment"># 这段太经典了，尝试用 状态机的 形式来理解这段</span></span><br><span class="line">        <span class="comment"># i 所代表的 不要第一时间理解为下标，这个地方更好的理解是状态</span></span><br><span class="line">        x=<span class="number">0</span></span><br><span class="line">        self.dp[<span class="number">0</span>][ord(self.pat[<span class="number">0</span>])] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,self.p_len):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">128</span>):</span><br><span class="line">                <span class="keyword">if</span> ord(self.pat[i]) == j:</span><br><span class="line">                    <span class="comment"># 遇到符合标准的字符串</span></span><br><span class="line">                    self.dp[i][j] = i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.dp[i][j] = self.dp[x][j]</span><br><span class="line">            </span><br><span class="line">            x = self.dp[x][ord(self.pat[i])]</span><br><span class="line">        print(self.dp)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, tat)</span>:</span></span><br><span class="line">        m = len(tat)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            j = self.dp[j][ord(tat[i])]</span><br><span class="line">            <span class="keyword">if</span> j == self.p_len:</span><br><span class="line">                <span class="keyword">return</span> i-self.p_len+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-12-整数转罗马数字</title>
    <url>/2020/02/26/Leetcode/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: 3<br>输出: “III”<br>示例 2:</p>
<p>输入: 4<br>输出: “IV”<br>示例 3:</p>
<p>输入: 9<br>输出: “IX”<br>示例 4:</p>
<p>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.<br>示例 5:</p>
<p>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
</blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>主要的思路就是 查表+贪心</p>
<p>查表体现在：我们尽可能将核心组成数组 用一个dict 存储起来</p>
<p>贪心体现在：每次我们都是先用一个尽可能大的 表中数字去进行处理，优先使用大的符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        table = &#123;<span class="string">'M'</span>:<span class="number">1000</span>, </span><br><span class="line">                 <span class="string">'CM'</span>:<span class="number">900</span>,</span><br><span class="line">                 <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">                 <span class="string">'CD'</span>:<span class="number">400</span>,</span><br><span class="line">                 <span class="string">'C'</span>:<span class="number">100</span>,</span><br><span class="line">                 <span class="string">'XC'</span>:<span class="number">90</span>,</span><br><span class="line">                 <span class="string">'L'</span>:<span class="number">50</span>,</span><br><span class="line">                 <span class="string">'XL'</span>:<span class="number">40</span>,</span><br><span class="line">                 <span class="string">'X'</span>:<span class="number">10</span>,</span><br><span class="line">                 <span class="string">'IX'</span>:<span class="number">9</span>,</span><br><span class="line">                 <span class="string">'V'</span>:<span class="number">5</span>,</span><br><span class="line">                 <span class="string">'IV'</span>:<span class="number">4</span>,</span><br><span class="line">                 <span class="string">'I'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> table.keys(): <span class="comment"># 潜在的贪心过程，因为table 我是按从大到小写的，遍历过程也会按照从大到小进行</span></span><br><span class="line">            cnt = num // table[key]</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            res += cnt * key</span><br><span class="line">            num -= cnt * table[key]</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-25-K个一组翻转链表</title>
    <url>/2020/02/26/Leetcode/leetcode-25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>示例 :</p>
<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>说明 :</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解题方式很简单，就是K个翻转一次，比较难理解的地方在于需要维护多个变量，来实现这个方法</p>
<blockquote>
<ul>
<li>start指针：待翻转链表的头结点，翻转后变成尾结点</li>
<li>end指针：待翻转链表的尾节点，翻转后变成头结点</li>
<li>pre指针：待翻转链表的前面部分（可以理解为 已经完成操作的节点的尾部）</li>
<li>nxt指针：未进行操作的链表头部</li>
</ul>
</blockquote>
<p>下图来自LeetCode讨论区：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/" target="_blank" rel="noopener">王小二</a></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc96g7ia6nj30lx10stax.jpg" alt="k个一组翻转链表.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pre = dummy</span><br><span class="line">        end = dummy</span><br><span class="line">        dummy.next = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> end:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                end = end.next <span class="keyword">if</span> end <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> end:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            nxt = end.next</span><br><span class="line">            end.next = <span class="literal">None</span></span><br><span class="line">            start = pre.next</span><br><span class="line">            pre.next = self.reverse(start)</span><br><span class="line">            start.next = nxt <span class="comment">### start 跑到尾部了</span></span><br><span class="line">            pre = start</span><br><span class="line">            end = start</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            nxt = p.next</span><br><span class="line">            p.next = pre</span><br><span class="line">            pre = p</span><br><span class="line">            p = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-138-复制带随机指针的链表</title>
    <url>/2020/02/26/Leetcode/leetcode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h2><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的 深拷贝。 </p>
<p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</p>
<p>示例 1：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc94qezsp7j31gs0aq0u5.jpg" alt="img"></p>
<blockquote>
<p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
</blockquote>
<p>更多示例 <a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">原题</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用的是剑指里面的解题思路。先把链表的每一个节点都copy一遍，并且追加到该节点之后</p>
<blockquote>
<p>即: 1-2-3-4 -&gt;  1-1’-2-2’-3-3’-4-4’</p>
</blockquote>
<p>然后再将随机指针按照原来的形式，追加到各个复制节点上</p>
<blockquote>
<p>即 若原来有一个 1——4的随机指针，那么复制的节点 也应该有 1’——4’这样一个随机指针</p>
</blockquote>
<p>然后再重新遍历整个链表，将链表拆开，返回深拷贝的链表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 1.复制一遍链表</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            tmp = Node(p.val,p.next)</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = tmp.next</span><br><span class="line">        <span class="comment"># 2.复制random 指针</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p :</span><br><span class="line">            q = p.next</span><br><span class="line">            q.random = p.random.next <span class="keyword">if</span> p.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p = q.next</span><br><span class="line">        <span class="comment"># 3.从头遍历，拆出来指针</span></span><br><span class="line">        p = head</span><br><span class="line">        dummy = head.next</span><br><span class="line">        q = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q.random = p.random.next <span class="keyword">if</span> p.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p = q.next</span><br><span class="line">            q.next = p.next <span class="keyword">if</span> p <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            q = q.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/02/22/SwordOffer/test/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>SwordOffer/矩阵中的路径</title>
    <url>/2020/02/22/SwordOffer/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<hr>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright(c) 2020 Mereder. All Rights Reserved</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Brief:</span></span><br><span class="line"><span class="string">File Name: matrixPath.py</span></span><br><span class="line"><span class="string">Author: mereder@163.com</span></span><br><span class="line"><span class="string">Date: 2020-06-22 11:52:05</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[["a","b","c","e"],</span></span><br><span class="line"><span class="string">["s","f","c","s"],</span></span><br><span class="line"><span class="string">["a","d","e","e"]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键点： 回溯框架；回溯时的状态更改：找不到才重新置为0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exits</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        m = len(board)</span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, j, depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> word[depth] == board[i][j]:</span><br><span class="line">                visited[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># up down left right</span></span><br><span class="line">                up = backtrack(i+<span class="number">1</span>, j, depth+<span class="number">1</span>)</span><br><span class="line">                down = backtrack(i<span class="number">-1</span>, j, depth+<span class="number">1</span>)</span><br><span class="line">                left = backtrack(i, j<span class="number">-1</span>, depth+<span class="number">1</span>)</span><br><span class="line">                right = backtrack(i, j+<span class="number">1</span>, depth+<span class="number">1</span>)</span><br><span class="line">                tmp = tmp <span class="keyword">or</span> up <span class="keyword">or</span> down <span class="keyword">or</span> left <span class="keyword">or</span> right</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tmp: <span class="comment">## 容易考虑不清的点</span></span><br><span class="line">                    visited[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                res = backtrack(i, j, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> res:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    board = [[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"e"</span>],[<span class="string">"s"</span>,<span class="string">"f"</span>,<span class="string">"c"</span>,<span class="string">"s"</span>],[<span class="string">"a"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"e"</span>]]</span><br><span class="line">    res = s.exits(board, <span class="string">'bfcA'</span>)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Union-Find</title>
    <url>/2020/02/22/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h2 id="Union-find"><a href="#Union-find" class="headerlink" title="Union-find"></a>Union-find</h2><p>并查集，主要用来解决在一个集合中查找是否存在另一个元素，或者合并两个集合。更常见的应用是连通分量。更具体一点的应用场景：</p>
<ul>
<li>网络连接</li>
<li>变量名等价性</li>
<li>数学集合</li>
</ul>
<p>涉及到的主要操作就是Union和Find</p>
<p>基本的实现有 <code>fast_find</code> <code>fast_union</code> ，这里只给出一个《算法第四版》的简单实现，重点是看后边实现的高效的<code>Union_Find</code></p>
<h3 id="Union-Find-基本例子"><a href="#Union-Find-基本例子" class="headerlink" title="Union-Find 基本例子"></a>Union-Find 基本例子</h3><h3 id="更高效的实现（-logN-）"><a href="#更高效的实现（-logN-）" class="headerlink" title="更高效的实现（$logN$）"></a>更高效的实现（$logN$）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    并查集： 10^7 mem out...</span></span><br><span class="line"><span class="string">    union:</span></span><br><span class="line"><span class="string">    find:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.index = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        self.cnt = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        self.maxCnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            self.index[i] = i</span><br><span class="line">            self.cnt[i] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.index[root] != root:</span><br><span class="line">            root = self.index[root]</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self,p,q)</span>:</span></span><br><span class="line">        root_p = self.find(p)</span><br><span class="line">        root_q = self.find(q)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root_p == root_q:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.cnt[root_p] &lt; self.cnt[root_q]:</span><br><span class="line">            self.cnt[root_q] += self.cnt[root_p]</span><br><span class="line">            self.index[root_p] = root_q</span><br><span class="line">            self.maxCnt = max(self.maxCnt,self.cnt[root_q])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.cnt[root_p] += self.cnt[root_q]</span><br><span class="line">            self.index[root_q] = root_p</span><br><span class="line">            self.maxCnt = max(self.maxCnt,self.cnt[root_p])</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isConnected</span><span class="params">(p,q)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(p) == self.find(q)</span><br></pre></td></tr></table></figure>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>原理就是在<code>find</code>过程，将沿途的路径都进行一次压缩。</p>
<p>压缩的含义就是指: 1-&gt;3-&gt;5这样的路径，变成1-&gt;3 , 1-&gt;5 ，这样再执行查找的过程中路径会更短一些，最终UF中的同一个连通分量都会直接指向根。</p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode/leetcode-980-不同路径III</title>
    <url>/2020/02/19/Leetcode/leetcode-980-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III/</url>
    <content><![CDATA[<h2 id="不同路径III"><a href="#不同路径III" class="headerlink" title="不同路径III"></a>不同路径III</h2><p>在二维网格 grid 上，有 4 种类型的方格：</p>
<p>1 表示起始方格。且只有一个起始方格。<br>2 表示结束方格，且只有一个结束方格。<br>0 表示我们可以走过的空方格。<br>-1 表示我们无法跨越的障碍。<br>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]<br>输出：2<br>解释：我们有以下两条路径：</p>
<p>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</p>
<p>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</p>
<p>示例 2：<br>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]<br>输出：4<br>解释：我们有以下四条路径： </p>
<p>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</p>
<p>(0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</p>
<p>(0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</p>
<p>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</p>
<p>示例 3：</p>
<p>输入：[[0,1],[2,0]]<br>输出：0<br>解释：<br>没有一条路能完全穿过每一个空的方格一次。<br>请注意，起始和结束方格可以位于网格中的任意位置。</p>
</blockquote>
<p>提示：</p>
<p>1 &lt;= grid.length * grid[0].length &lt;= 20</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>自己的思路上来就是DFS，因为给的提示是<code>1&lt;= len(grid)*len(grid[0])&lt;=20</code>,说明数据量很小，DFS应该没问题</p>
<p>况且，需要遍历所有0位置，一开始没有想到动态规划如何来解决。那就用DFS来遍历所有位置。</p>
<p>每一次到达终点时候都需要检测是否grid内部的0都被探测到了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># grid &lt;=1 &lt;= 20</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        result = []</span><br><span class="line">        stack = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    self.help(i+<span class="number">1</span>, j, m, n, grid, result, stack)</span><br><span class="line">                    self.help(i<span class="number">-1</span>, j, m, n, grid, result, stack)</span><br><span class="line">                    self.help(i, j+<span class="number">1</span>, m, n, grid, result, stack)</span><br><span class="line">                    self.help(i, j<span class="number">-1</span>, m, n, grid, result, stack)</span><br><span class="line"></span><br><span class="line">        result = len(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(self, i,j,m,n,grid, result,stack)</span>:</span> <span class="comment"># result stack  都是 set</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i &gt;=m <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> grid[i][j]==<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> grid[i][j]==<span class="number">2</span> <span class="keyword">and</span> self.check(grid,m,n):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> grid[i][j]==<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> self.check(grid,m,n):</span><br><span class="line">            result.append(stack)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            grid[i][j] = <span class="number">-2</span></span><br><span class="line">            stack.add((i,j))</span><br><span class="line">            self.help(i,j+<span class="number">1</span>,m,n,grid,result,stack)</span><br><span class="line">            self.help(i,j<span class="number">-1</span>,m,n,grid,result,stack)</span><br><span class="line">            self.help(i+<span class="number">1</span>,j,m,n,grid,result,stack)</span><br><span class="line">            self.help(i<span class="number">-1</span>,j,m,n,grid,result,stack)</span><br><span class="line">            stack.add((i,j))</span><br><span class="line">            grid[i][j] = <span class="number">0</span>        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self,grid,m,n)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="延续【不同路径】系列问题思路"><a href="#延续【不同路径】系列问题思路" class="headerlink" title="延续【不同路径】系列问题思路"></a>延续【不同路径】系列问题思路</h3><p>继续动态规划</p>
]]></content>
  </entry>
  <entry>
    <title>第一次参加Leetcode周赛</title>
    <url>/2020/02/16/Leetcode/leetcode%E5%91%A8%E8%B5%9B176%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="周赛——176场"><a href="#周赛——176场" class="headerlink" title="周赛——176场"></a>周赛——176场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/" target="_blank" rel="noopener">统计有序矩阵中的负数</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/" target="_blank" rel="noopener">最后 K 个数的乘积</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/" target="_blank" rel="noopener">最多可以参加的会议数目</a><br><code>6 分</code> - <a href="https://leetcode-cn.com/problems/construct-target-array-with-multiple-sums/" target="_blank" rel="noopener">多次求和构造目标数组</a></p>
<h3 id="统计有序矩阵中的负数"><a href="#统计有序矩阵中的负数" class="headerlink" title="统计有序矩阵中的负数"></a>统计有序矩阵中的负数</h3><p>谈到有序！！！瞬间想到  <code>二分查找</code>，尤其是看了题意之后，这跟<a href="">Leetcode-74-搜索二维矩阵</a>解题思路基本一致。</p>
<p>关键点就是，定义行标，列标，从右上角开始遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNegatives</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        col = n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> row&lt;m <span class="keyword">and</span> col &gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> grid[row][col] &lt; <span class="number">0</span>:</span><br><span class="line">                result += m-row</span><br><span class="line">                col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>时间复杂度分析：<code>o(m+n)</code> 其实就是行指针和列指针各走一遍，相比于o(m<em>n)的解题方法，这里主要是通过行列两个指针，同时移动达到优化的。原本`m</em>n`方法，行列不会进行继承，跟前面遍历过后的没有关系。</p>
<h3 id="最后K个数的乘积"><a href="#最后K个数的乘积" class="headerlink" title="最后K个数的乘积"></a>最后K个数的乘积</h3><p>算法设计题目，原理很简单，设置一个list来保存每次添加的数，计算乘积时候，从后向前连乘K个即可。这里有很明显的问题，就是效率问题，计算连乘时候时间复杂度是<code>O(N)</code>的。</p>
<p>自然想到的时间优化策略就是用空间来换，如果我们保存好每个位置的乘积结果，那么最后K个数的乘积有:</p>
<p><code>f(k) = f(n)/f(n-k)</code>，因为都是连乘，那么也不需要刚开始说的list来保存添加的数了，只需要一个list保存连乘结果——<code>前缀乘</code></p>
<p>但是！ 遇到为0的情况需要特殊处理。</p>
<ul>
<li>遇到0的地方，那么前面的连乘结果就是0了，所以当其中一个元素为0时候，我们可以考虑丢弃前面所有结果了，重置数组和参数<code>nums</code></li>
<li>再调用时候，如果k大于0后的元素个数，那么结果一定为0，否则按照除法求得结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductOfNumbers</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sequence = []</span><br><span class="line">        self.nums = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            self.sequence = []  <span class="comment"># 关键地方！！！</span></span><br><span class="line">            self.nums = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.nums == <span class="number">0</span>:</span><br><span class="line">                self.sequence.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.sequence.append(self.sequence[self.nums<span class="number">-1</span>]*num)</span><br><span class="line">            self.nums += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getProduct</span><span class="params">(self, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &lt; k: <span class="comment"># ！！！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.nums == k:</span><br><span class="line">            <span class="keyword">return</span> self.sequence[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.sequence[self.nums<span class="number">-1</span>] // self.sequence[self.nums-k<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 3,1,2,10,40</span></span><br><span class="line"><span class="comment"># 1,2,10,40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your ProductOfNumbers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = ProductOfNumbers()</span></span><br><span class="line"><span class="comment"># obj.add(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getProduct(k)</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度分析：<code>o(1)</code>因为结果都已经进行了保存，直接获取即可，空间复杂度为<code>o(n)</code>如果没有0出现，将保存整个前缀积</p>
<h3 id="最多可以参加的会议数目"><a href="#最多可以参加的会议数目" class="headerlink" title="最多可以参加的会议数目"></a>最多可以参加的会议数目</h3><p><strong>优先队列</strong>：说白了就是小根堆或者大根堆，看出去的元素优先出最小的还是最大的。</p>
<p>第一次接触优先队列，就遇到这样一个，我感觉比较难的题。</p>
<p>参考了别人的解法，基本思路就是：</p>
<ol>
<li>按照开始时间进行排序，如果开始时间比当前时间早即：current<code>小，那么这个会议可以加入考虑，将其结束时间放入优先队列，</code>注意：python 的heapq默认实现的是小根堆，也就是优先出小的元素。`</li>
<li>然后对优先队列的top进行判断，check是否<code>时间&lt;current</code>，这个时间就是上一步加入的结束时间，如果<code>结束时间&lt;current</code>表示该会议无法安排，则让其出队。</li>
<li>然后进行判断<code>队列是否为空</code>，不空则表示有可以安排的会议，然后<code>安排且仅能安排一个，即res+=1，并且top出队</code>。</li>
<li>直到满足 <code>i ==n and len(queue) == 0</code> 即待安排events 没有了，且队列中没有可安排的会议。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEvents</span><span class="params">(self, events: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 按照开始时间排序</span></span><br><span class="line">        events.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        current = <span class="number">1</span></span><br><span class="line">        pq = [] <span class="comment"># 默认是个小根堆</span></span><br><span class="line">        n = len(events)</span><br><span class="line">        <span class="comment"># max_time = max(max(events,key=lambda x:x[1]))</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 1.加入  值得安排的 会议</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> events[i][<span class="number">0</span>] &lt;= current:</span><br><span class="line">                heapq.heappush(pq, events[i][<span class="number">1</span>])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 2. 剔除不满足条件的会议</span></span><br><span class="line">            <span class="keyword">while</span> len(pq) &gt; <span class="number">0</span> <span class="keyword">and</span> pq[<span class="number">0</span>] &lt; current:</span><br><span class="line">                heapq.heappop(pq)</span><br><span class="line">            <span class="comment"># 3. 安排且仅能安排一个会议</span></span><br><span class="line">            <span class="keyword">if</span> len(pq) &gt; <span class="number">0</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                heapq.heappop(pq)</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 4. 弹尽粮绝 跳出</span></span><br><span class="line">            <span class="keyword">if</span> i == n <span class="keyword">and</span> len(pq) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="多次求和构造目标数组"><a href="#多次求和构造目标数组" class="headerlink" title="多次求和构造目标数组"></a>多次求和构造目标数组</h3><p>上来自己的垃圾思路就是 DFS，直接暴力枚举所有情况，直到出现有解得情况…</p>
<p>即 每一步加和的结果，可以成为下一步任一位置的值…这个复杂度太高了</p>
<p>其实倒过来想就很简单了：<strong>由本溯源</strong></p>
<p>对于给定的一个序列，只需要模拟情况，由当前序列，按照规则不断递减，看能否得到全1的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPossible</span><span class="params">(self, target: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            cur_max = max(target)</span><br><span class="line">            <span class="keyword">if</span> cur_max == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            s  = sum(target)</span><br><span class="line">            idx = target.index(cur_max)</span><br><span class="line">            increase = s-cur_max</span><br><span class="line">            <span class="keyword">if</span> increase &gt;= cur_max:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            target[idx] = cur_max-increase</span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li>上面的解法对于testcase:<code>[10^9,1]</code>需要循环10^9次，肯定超时了…大佬们都在说LeetCode测试数据太弱了。将上面的  <code>target[idx] = cur_max - increase</code> 修改为: <code>target[idx] = cur_max % increase</code>换成取模后，对于上面提到的问题，可以很快解决了。</li>
<li>还有问题，对于testcase:<code>[2]</code>，这个问题，上面将陷入无限循环，应该首先对这个进行优先判断。</li>
</ul>
<p>完整解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPossible</span><span class="params">(self, target: List[int])</span> -&gt; bool:</span></span><br><span class="line">      	<span class="keyword">if</span> len(target) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> target[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            cur_max = max(target)</span><br><span class="line">            <span class="keyword">if</span> cur_max == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            s  = sum(target)</span><br><span class="line">            idx = target.index(cur_max)</span><br><span class="line">            increase = s-cur_max</span><br><span class="line">            <span class="keyword">if</span> increase &gt;= cur_max:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            target[idx] = cur_max % increase</span><br></pre></td></tr></table></figure>
<h4 id="更多考虑"><a href="#更多考虑" class="headerlink" title="更多考虑"></a>更多考虑</h4><p>第四题：</p>
<p>来源<a href="https://leetcode-cn.com/circle/discuss/0gO5RS/" target="_blank" rel="noopener">周赛题目讨论区</a>  用户：<a href="https://leetcode-cn.com/u/scut_dell/" target="_blank" rel="noopener">小白二号</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (target.length == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       PriorityQueue&lt;Long&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">       <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length; i++) &#123;</span><br><span class="line">           sum += target[i];</span><br><span class="line">           pq.offer((<span class="keyword">long</span>)target[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果此时队列为空或者最大值就是1，直接return true</span></span><br><span class="line">       <span class="keyword">if</span> (pq.isEmpty() || pq.<span class="built_in">peek</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">//取出最大的那个</span></span><br><span class="line">           Long poll = pq.poll();</span><br><span class="line">           <span class="comment">//如果此时堆中最大的为1</span></span><br><span class="line">           <span class="keyword">if</span> (pq.<span class="built_in">peek</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//直接看它满足或不满足公式</span></span><br><span class="line">               <span class="keyword">return</span> (poll - <span class="number">1</span>) % (sum - poll) == <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//需要计算多少轮才能比第二小的数小</span></span><br><span class="line">               <span class="keyword">long</span> n = (poll - pq.<span class="built_in">peek</span>()) / (sum - poll) + <span class="number">1</span>;</span><br><span class="line">               <span class="comment">//得到这个数字</span></span><br><span class="line">               <span class="keyword">long</span> x = poll - n * (sum - poll);</span><br><span class="line">               <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//更新sum</span></span><br><span class="line">               sum = poll - (sum - poll) * (n - <span class="number">1</span>);</span><br><span class="line">               pq.offer(x);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode/leetcode-66-加一</title>
    <url>/2020/02/12/Leetcode/leetcode-66-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<hr>
<p>title</p>
<hr>
<h2 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>模拟实现过程，并且注意特殊情况，既然是从低位开始+1，则遍历数组需要从后向前。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 倒序遍历</span></span><br><span class="line">        index = len(digits)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 初始化情况</span></span><br><span class="line">        digits[index] = digits[index]+<span class="number">1</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 满足进位条件，则进行进位</span></span><br><span class="line">            <span class="keyword">if</span> digits[index]+carry&gt;<span class="number">9</span>:</span><br><span class="line">                digits[index] = (digits[index]+carry)%<span class="number">10</span> <span class="comment"># 模10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 不满足进位，加上可能存在的carry,然后直接退出就可以了</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[index] += carry </span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 判断是否需要再补入一个1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span> <span class="keyword">and</span> carry ==<span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]+digits</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-369-给单链表加1</title>
    <url>/2020/02/12/Leetcode/leetcode-369-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8A%A01/</url>
    <content><![CDATA[<h2 id="给单链表加1"><a href="#给单链表加1" class="headerlink" title="给单链表加1"></a>给单链表加1</h2><p>用一个 非空 单链表来表示一个非负整数，然后将这个整数加一。</p>
<p>你可以假设这个整数除了 0 本身，没有任何前导的 0。</p>
<p>这个整数的各个数位按照 高位在链表头部、低位在链表尾部 的顺序排列。</p>
<p>示例:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>发现有大神分享的思路太好了，所以直接按照他们的思路进行了编码。</p>
<p>这个题目最棘手的问题就是遇到含有9且以9结尾，就涉及到进位的问题：</p>
<blockquote>
<p>举个例子：</p>
<p>1-2-9-3-4 这个我们不需要担心，因为不是以9结尾</p>
<p>1-2-3-9-9 这个就很棘手，如果+1的话会造成两次进位，但是问题简化下，实际只需要在3处进位一次，后边置0即可</p>
</blockquote>
<ul>
<li>对于某个节点值为9，我们希望有个指针停留在9之前，这样我们方便进位，也能把之后的值都置为0</li>
<li>对于某个节点值为0-8，我们希望指针停留在当前节点，直接在当前节点上+1即可，无需额外操作</li>
</ul>
<p>根据上面的分析，自然想到用双指针，其中一个指针用来遍历链表，另外一个指针用来表示上面的情况。由于<code>left</code>,需要先在<code>right</code>前面才能保证首位如果是9的话，left仍在前面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">dummy.next = head</span><br><span class="line">left = dummy</span><br><span class="line">right = head</span><br><span class="line"><span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">  <span class="keyword">if</span> right.val != <span class="number">9</span>:</span><br><span class="line">    left = right</span><br><span class="line">  right = right.next</span><br></pre></td></tr></table></figure>
<p>由于上面的移动，最终的<code>left</code>指针就是我们需要操作的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left.val += <span class="number">1</span></span><br><span class="line">p = left.next</span><br><span class="line"><span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">  p.val = <span class="number">0</span></span><br><span class="line">  p = p.next</span><br></pre></td></tr></table></figure>
<p>但是这里还有另外一个问题，如果遇到首位就是9的情况怎么办？那意味着我们需要重新创建一个头结点并且值为1，后续结点都为0。</p>
<p>巧了！前面我们为了保证left起始时在right前面，定义了一个哑变量<code>dummy node</code>，我们可以利用这个节点，来完成，所以修改如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dummy = ListNode(<span class="number">0</span>) <span class="comment"># 由原来的-1 变为0 这样+1之后就有含义了</span></span><br><span class="line">dummy.next = head</span><br><span class="line">left = dummy</span><br><span class="line">right = head</span><br><span class="line"><span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">  <span class="keyword">if</span> right.val != <span class="number">9</span>:</span><br><span class="line">    left = right</span><br><span class="line">  right = right.next</span><br></pre></td></tr></table></figure>
<p>最后返回时候，我们需要确认，dummy node的值是否更新了，如果更新为1则返回dummy，否则返回dummy.next</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> dummy.val == <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">return</span> dummy.next</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>
<h3 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h3><p>时间复杂度为<code>o(N)</code>,空间复杂度为<code>o(1)</code>，因为使用了一个dummy node  3个指针，都是常数级别的</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        left = dummy</span><br><span class="line">        right = head</span><br><span class="line">        <span class="comment"># 始终更新left 和right保证left 始终在某个可能的9的左侧</span></span><br><span class="line">        <span class="keyword">while</span> right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> right.val != <span class="number">9</span>:</span><br><span class="line">                left = right</span><br><span class="line">            right = right.next </span><br><span class="line">        </span><br><span class="line">        left.val += <span class="number">1</span></span><br><span class="line">        p = left.next</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            p.val = <span class="number">0</span></span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dummy.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode/leetcode-155-最小栈</title>
    <url>/2020/02/11/Leetcode/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<hr>
<hr>
<h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) — 将元素 x 推入栈中。<br>pop() — 删除栈顶的元素。<br>top() — 获取栈顶元素。<br>getMin() — 检索栈中的最小元素。<br>示例:</p>
<p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   —&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      —&gt; 返回 0.<br>minStack.getMin();   —&gt; 返回 -2.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-stack" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是借助一个辅助栈，来实现常数时间内获取最小值。</p>
<p>原理就是每次加入 辅助最小栈时，先比较，如果比最小栈栈顶元素小，就压入元素，否则就把原来的最小栈栈顶元素再次压入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.m_stack = []</span><br><span class="line">        self.nums = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums == <span class="number">0</span>:</span><br><span class="line">            self.m_stack.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> x &lt; self.m_stack[<span class="number">-1</span>]:</span><br><span class="line">                self.m_stack.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.m_stack.append(self.m_stack[<span class="number">-1</span>])</span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.nums += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">            self.m_stack.pop()</span><br><span class="line">            self.nums -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'栈为空'</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.nums &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.m_stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'栈为空'</span>)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-707-设计链表</title>
    <url>/2020/02/11/Leetcode/leetcode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<p>在链表类中实现这些功能：</p>
<p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<p>示例：</p>
<p>MyLinkedList linkedList = new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            //返回2<br>linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>linkedList.get(1);            //返回3</p>
<p>提示：</p>
<p>所有val值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>emmm 看见几个月前用java尝试了N边都错的题，Python一遍就过了…看了下当时写的java，不忍卒读，难怪会出问题。</p>
<p>注意几个地方：</p>
<ul>
<li>及时更新 capacity</li>
<li>使用一个dummy node 当 header</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        self.val = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># dummy 头</span></span><br><span class="line">        self.head = ListNode(<span class="number">-1</span>)</span><br><span class="line">        self.capacity = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># index 范围是 0-n-1</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.capacity:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> p.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = ListNode(val)</span><br><span class="line">        tmp.next = self.head.next</span><br><span class="line">        self.head.next = tmp</span><br><span class="line">        self.capacity += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = ListNode(val)</span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p.next != <span class="literal">None</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">        p.next = tmp</span><br><span class="line">        self.capacity += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.capacity:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index == self.capacity:</span><br><span class="line">            self.addAtTail(val)</span><br><span class="line">        <span class="keyword">elif</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            self.addAtHead(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = self.head</span><br><span class="line">            <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">            tmp = ListNode(val)</span><br><span class="line">            tmp.next = p.next</span><br><span class="line">            p.next = tmp</span><br><span class="line">            self.capacity += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span><span class="params">(self, index: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.capacity <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = self.head</span><br><span class="line">            <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p.next == <span class="literal">None</span>:</span><br><span class="line">                p = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = p.next.next</span><br><span class="line">            self.capacity -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第一次参加Leetcode周赛</title>
    <url>/2020/02/09/Leetcode/leetcode%E5%91%A8%E8%B5%9B175%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="第一次参加周赛"><a href="#第一次参加周赛" class="headerlink" title="第一次参加周赛"></a>第一次参加周赛</h2><p>之前觉得太菜了，还是好好耍基础题，搞什么周赛，直到我参加了之后，才发现，我是真的菜！….</p>
<h2 id="周赛-175场"><a href="#周赛-175场" class="headerlink" title="周赛-175场"></a>周赛-175场</h2><p><code>3 分</code> - <a href="https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/" target="_blank" rel="noopener">检查整数及其两倍数是否存在</a><br><code>4 分</code> - <a href="https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/" target="_blank" rel="noopener">制造字母异位词的最小步骤数</a><br><code>5 分</code> - <a href="https://leetcode-cn.com/problems/tweet-counts-per-frequency/" target="_blank" rel="noopener">推文计数</a><br><code>7 分</code> - <a href="https://leetcode-cn.com/problems/maximum-students-taking-exam/" target="_blank" rel="noopener">参加考试的最大学生数</a></p>
<h3 id="第一题：easy"><a href="#第一题：easy" class="headerlink" title="第一题：easy"></a>第一题：easy</h3><p>跟2sum差不多的路子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfExist</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        tmp_dict = set([])</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            tmp = arr[i]</span><br><span class="line">            <span class="keyword">if</span> tmp*<span class="number">2</span> <span class="keyword">in</span> tmp_dict:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> tmp/<span class="number">2</span> <span class="keyword">in</span> tmp_dict:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            tmp_dict.add(tmp)</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>
<p>复杂度分析：时间复杂度是<code>o(n)</code>，空间复杂度也是<code>o(n)</code>，n是数组元素个数。由于使用了<code>set</code>也是一种hash结构嘛，所以空间复杂度实际应该大于<code>o(n)</code>,具体到多少，就需要看<code>set</code>的实现机制了。</p>
<h3 id="第二题：Medium"><a href="#第二题：Medium" class="headerlink" title="第二题：Medium"></a>第二题：Medium</h3><p>看完题意之后，表示没太看懂，然后又看例子…我的理解就是，看下diff的字母个数就好了。</p>
<p>就先给<code>s</code>串各个字母计个数，然后遍历<code>t</code>串时候相应的减去，最后将<code>计数个数&gt;0</code>的相加就可以了</p>
<p>用什么来存各个计数个数呢？因为说的都是小写字母，用个26的数组就可以了，这样空间复杂度降到o(1)了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">        mem = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            mem[ord(char)-ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">            mem[ord(char)-ord(<span class="string">'a'</span>)] -= <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> mem[i] &gt;<span class="number">0</span>:</span><br><span class="line">                cnt += mem[i]</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<h3 id="第三题：Medium"><a href="#第三题：Medium" class="headerlink" title="第三题：Medium"></a>第三题：Medium</h3><p>程序设计题目，理解题目并模拟就可以了，其实主要问题在于细节的优化。</p>
<p>一开始直接用的<code>o(nk)</code>n是一个用户的所有记录，k是k个时间间隔，也就是两层循环套起来用的…显然超时了。</p>
<p>简单的优化就是 二分查找，只需要确定startTime的起始下标就可以了。(实际是二分查找的变体：找最左满足条件的)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TweetCounts</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.tweetUser = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recordTweet</span><span class="params">(self, tweetName: str, time: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tweetName <span class="keyword">in</span> self.tweetUser:</span><br><span class="line">            self.tweetUser[tweetName].append(time)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tweetUser[tweetName] = [time]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTweetCountsPerFrequency</span><span class="params">(self, freq: str, tweetName: str, startTime: int, endTime: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> tweetName <span class="keyword">not</span> <span class="keyword">in</span> self.tweetUser:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> freq == <span class="string">'minute'</span>:</span><br><span class="line">            delt = <span class="number">60</span></span><br><span class="line">        <span class="keyword">elif</span> freq == <span class="string">'hour'</span>:</span><br><span class="line">            delt = <span class="number">60</span> * <span class="number">60</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delt = <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span></span><br><span class="line">        self.tweetUser[tweetName].sort()</span><br><span class="line">        result = []</span><br><span class="line">        index = self.bs(self.tweetUser[tweetName],startTime)</span><br><span class="line">        <span class="comment"># if index == -1:</span></span><br><span class="line">        <span class="comment">#     return [0]*((endTime+1-startTime)//delt + 1)</span></span><br><span class="line">        <span class="keyword">for</span> b_interval <span class="keyword">in</span> range(startTime,endTime+<span class="number">1</span>,delt):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            e_interval = min(endTime+<span class="number">1</span>,b_interval+delt)</span><br><span class="line">            <span class="keyword">while</span> index &lt; len(self.tweetUser[tweetName]) <span class="keyword">and</span> self.tweetUser[tweetName][index] &lt; endTime+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> b_interval &lt;= self.tweetUser[tweetName][index] &lt; e_interval:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> self.tweetUser[tweetName][index] &gt;= e_interval:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            result.append(cnt)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bs</span><span class="params">(self,nums,target)</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">if</span> right == len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &gt; target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">return</span> right  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your TweetCounts object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = TweetCounts()</span></span><br><span class="line"><span class="comment"># obj.recordTweet(tweetName,time)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度为<code>o(nlogn)</code>主要来自于排序部分，其他部分二分<code>logn</code>，计算时间复杂度的依然是<code>k*n</code>但是此时的n已经不是全局的数量了，已经给二分优化后的n已经大大减少。（我感觉并没有优化一个数量级那么夸张，但是已经很可观了）</p>
<p>后续看分享，有大神提出来二分的过程完全可以考虑使用<code>跳表</code>，给有序链表建立多级索引。</p>
<h3 id="第四题：Hard"><a href="#第四题：Hard" class="headerlink" title="第四题：Hard"></a>第四题：Hard</h3><p>参加考试的最大学生，看完题的感觉跟八皇后很像，所以直接考虑DFS进行。</p>
<p>根据题意，我们只需要DFS那个有效作为就可以， 并不用每个座位都遍历，最大的学生数的上限就是有效座位数。很可惜，辛辛苦苦搞出来，纯粹的DFS是超时的。</p>
<p>如果自己继续优化的话应该考虑剪枝问题，但是当时没有想到特别好的剪枝办法。</p>
<p>赛后看了大神们的分享，又学会了一个新的东西 <code>状态压缩DP</code> 或 <code>状态压缩DFS</code></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-725-分隔链表</title>
    <url>/2020/02/07/Leetcode/leetcode-725-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p>
<p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p>
<p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p>
<p>返回一个符合上述规则的链表的列表。</p>
<p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p>
<p>示例 1：</p>
<p>输入:<br>root = [1, 2, 3], k = 5<br>输出: [[1],[2],[3],[],[]]<br>解释:<br>输入输出各部分都应该是链表，而不是数组。<br>例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。<br>第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。<br>最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。<br>示例 2：</p>
<p>输入:<br>root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br>解释:<br>输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/split-linked-list-in-parts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-linked-list-in-parts</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>讲一下主要的几个点：</p>
<ul>
<li><p>如何判断每次应该分几个？</p>
<p>其实就是看<code>元素个数➗划分k</code>的商是多少，余数是多少。按照题意，前面的应该是多的，后面的是少的，我们只需要把余数分配到前面几个就好了。举个例子</p>
<blockquote>
<p>eg: divmod(10,4) 商2余2，什么意思呢，就是将是个元素，划分成4块，每块有2个元素，余下来的2个元素放到前面两块，这样就划分成：3，3，2，2</p>
</blockquote>
</li>
<li><p>若有空节点，有且仅有可能有一个 </p>
<p>什么时候才会出现空节点也需要放入呢？就是需要划分块数大于节点个数的时候：<code>k&gt;n</code></p>
<p>这样才会出现需要<code>None</code> 来占位，并且出现这种情况之后，每个节点有且仅可能有一个节点。</p>
<blockquote>
<p>eg: [1,2,3]  5</p>
<p>将3个节点切分成5份，divmod(3,5)  商0余3，这样划分结果就是</p>
<p>[[1],[2],[3],[],[]]</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span><span class="params">(self, root: ListNode, k: int)</span> -&gt; List[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]*k</span><br><span class="line">        </span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        quotient, remainder = divmod(cnt,k)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            num = quotient + (<span class="number">1</span> <span class="keyword">if</span> remainder!=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            remainder = <span class="number">0</span> <span class="keyword">if</span> remainder==<span class="number">0</span> <span class="keyword">else</span> (remainder<span class="number">-1</span>)</span><br><span class="line">            p = root</span><br><span class="line">            <span class="keyword">while</span> num &gt; <span class="number">1</span>: <span class="comment"># 不需要真的移动num个 因为还涉及链表的处理</span></span><br><span class="line">                <span class="keyword">if</span> p:</span><br><span class="line">                    p = p.next</span><br><span class="line">                num -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                tmp = p.next</span><br><span class="line">                p.next = <span class="literal">None</span></span><br><span class="line">            result.append(root)</span><br><span class="line">            root = tmp</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>这个地方用到了3次循环，且每次都需要额外的一个变量控制循环次数，这样不如直接用for循环，可以减少很多额外操作。</p>
<p><strong>官方题解</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> N <span class="keyword">in</span> xrange(<span class="number">1001</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">break</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        width, remainder = divmod(N, k)</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            head = cur</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(width + (i &lt; remainder) - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> cur: cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                cur.next, cur = <span class="literal">None</span>, cur.next</span><br><span class="line">            ans.append(head)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https://leetcode-cn.com/problems/split-linked-list-<span class="keyword">in</span>-parts/solution/fen-ge-lian-biao-by-leetcode<span class="number">-2</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-61-旋转链表</title>
    <url>/2020/02/07/Leetcode/leetcode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>示例 2:</p>
<p>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不同于旋转数组，旋转数组方便的地方在于数组，下标可以直接使用。链表的优点是在于插入删除。</p>
<p>所以一开始的基本想法是 每次把尾部的节点拿出来前插到头结点前面，这样就完成了一次题意要求的移动，但这样的问题是，时间复杂度为<code>o(kn)</code></p>
<p>因为每次都需要遍历到最后到尾节点</p>
<h3 id="最优思路"><a href="#最优思路" class="headerlink" title="最优思路"></a>最优思路</h3><p>链表的优点在于方便的连接，所以只需要将本身链表的尾部和首部相连接，然后再从<code>head</code>移动<code>n-k个节点</code>，将该节点之后的部分断掉，那么就形成了 相当于将尾部<code>k</code>个节点移动到前面的操作了，最后返回断开位置后的节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        p = head</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p.next!= <span class="literal">None</span>:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        p.next = head</span><br><span class="line">        k = k%n</span><br><span class="line">        cnt = n-k<span class="number">-1</span> <span class="comment"># 小细节</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        return_head = p.next</span><br><span class="line">        p.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> return_head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-189-旋转数组</title>
    <url>/2020/02/06/Leetcode/leetcode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为用python 解题嘛，上来最先考虑的就是python特性解决。</p>
<p>根据题意就是个循环移动过程，将尾部的元素拿出来放到头部</p>
<p>对应可用的list的方法就是<code>pop()</code>,<code>insert</code>()</p>
<blockquote>
<p><strong>insert</strong>(self, index, object, /)</p>
<p>  Insert object before index.</p>
<p><strong>pop</strong>(self, index=-1, /)</p>
<p>  Remove and return item at index (default last).</p>
<p>  Raises IndexError if list is empty or index is out of range.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">if</span> k == length <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            nums.insert(<span class="number">0</span>,nums.pop())</span><br><span class="line">            k-=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果深究时间复杂度的话，python底层实现中list的<code>insert()</code>时间复杂度是<code>o(N)</code> 而<code>pop()</code>时间复杂度是<code>o(1)</code>，并且调用<code>k</code>次，所以时间复杂度为<code>o(kn)</code></p>
<h3 id="正规解题姿势"><a href="#正规解题姿势" class="headerlink" title="正规解题姿势"></a>正规解题姿势</h3><p>可用通过多次旋转不同位置的元素来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k = k%n</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, k<span class="number">-1</span>)</span><br><span class="line">        self.reverse(nums, k, n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left],nums[right] = nums[right], nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总共调用了3次reverse，3次的时间复杂度分别为<code>o(n),o(k),o(n-k)</code></p>
<p>总的时间复杂度还是<code>o(n)</code>的</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-186-翻转字符串中的单词II</title>
    <url>/2020/02/05/Leetcode/leetcode-186-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DII/</url>
    <content><![CDATA[<h2 id="翻转字符串中的单词II"><a href="#翻转字符串中的单词II" class="headerlink" title="翻转字符串中的单词II"></a>翻转字符串中的单词II</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例：</p>
<p>输入: [“t”,”h”,”e”,” “,”s”,”k”,”y”,” “,”i”,”s”,” “,”b”,”l”,”u”,”e”]<br>输出: [“b”,”l”,”u”,”e”,” “,”i”,”s”,” “,”s”,”k”,”y”,” “,”t”,”h”,”e”]<br>注意：</p>
<p>单词的定义是不包含空格的一系列字符<br>输入字符串中不会包含前置或尾随的空格<br>单词与单词之间永远是以单个空格隔开的<br>进阶：使用 O(1) 额外空间复杂度的原地解法。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题目这么给输入输出，就是相当于给了你 <code>char array</code>，这样就可以通过o(1)的空间复杂度来实现。</p>
<p>原理同题目一</p>
<ul>
<li>先reverse整个数组</li>
<li>再逐个单词reverse</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(s,left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">                s[left],s[right] = s[right],s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = length<span class="number">-1</span></span><br><span class="line">        reverse(s,left,right)</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(right&lt;length):</span><br><span class="line">            <span class="keyword">if</span> s[right] == <span class="string">' '</span>:</span><br><span class="line">                reverse(s,left,right<span class="number">-1</span>)</span><br><span class="line">                left = right+<span class="number">1</span></span><br><span class="line">                right = right+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> right == length<span class="number">-1</span>: <span class="comment"># 这个地方需要注意下 这种形式给的字符串没有结尾符号需要自行判断</span></span><br><span class="line">                reverse(s,left,right)</span><br><span class="line">                right = right+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-151-翻转字符串中的单词</title>
    <url>/2020/02/05/Leetcode/leetcode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="翻转字符串中的单词"><a href="#翻转字符串中的单词" class="headerlink" title="翻转字符串中的单词"></a>翻转字符串中的单词</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：</p>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>说明：</p>
<p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照 剑指offer的解题思路 </p>
<ul>
<li>先翻转整个字符串</li>
<li>再逐个翻转单词</li>
</ul>
<p>主要的问题出现在，python解决过程出现的小坑</p>
<ul>
<li>python 中的string 是不可以进行修改的，所以做不到原地逆置</li>
<li>python可以用<code>split()</code>将单词分隔开，但是空白字符会之间变成 空<code>&#39;&#39;</code>，而不是<code>’ ‘</code></li>
</ul>
<blockquote>
<p>split(‘ ‘)和split()的切分是不一样的。</p>
<p>split(‘ ‘)会严格按照一个空格一个空格来切</p>
<p>split()会按照空白的来切掉</p>
<p>eg: “  hello   world    “</p>
<p>>&gt;&gt; a = ‘ hellow word  ‘</p>
<p>>&gt;&gt; a.split(‘ ‘)</p>
<p>[‘’, ‘hellow’, ‘’, ‘word’, ‘’, ‘’, ‘’]</p>
<p>>&gt;&gt; a.split()</p>
<p>[‘hellow’, ‘word’]</p>
</blockquote>
<p>题解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        s = self.reverse(s)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> s.split():</span><br><span class="line">            <span class="keyword">if</span> word != <span class="string">''</span>: <span class="comment"># 坑</span></span><br><span class="line">                result.append(self.reverse(word))</span><br><span class="line">        result = <span class="string">' '</span>.join(result)</span><br><span class="line">        <span class="keyword">return</span> result.strip()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self,s)</span>:</span></span><br><span class="line">        list_s = list(s) <span class="comment"># 坑</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(list_s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">            list_s[left],list_s[right] = list_s[right],list_s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(list_s)</span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>如果充分利用python 特性来解决：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  	<span class="function"><span class="keyword">def</span> <span class="title">reverseWords1</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(s.split()[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p>首先将字符串按照<code>&#39; &#39;</code>切分，然后得到一个list的切分结果，再将切分的结果逆置，达到了只需要把单词位置颠倒，就完成了。</p>
<ul>
<li><code>[::-1]</code>是将list内容进行逆置的操作</li>
<li>这个方法不用管空白字符的原因是 <code>split()</code>会以任何空白进行切割，可以参考上面对split的举例。</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-388-文件最长绝对路径</title>
    <url>/2020/02/02/Leetcode/leetcode-388-%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="文件的最长绝对路径"><a href="#文件的最长绝对路径" class="headerlink" title="文件的最长绝对路径"></a>文件的最长绝对路径</h2><p>假设我们以下述方式将我们的文件系统抽象成一个字符串:</p>
<p>字符串 “dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext” 表示:</p>
<blockquote>
<p>dir<br> subdir1<br> subdir2<br>     file.ext</p>
<p>目录 dir 包含一个空的子目录 subdir1 和一个包含一个文件 file.ext 的子目录 subdir2 。</p>
</blockquote>
<p>字符串 “dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext” 表示:</p>
<blockquote>
<p>dir<br>    subdir1<br>        file1.ext<br>        subsubdir1<br>    subdir2<br>        subsubdir2<br>            file2.ext<br>目录 dir 包含两个子目录 subdir1 和 subdir2。 subdir1 包含一个文件 file1.ext 和一个空的二级子目录 subsubdir1。subdir2 包含一个二级子目录 subsubdir2 ，其中包含一个文件 file2.ext。</p>
</blockquote>
<p>我们致力于寻找我们文件系统中文件的最长 (按字符的数量统计) 绝对路径。例如，在上述的第二个例子中，最长路径为 “dir/subdir2/subsubdir2/file2.ext”，其长度为 32 (不包含双引号)。</p>
<p>给定一个以上述格式表示文件系统的字符串，返回文件系统中文件的最长绝对路径的长度。 如果系统中没有文件，返回 0。</p>
<p>说明:</p>
<ul>
<li>文件名至少存在一个 . 和一个扩展名。</li>
<li>目录或者子目录的名字不能包含 .。</li>
<li>要求时间复杂度为 O(n) ，其中 n 是输入字符串的大小。</li>
</ul>
<p>请注意，如果存在路径 aaaaaaaaaaaaaaaaaaaaa/sth.png 的话，那么  a/aa/aaa/file1.txt 就不是一个最长的路径。</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>抓住一个细节问题：只有文件名是带有.（点）的，如果不包含文件名则不应计算最大长度</p>
<p>这个问题的另一个特点就是<code>\t</code>，其实代表了<strong>目录深度</strong>。</p>
<p>当我们找到一个带<code>.</code>的文件时候，我们就<strong>计算其长度</strong>，并与最大长度比较，保留最长的数。</p>
<p>如何计算一次完整路径的长度呢？</p>
<p>只需要让当前文件的文件名字长度+其目录文件的长度</p>
<p>举例：</p>
<blockquote>
<p>dir<br>    subdir1<br>        file1.ext<br>        subsubdir1<br>    subdir2<br>        subsubdir2<br>            file2.ext</p>
</blockquote>
<p>定义一个dict来存储长度，初始化{0:0}</p>
<p>当处理’dir’时，其<code>\t</code>个数为0，则depth=0，则下一层文件的基础部分就有了<code>dir/</code>,所以</p>
<p><code>dict[depth+1] = len(&#39;dir&#39;)+dict[depth]+1</code></p>
<p>dict变为{0:0,1:4}</p>
<p>同理，当处理过subdir1后，dict变为{0:0,1:4,2:12}，12来自<code>dir/subdir1/</code></p>
<p>同理，当处理到<code>file1.ext</code>，需要更新一次最大长度，<code>max= &#39;dir/subdir1/file1.ext&#39; = 12+9=21</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthLongestPath</span><span class="params">(self, input: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">not</span> <span class="keyword">in</span> input:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        depth_dict = &#123;<span class="number">0</span>:<span class="number">0</span>&#125; <span class="comment"># key:depth  value:length</span></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> input.split(<span class="string">'\n'</span>):</span><br><span class="line">            <span class="comment"># 每行</span></span><br><span class="line">            depth = line.count(<span class="string">'\t'</span>)</span><br><span class="line">            name = line.strip(<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> name:</span><br><span class="line">                max_len = max(max_len, len(name)+depth_dict[depth])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 下一级目录长度 = 目录名+之前的目录+分隔符号 ”/“</span></span><br><span class="line">                depth_dict[depth+<span class="number">1</span>] = len(name) + depth_dict[depth] + <span class="number">1</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h3><p>利用栈来实现。</p>
<p>栈深度代表了文件目录的深度，压栈的内容是目录的名字，当遍历到带有拓展名的文件时，只需要将栈内的内容按<code>/</code>链接起来就是绝对路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthLongestPath</span><span class="params">(self, input: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">not</span> <span class="keyword">in</span> input:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> input.split(<span class="string">'\n'</span>):</span><br><span class="line">            depth = line.count(<span class="string">'\t'</span>)+<span class="number">1</span>  <span class="comment"># 小细节，同等递归深度目录，应该出栈</span></span><br><span class="line">            name = line.strip(<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> len(stack) &gt;= depth:</span><br><span class="line">                stack.pop()</span><br><span class="line">            stack.append(name)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> name:</span><br><span class="line">                max_len = max(max_len,len(<span class="string">'/'</span>.join(stack)))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-681-最近时刻</title>
    <url>/2020/02/02/Leetcode/leetcode-681-%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="最近时刻"><a href="#最近时刻" class="headerlink" title="最近时刻"></a>最近时刻</h2><p>给定一个形如 “HH:MM” 表示的时刻，利用当前出现过的数字构造下一个距离当前时间最近的时刻。每个出现数字都可以被无限次使用。</p>
<p>你可以认为给定的字符串一定是合法的。例如，“01:34” 和 “12:09” 是合法的，“1:34” 和 “12:9” 是不合法的。</p>
<p>样例 1:</p>
<p>输入: “19:34”<br>输出: “19:39”<br>解释: 利用数字 1, 9, 3, 4 构造出来的最近时刻是 19:39，是 5 分钟之后。结果不是 19:33 因为这个时刻是 23 小时 59 分钟之后。</p>
<p>样例 2:</p>
<p>输入: “23:59”<br>输出: “22:22”<br>解释: 利用数字 2, 3, 5, 9 构造出来的最近时刻是 22:22。 答案一定是第二天的某一时刻，所以选择可构造的最小时刻。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归思路：就是枚举四个数字出现在每一个位置时候的情况，四个位置，4个数字，最差遍历就是 4！<br>剪枝策略：对于小时位置不满足[0,24)，对于分钟位置不满足[0,60)</p>
<p>!!!注意一个问题：对于’00:00’ ‘11:11’的处理。<br>原有逻辑遇到 其本身会直接return 返回空结果，这样导致上面出现的case不能很好的覆盖<br>我们可以先将其赋值到<code>self.result</code>上，如果最后没有找到最小的时间，那么说明出现了上面这样的情况（全是重复数字）<br>最后直接返回<code>self.result</code></p>
<p> 如何计算时间差？ 可参考官方题解给的计算方法<br>（minutes_new_time - minutes_origin_time） % (24*60)<br>举例：12:01对应  12*60+1 = 720<br>那么‘11:02’时间对应  11*60+2 = 662<br>（662-720） % 1440 = -58 % 1440 = 1382 是一个很大的值<br>主要就是这个思想来判断新生成的时间是否是距离最近的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = <span class="string">''</span></span><br><span class="line">        self.min_time = <span class="number">1440</span></span><br><span class="line">        self.time = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextClosestTime</span><span class="params">(self, time: str)</span> -&gt; str:</span></span><br><span class="line">        self.result = time  <span class="comment"># 直接赋值到结果上 </span></span><br><span class="line">        self.time = int(time[:<span class="number">2</span>])*<span class="number">60</span>+int(time[<span class="number">3</span>:])</span><br><span class="line">        digit = time[:<span class="number">2</span>]+time[<span class="number">3</span>:]</span><br><span class="line">        stack = <span class="string">''</span></span><br><span class="line">        self.backtrace(<span class="number">0</span>,stack,digit)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dfs+剪枝</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self,depth,stack,digit)</span>:</span></span><br><span class="line">        <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> depth == <span class="number">2</span> <span class="keyword">and</span> int(stack[:<span class="number">2</span>])&gt;=<span class="number">24</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> depth == <span class="number">4</span> <span class="keyword">and</span> int(stack[<span class="number">2</span>:])&gt;=<span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> depth == <span class="number">4</span>:</span><br><span class="line">            tmp_time = self.cal_time(stack)</span><br><span class="line">            <span class="keyword">if</span> tmp_time == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> tmp_time &lt; self.min_time: <span class="comment"># 如果出现更小的时间，更新最小时间差以及结果</span></span><br><span class="line">                self.min_time = tmp_time</span><br><span class="line">                self.result = stack[:<span class="number">2</span>]+<span class="string">':'</span>+stack[<span class="number">2</span>:]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(digit)):</span><br><span class="line">            </span><br><span class="line">                stack += digit[i]</span><br><span class="line">                self.backtrace(depth+<span class="number">1</span>,stack,digit)</span><br><span class="line">                stack = stack[:<span class="number">-1</span>]</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal_time</span><span class="params">(self,new_time)</span>:</span></span><br><span class="line">        hour = int(new_time[:<span class="number">2</span>])</span><br><span class="line">        minutes = int(new_time[<span class="number">2</span>:])</span><br><span class="line">        time = hour*<span class="number">60</span>+minutes</span><br><span class="line">        <span class="keyword">return</span> (time-self.time)%(<span class="number">24</span>*<span class="number">60</span>)   <span class="comment">#  小trick  -1 % 100 的结果是 99</span></span><br></pre></td></tr></table></figure>
<p>更多Leetcode题解以及面试经验：<a href="https://mereder.github.io/archives/" target="_blank" rel="noopener">Mereder博客</a></p>
<p><a href="https://drive.google.com/file/d/1PXQAvlTAzV4cdAGwit_52aKVrK4IShPw/view?usp=sharing" target="_blank" rel="noopener">https://drive.google.com/file/d/1PXQAvlTAzV4cdAGwit_52aKVrK4IShPw/view?usp=sharing</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-8-字符串转换整数(atoi)</title>
    <url>/2020/02/02/Leetcode/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0(atoi)/</url>
    <content><![CDATA[<blockquote>
<p>复习要点：</p>
<p>处理的前后顺序很关键，先处理空白字符，再处理“+-” ,而且”+-“只能出现一次，所以放在 循环外。</p>
<p>python 自身的好处 是不存在数据越界的问题。java 的话最好分配long</p>
</blockquote>
<h2 id="字符串转换整数"><a href="#字符串转换整数" class="headerlink" title="字符串转换整数"></a>字符串转换整数</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:</p>
<p>输入: “42”<br>输出: 42<br>示例 2:</p>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p>
<p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p>
<p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实题目已经将思路告知了，只需要按照要求实现即可。</p>
<ul>
<li>首先要处理None，否则后边无法调用len()</li>
<li>其次处理字符串中的空白字符，这些可以直接跳过</li>
<li>然后识别是否有“+“，”-“</li>
<li>最后一起处理字母和数字</li>
</ul>
<p>整道题的处理逻辑很清楚，就是用一个全局的下标，来逐个处理字符，符合就留下，不符合就丢弃</p>
<p>此处应注意与java等语言的不同，python默认定义的数据int是64位的，而java普通int是32位的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        max_value = <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">        min_value = <span class="number">-2</span>**<span class="number">31</span></span><br><span class="line">        index = <span class="number">0</span> <span class="comment">#  全局使用</span></span><br><span class="line">        symbol = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(str) <span class="keyword">and</span> str[index] == <span class="string">' '</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index &lt; len(str):</span><br><span class="line">            <span class="keyword">if</span> str[index] == <span class="string">'+'</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> str[index] == <span class="string">'-'</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                symbol = <span class="literal">False</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index,len(str)):</span><br><span class="line">                <span class="keyword">if</span> str[i] &gt;= <span class="string">'0'</span> <span class="keyword">and</span> str[i] &lt;= <span class="string">'9'</span>:</span><br><span class="line">                    result = result*<span class="number">10</span>+int(str[i])   <span class="comment"># 如果更保险，这个位置可以加入一个&gt;max的判断</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> symbol:</span><br><span class="line">                result = -result</span><br><span class="line">            <span class="keyword">if</span> result &lt; min_value: <span class="keyword">return</span> min_value</span><br><span class="line">            <span class="keyword">if</span> result &gt; max_value: <span class="keyword">return</span> max_value</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-7-整数翻转</title>
    <url>/2020/02/02/Leetcode/leetcode-7-%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="整数翻转"><a href="#整数翻转" class="headerlink" title="整数翻转"></a>整数翻转</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:</p>
<p>输入: 123<br>输出: 321<br> 示例 2:</p>
<p>输入: -123<br>输出: -321<br>示例 3:</p>
<p>输入: 120<br>输出: 21<br>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路很简单：对原始值不断按10取余，然后将取出来的余数*10加到新的结果上。</p>
<p><strong>重点是</strong>：对于结果的处理，题目按时很明显，32位，最大的32位数字是多少呢？ 是<strong>2^31-1</strong>.</p>
<p>如果结果超过最大的值，我们需要进行判断。越界就返回0，否则返回翻转的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        max_value = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">        min_value = <span class="number">-2</span>**<span class="number">31</span></span><br><span class="line">        x1 = abs(x)</span><br><span class="line">        <span class="keyword">while</span> x1 != <span class="number">0</span>:</span><br><span class="line">            result = result*<span class="number">10</span> + x1%<span class="number">10</span></span><br><span class="line">            x1 = x1//<span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> result &gt; max_value <span class="keyword">or</span> result &lt; min_value :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -result</span><br></pre></td></tr></table></figure>
<h3 id="知识拓展：负数取余"><a href="#知识拓展：负数取余" class="headerlink" title="知识拓展：负数取余"></a>知识拓展：负数取余</h3><p>关于python 取余的结果与   （C++和java）取余结果的不同。</p>
<p>对于自然数来说，没有什么问题，但是对于负数而言，运算机制是不同的。</p>
<blockquote>
<p>c++：cout &lt;&lt; (-7) % 3; // 输出 <strong>-1</strong></p>
<p>java：System.out.println((-7) % 3); // 输出 <strong>-1</strong></p>
<p>python：>&gt;&gt; (-7) % 3 // 输出 <strong>2</strong></p>
</blockquote>
<p>同号整数运算，所有语言都遵循<strong>尽量让商小</strong>的原则，因此7mod3结果为1没有异议。</p>
<p>在异号的整数运算中，C++和Java会让商<strong>尽可能大</strong>（比如-7mod3中，d=-2,r=-1）。</p>
<p>Python等则让商<strong>尽可能小</strong>（比如-7mod3中，d=-3，r=2）。</p>
<p>回到本题除10取余的过程，如果x=-123</p>
<p>c++和java</p>
<blockquote>
<p>-123 %10  商-12 余-3</p>
</blockquote>
<p>python</p>
<blockquote>
<p>-123%10 商-13 余 +7</p>
</blockquote>
<p>如果c++和java的话，可以直接处理，之后的结果仍然是负数，且颠倒过。</p>
<p>而python 就会出问题</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Learning to Rank</title>
    <url>/2020/01/15/L2R:learning%20to%20rank/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>VScode跳板机连接服务器</title>
    <url>/2020/01/15/VScode%E8%B7%B3%E6%9D%BF%E6%9C%BA%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/witnessai1/article/details/89217498" target="_blank" rel="noopener">https://blog.csdn.net/witnessai1/article/details/89217498</a></p>
]]></content>
  </entry>
  <entry>
    <title>Tensorflow-GPU 环境配置问题</title>
    <url>/2020/01/15/Tensorflow%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="版本兼容问题"><a href="#版本兼容问题" class="headerlink" title="版本兼容问题"></a>版本兼容问题</h2><p>大部分的gpu版本TensorFlow不work大概率都是因为版本不匹配导致的</p>
<p>重点就是环境匹配的问题</p>
<p>当前亲测最好用的就是python3.6+tf1.12-gpu 此外就是CUDA和cudnn的问题了</p>
<p>服务器上多人操作的话 最好还是使用conda创建自己的虚拟环境然后再自己的虚拟环境里面搞</p>
<h3 id="首先确认显卡驱动与CUDA以及CUDA与cudnn版本的问题"><a href="#首先确认显卡驱动与CUDA以及CUDA与cudnn版本的问题" class="headerlink" title="首先确认显卡驱动与CUDA以及CUDA与cudnn版本的问题"></a>首先确认显卡驱动与CUDA以及CUDA与cudnn版本的问题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p>上方有个<code>NVIDIA-SMI：384.81</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 再一次确认CUDA版本</span></span><br><span class="line">cat /usr/local/cuda/version.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 和cudnn版本问题</span></span><br><span class="line">cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure>
<p>先确认CUDA版本与显卡驱动之间的版本对应好，然后再确认CUDA和cudnn版本之间的问题，自己配置几次的感受就是，显卡驱动和CUDA一般都是固定好的，最好不要动否则会影响服务器上其他用户，但是cudnn是可以更新的，这个向下兼容的。偏硬件的东西都设置好之后，再按照TensorFlow-GPU</p>
<h3 id="cuDNN版本问题"><a href="#cuDNN版本问题" class="headerlink" title="cuDNN版本问题"></a>cuDNN版本问题</h3><p>关于更新cudnn，完全可以按照<a href="https://docs.nvidia.com/deeplearning/sdk/cudnn-install/" target="_blank" rel="noopener">官方教程来搞</a>，重点是最好备份下原有的cudnn文件，万一导致更新后别人的也不可以用了，就惨了。</p>
<h3 id="conda-创建虚拟环境以及问题"><a href="#conda-创建虚拟环境以及问题" class="headerlink" title="conda 创建虚拟环境以及问题"></a>conda 创建虚拟环境以及问题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n env_name python==3.6</span><br></pre></td></tr></table></figure>
<p>其实可以直接 <code>conda install tensorflow-gpu=1.12</code></p>
<p>注意conda进行包管理的问题就是，conda会直接安装所有可能依赖的包，可能有的包是你不需要的 这无所谓，但是有时候会给你安装错误版本的依赖包，导致出问题。这样的话只能后期再修改包</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Vim 日常使用</title>
    <url>/2020/01/08/vim%20%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>优化方法总结（先挖个坑，最近任务是刷题 之后补一下）</title>
    <url>/2020/01/07/ML/%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/yinyu19950811/article/details/90476956" target="_blank" rel="noopener">https://blog.csdn.net/yinyu19950811/article/details/90476956</a></p>
<p><a href="https://mp.weixin.qq.com/s/DIQFCQBpfixDqueKIFzlEw" target="_blank" rel="noopener">小小挖掘机</a></p>
<h2 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h2><p>随机梯度下降算法</p>
]]></content>
  </entry>
  <entry>
    <title>Bloom Filter(布隆过滤器)</title>
    <url>/2020/01/06/bloom%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank" rel="noopener">https://blog.csdn.net/jiaomeng/article/details/1495500</a></p>
]]></content>
  </entry>
  <entry>
    <title>numpy 相关</title>
    <url>/2020/01/06/Numpy%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="Numpy-相关"><a href="#Numpy-相关" class="headerlink" title="Numpy 相关"></a>Numpy 相关</h2><h3 id="np-vstack-和np-dstack"><a href="#np-vstack-和np-dstack" class="headerlink" title="np.vstack 和np.dstack"></a>np.vstack 和np.dstack</h3><p>vstack是对其低纬，将高纬进行合并</p>
<p>dstack是对其高纬，将低纬进行合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = np.ones((64,30,2))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = np.zeros((64,30,3))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c = np.dstack((a,b))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c.shape</span></span><br><span class="line">(64, 30, 5)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = np.ones((10,30))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = np.zeros((20,30))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c = np.vstack((a,b))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c.shape</span></span><br><span class="line">(30, 30)</span><br></pre></td></tr></table></figure>
<h3 id="np-where"><a href="#np-where" class="headerlink" title="np.where"></a>np.where</h3><p>基本用法就是用来将数组内满足条件的值进行替换，比如将数组中<code>&gt;=1</code>的数置为1，其他置为0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.where(a&gt;=<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，np.where并不会修改原数组</strong></p>
<ul>
<li>求职意向：暑期实习生需要写的稍微具体点嘛   比如我写  算法实习生（研发实习生、产品实习生）   娇娇可以写   xx暑期实习生</li>
<li>邮箱留学校的？</li>
<li>大数据+机器学习选股  这个 如果很清楚并且可以讲出来可以写， 不太清楚的话 容易被问到盲区 </li>
<li>每个项目可以写个项目的大致情况， 娇娇宝宝都写了自己做了哪些工作，但是感觉每一条中间没有什么连贯性。是同属于一个项目下的 还是 你在职期间所有的工作？</li>
<li>本科如果 gpa 比较高 可以贴一下的 然后金融双学位有的课程记得比较清楚也可以写 （0.0 我猜娇娇宝宝都忘记了）</li>
<li>其他应该就是顺序问题吧，我不太清楚你们的实习， 他们更在意什么？ 比如 学校  还是你的技能 还是 实习经历 娇娇动态调整下 </li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-124-二叉树中的最大路径和</title>
    <url>/2020/01/05/Leetcode/leetcode-124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]</p>
<pre><code>   1
  / \
 2   3
</code></pre><p>输出: 6<br>示例 2:</p>
<blockquote>
<p>输入: [-10,9,20,null,null,15,7]</p>
<p>  -10<br>   / \<br>  9  20<br>      /  \<br>   15   7</p>
<p>输出: 42</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = float(<span class="string">'-inf'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 不要被奇怪的遍历吓到  只要求返回最大值，并不要求返回最大路径</span></span><br><span class="line">        tmp = self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        left = max(self.helper(root.left),<span class="number">0</span>)</span><br><span class="line">        right = max(self.helper(root.right),<span class="number">0</span>)</span><br><span class="line">        self.result = max(root.val+left+right,self.result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val+max(left,right)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>外企冲冲冲</title>
    <url>/2020/01/05/%E5%88%B7%E9%A2%98%E6%8C%89%E5%85%AC%E5%8F%B8%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>那么面试过程中，如何表现呢？**</p>
<p><strong>1. 听题+记录</strong></p>
<p><strong>2. 复述+追问</strong></p>
<p><strong>3. 设计输入输出</strong></p>
<p><strong>4. 思路解释，向面试官求证</strong></p>
<p><strong>5. 复杂度分析</strong></p>
<p><strong>6. 设计边界条件</strong></p>
<p><strong>7. 编码</strong></p>
<p><strong>8. 运行测试用例</strong></p>
<p><strong>9. 期待 follow up</strong></p>
<p><strong>1. 听题+记录</strong></p>
<p>面试官在描述题目的时候，会描述一个场景。我们在听题的时候，要把题目抽象转化为若干项 RI（Requirement Item），并记录在小本本上。</p>
<p><strong>2. 复述+追问</strong></p>
<p>拿到题目后，很多情况下，我们的理解和面试官的表达是有出入的。可能是面试官忘说了某句，我们漏听了，甚至是面试官为了考验我们故意隐瞒了其中条件。应试者需要自己去挖掘这所有的隐藏 RI，把题目搞清楚。还要强调的是，有两个特殊的 RI：时间复杂度+空间复杂度。</p>
<p><strong>3. 设计输入输出，思路解释，向面试官求证</strong></p>
<p>截止目前，假如我们已经成功地搞懂了题目，那么我们的小本本上会有好多需求项目。接下来，就需要我们把这些文科生也能听懂的话，抽象成一个函数。具体而言，是抽象成一个函数的输入+输入+好听的函数名称。</p>
<p><strong>4. 思路解释，向面试官求证</strong></p>
<p>在我看来，这是比编码更重要的步骤。简单来说，这步主要是在向面试官描述你的想法、思考过程。</p>
<p>“既然输入是一个已排序的列表，那么我可以尝试运用二分查找的思想”。</p>
<p>“我发现在贪心求值的过程中，有重复计算的情况，那是不是可以利用空间换时间，利用 dp 的思想，把之前运算的结果记录下来”。</p>
<p>“我首先做了一次排序，之后两个嵌套循环，最终时间复杂度是 O(N^2)，其中 N 是输入元素的个数”。</p>
<p><strong>5. 复杂度分析</strong></p>
<p>之前在思路解释的时候，已经分析过时间、空间复杂度了。在此处再次分析，主要做的是在写好的代码中，标注出各个函数的复杂度、循环嵌套情况。</p>
<p><strong>6. 设计边界条件</strong></p>
<p>最没技术含量的一个考察点。</p>
<p>给定的输入，在极端情况下，程序该怎么办？</p>
<p>输入是 int，如果是 Integer.max 怎么办？</p>
<p>输入是 String，如果是 null or 空白怎么办？</p>
<p>输入是数组………</p>
<p><strong>7. 编码</strong></p>
<p>硬实力，请去刷题。</p>
<p><strong>8. 运行测试用例</strong></p>
<p>在编码完成之后，主动跑一些 case，检验程序的正确，设计 case 也是考察的点。</p>
<p><strong>9. 算法分析</strong></p>
<p>分析整个代码，当前代码有哪些不好？结合使用的语言哪些可以优化？如果把输入改成更一般的情况，程序应该如何调整？</p>
<p><strong>10. 思路讲解</strong></p>
<p>把思考过程清楚明白地表达出来。</p>
<p><strong>总结而言，面试是一个展示自己作为合作者的过程。除了算法本身，如何沟通，把题目弄清楚，完成面试官对你的各方面预期是极其重要的。</strong></p>
<h3 id="按公司分类-按频繁程度由高到低"><a href="#按公司分类-按频繁程度由高到低" class="headerlink" title="按公司分类(按频繁程度由高到低)"></a>按公司分类(按频繁程度由高到低)</h3><h4 id="Airbnb"><a href="#Airbnb" class="headerlink" title="Airbnb"></a>Airbnb</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">336    755    251    269    751    68    787    773    341    39    1    324    291    759    42    212    588    756    829    1058    2    10    299    76    322    219    198    843    5    252    125    220    14    7    410    385    657    41    295    20    273    17    8    9    815    347    127    175    4    147    6    15    236    11    190    202    136    3    21    224    108    160    215    23    16    221    622    246    107    211    217    37    176    138    12    38    300    75    88    18    73    49    227    415    1017    1041</span><br></pre></td></tr></table></figure>
<h4 id="Hulu"><a href="#Hulu" class="headerlink" title="Hulu"></a>Hulu</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">383    909    148    143    146    200    54    863    21    127    341    1    371    322    238    326    239    121    49    3    4    53    26    440    772    814    1063</span><br></pre></td></tr></table></figure>
<h4 id="Microsoft"><a href="#Microsoft" class="headerlink" title="Microsoft"></a>Microsoft</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">138    151    1    146    165    103    348    402    445    88    253    186    54    200    2    722    285    297    794    273    4    75    48    5    23    53    564    42    8    98    428    21    206    636    545    10    706    79    443    121    22    36    450    287    322    33    20    295    25    141    236    72    240    224    24    13    116    17    218    43    417    419    347    85    560    568    529    229    102    269    31    692    168    380    344    557    15    449    114    333    94    160    117    642    935    239    3    652    105    44    143    232    173    277    56    917    133    71    958    679    362    76    59    836    12    234    51    84    123    208    300    49    407    235    805    708    227    316    772    93    612    493    39    415    729    73    41    638    155    162    490    242    28    92    171    426    204    212    64    91    97    535    172    394    215    110    174    283    210    238    19    237    669    460    214    199    1026    887    647    46    37    230    128    148    286    759    45    528    655    61    698    74    503    68    688    662    314    140    134    658    109    694    7    397    863    632    99    40    57    55    81    139    150    969    30    862    304    149    289    78    354    38    124    153    266    328    523    280    317    346    26    70    284    516    216    122    125    383    11    611    442    63    108    572    695    142    32    225    939    373    378    223    543    189    161    724    69    106    621    86    29    270    416    412    979    671    209    515    622    787    430    459    77    541    83    509    220    767    147    739    167    707    876    791    796    18    448    518    107    406    784    191    384    203    329    211    819    905    126    451    60    912    65    95    16    733    332    101    127    367    547    67    341    118    129    701    112    973    371    120    290    665    231    50    977    169    704    90    257    387    9    198    852    176    929    14    111    349    152    350    217    27</span><br></pre></td></tr></table></figure>
<h4 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h4><blockquote>
<p>—904—    929    1    681    482    159    399    975    843    844    857    947    683    410    489    222    753    777    939    308    158    803    833    642    253    299    736    900    809    248    524    734    135    679    911    727    731    527    359    200    837    943    818    2    56    4    849    247    913    1057    457    562    528    750    205    329    846    850    465    42    157    685    418    475    394    774    544    1096    163    855    353    380    315    686    246    766    920    767    57    737    317    659    340    640    963    68    684    3    146    271    729    1066    354    616    288    723    694    715    951    269    799    776    853    743    363    15    1055    428    85    388    770    403    471    124    702    444    34    1007    208    334    549    393    218    552    1087    708    138    23    788    351    215    497    347    127    126    375    361    304    710    128    224    498    187    31    398    5    981    636    76    139    155    297    936    285    332    425    722    800    280    771    221    378    43    346    150    941    1011    241    284    845    66    310    543    133    305    835    772    54    973    792    695    210    493    261    392    660    212    10    360    295    370    852    365    281    486    591    239    739    761    518    38    53    406    296    379    815    386    871    688    751    773    250    742    17    724    140    407    1032    672    72    488    41    635    499    417    166    460    836    55    568    298    765    464    505    20    926    692    433    940    149    316    22    381    48    817    369    266    341    979    109    302    490    621    935    152    213    211    37    458    730    745    987    185    175    277    137    424    11    827    228    484    358    63    572    759    242    121    195    165    21    97    535    300    62    366    110    98    529    117    162    551    834    45    438    132    238    1036    769    348    307    282    130    668    889    44    287    19    416    91    206    324    768    760    322    50    977    249    480    785    350    662    273    207    459    229    7    752    320    312    84    69    333    839    894    105    283    609    914    101    400    630    294    33    279    87    732    198    79    116    26    877    141    64    1048    1047    463    385    564    232    450    240    1091    373    1110    840    859    265    510    540    161    226    801    148    676    49    188    344    167    343    714    278    395    968    890    741    65    171    374    733    243    622    698    787    74    404    274    301    259    881    794    18    118    1024    46    156    632    99    336    6    802    426    992    70    120    35    236    268    368    81    104    8    36    504    415    647    318    30    980    997    28    289    830    542    16    387    560    252    92    103    382    144    414    154    583    173    193    807    14    496    872    451    468    942    811    309    337    325    448    442    362    108    168    32    419    203    94    933    100    230    134    690    566    176    129    701    931    202    713    821    965    286    227    476    201    345    721    270    986    153    412    231    559    994    125    503    841    83    52    917    863    938    328    75    160    707    703    234    113    747    24    169    449    114    191    13    674    384    595    142    264    567    178    905    122    235    204    389    71    60    581    29    9    59    12    51    367    177    443    131    237    136    680    106    143    371    290    665    39    209    190    82    219    804    557    77    78    704    123    700    326    119    96    1021    102    27    73    40    832    199    151    819    349    67    509</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-200-海岛数量</title>
    <url>/2020/01/05/Leetcode/leetcode-200-%E6%B5%B7%E5%B2%9B%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h2 id="海岛数量"><a href="#海岛数量" class="headerlink" title="海岛数量"></a>海岛数量</h2><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<blockquote>
<p> 输入:<br>11110<br>11010<br>11000<br>00000</p>
<p>输出: 1</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入:<br>11000<br>11000<br>00100<br>00011</p>
<p>输出: 3</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是找<code>连通区域</code>嘛，简单的dfs就可以解决，通过对<code>连着的海岛（1）</code>进行dfs，同时将<code>1</code>变为<code>0</code>。</p>
<p>每进入一次dfs计数1次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    self.helper(grid,i,j,m,n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, grid, i, j, m, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;<span class="number">0</span> <span class="keyword">or</span> j &lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=m <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> grid[i][j] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="string">'0'</span></span><br><span class="line">        self.helper(grid, i+<span class="number">1</span>, j, m, n)</span><br><span class="line">        self.helper(grid, i<span class="number">-1</span>, j, m, n)</span><br><span class="line">        self.helper(grid, i, j+<span class="number">1</span>, m, n)</span><br><span class="line">        self.helper(grid, i, j<span class="number">-1</span>, m, n)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-130-被围绕的区域</title>
    <url>/2020/01/05/Leetcode/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<p>X X X X<br>X O O X<br>X X O X<br>X O X X<br>运行你的函数后，矩阵变为：</p>
<p>X X X X<br>X X X X<br>X X X X<br>X O X X<br>解释:</p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>马上能想到用dfs，通过遍历将O置为X，但是这样不满足题目的限制条件，即只有X包围的O才可以。</p>
<p>问题主要出现在边界上，即如果边界上如果有一个O跟其他所有O相连，那么所有O都不用置为X。</p>
<p>既然问题在边界，我们就先解决边界问题。</p>
<blockquote>
<p>我们可以先通过dfs来确定哪些O是不可以被置为X的，然后将他们标记出来</p>
<p>再去一次遍历解决那些可以被置为X的O</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        nrow = len(board)</span><br><span class="line">        ncol = len(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从边界开始进行dfs 确保找到所有不能填充的O，并且置换为另一个字符</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(nrow):</span><br><span class="line">            self.helper(board,row,<span class="number">0</span>, nrow, ncol)</span><br><span class="line">            self.helper(board,row,ncol<span class="number">-1</span>, nrow, ncol)</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">1</span>,ncol):</span><br><span class="line">            self.helper(board, <span class="number">0</span>, col, nrow, ncol)</span><br><span class="line">            self.helper(board, nrow<span class="number">-1</span>, col, nrow, ncol)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再从上到下遍历全部，将所有O置为X，其他置为G</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(nrow):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(ncol):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">'G'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, board, row, col, nrow, ncol)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row&lt;<span class="number">0</span> <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt;= nrow <span class="keyword">or</span> col &gt;= ncol <span class="keyword">or</span> board[row][col] != <span class="string">'O'</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        board[row][col] = <span class="string">'G'</span></span><br><span class="line">        self.helper(board, row<span class="number">-1</span>, col, nrow, ncol)</span><br><span class="line">        self.helper(board, row+<span class="number">1</span>, col, nrow, ncol)</span><br><span class="line">        self.helper(board, row, col<span class="number">-1</span>, nrow, ncol)</span><br><span class="line">        self.helper(board, row, col+<span class="number">1</span>, nrow, ncol)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-377-组合总和IV</title>
    <url>/2020/01/04/Leetcode/leetcode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV/</url>
    <content><![CDATA[<h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h2><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<p>nums = [1, 2, 3]<br>target = 4</p>
<p>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)</p>
<p>请注意，顺序不同的序列被视作不同的组合。</p>
<p>因此输出为 7。<br>进阶：<br>如果给定的数组中含有负数会怎么样？<br>问题会产生什么变化？<br>我们需要在题目中添加什么限制来允许负数的出现？</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>连续刷了一个回溯+剪枝的题目，这个拿过来就写了出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> target &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.helper(nums,target)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            cnt += self.helper(nums,target-nums[index])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p><strong>通不过呀 超时了</strong></p>
<p>原因很简单，如果画出递归树，很明显的能看到有许多重复计算的地方。那么如何避免重复计算呢？</p>
<p><strong>使用动态规划呗</strong></p>
<p>动态规划里有一个很重要的模块就是 <strong>备忘录</strong>，意思就是如果再次涉及到这个计算的时候，我不用再重复计算算，直接查找备忘录就可以得到对应的值，一般返回结果也是直接从备忘录里面找。</p>
<p>涉及两个问题，动态规划的状态是什么？状态转移方程是什么？</p>
<ul>
<li><p>状态是什么</p>
<p>我们要求target为和的可能个数，那么我们可以用一个备忘录来存储所有比target小的数的可能个数</p>
<p>即mem[i] 表示和为i时候的个数</p>
</li>
<li><p>状态转移方程是什么</p>
<p>状态转移方程也可以了解为递推的过程，就是如何从小到大，将整个备忘录填写完成。我们的备忘录填写过程还是要根据所给的数组来完成的。比如<code>nums=[1,3]</code> 那么产生<code>target=4</code>如何产生呢？</p>
<blockquote>
<p>mem[0] = 1</p>
<p>mem[1] = mem[1-nums[0]] = mem[0] = 1</p>
<p>mem[2] = mem[2-nums[0]] = mem[1] = 1</p>
<p>mem[3] = mem[3-nums[0]] + mem[3-nums[1]] = mem[2] + mem[0] = 2</p>
<p>mem[4] = mem[4-nums[0]] + mem[4-nums[1]] = mem[3] + mem[1] = 2+1 = 3 </p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> target &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        mem = [<span class="number">0</span>]*(target+<span class="number">1</span>)</span><br><span class="line">        mem[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= nums[j]:</span><br><span class="line">                    mem[i] += mem[i-nums[j]]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mem[target]</span><br></pre></td></tr></table></figure>
<h3 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h3><ul>
<li><p>如果给定的数组中含有负数会怎么样？问题会产生什么变化？</p>
</li>
<li><p>如果不只是问个数，更要求 求出结果集</p>
<p>则第一种方法，可以通过回溯将结果求出</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-216-组合总和III</title>
    <url>/2020/01/03/Leetcode/leetcode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/</url>
    <content><![CDATA[<h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<p>所有数字都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>
<p>输入: k = 3, n = 7<br>输出: [[1,2,4]]<br>示例 2:</p>
<p>输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯+剪枝，轻车熟路</p>
<p>清楚每一次递归的元素是什么，基本都是有几个必要的元素</p>
<blockquote>
<p>结果集、栈、递归控制元素</p>
</blockquote>
<p>对应本体 结果集就是result</p>
<p>栈就是用来存储结果的stack</p>
<p>控制元素本体就是n,k</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        base = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">        <span class="comment"># 剪枝两次， n==0 k ==0</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        self.helper(base, n, k, result, stack, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, base, n, k,result,stack,start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">and</span> k ==<span class="number">0</span>:</span><br><span class="line">            result.append(stack.copy())</span><br><span class="line">				<span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(start,<span class="number">9</span>):</span><br><span class="line">            stack.append(base[index])</span><br><span class="line"></span><br><span class="line">            self.helper(base,n-base[index],k<span class="number">-1</span>,result,stack,index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            stack.pop()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-39-组合总和</title>
    <url>/2020/01/03/Leetcode/leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>
<p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]<br>示例 2:</p>
<p>输入: candidates = [2,3,5], target = 8,<br>所求解集为:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可能确实刷题刷出来感觉了，拿到题第一时间就想到了用 回溯来做，具体细节当然要使用一些剪枝。</p>
<p>既然使用回溯来做，最好要画图分析下（递归的过程都可以画成树）</p>
<p>（假装这里有个图）</p>
<p>然后比较细节的地方就是：</p>
<ul>
<li>本题是 <strong>无重复数字</strong>，所以想要避免出现重复的组合，只需选下一个数的时候，从当前位置向后看即可</li>
<li>为什么是当前位置向后看？而不是当前位置+1向后？因为题目说明数字是可以<strong>无限制重复</strong>选取的。</li>
</ul>
<p>搞清楚</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        self.helper(candidates, target, result, stack, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, candidates, target, result, stack, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:  <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:  <span class="comment"># 找到一个结果集</span></span><br><span class="line">            result.append(stack.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">            stack.append(candidates[index])</span><br><span class="line">						<span class="comment"># 由于允许有重复 所以下一个位置还是从index 开始</span></span><br><span class="line">            self.helper(candidates, target-candidates[index], result, stack, index)</span><br><span class="line"></span><br><span class="line">            stack.pop()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-1138-字母板上的路径</title>
    <url>/2020/01/02/Leetcode/leetcode-1138-%E5%AD%97%E6%AF%8D%E6%9D%BF%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="字母板上的路径"><a href="#字母板上的路径" class="headerlink" title="字母板上的路径"></a>字母板上的路径</h2><p>我们从一块字母板上的位置 (0, 0) 出发，该坐标对应的字符为 board[0][0]。</p>
<p>在本题里，字母板为board = [“abcde”, “fghij”, “klmno”, “pqrst”, “uvwxy”, “z”].</p>
<p>我们可以按下面的指令规则行动：</p>
<p>如果方格存在，’U’ 意味着将我们的位置上移一行；<br>如果方格存在，’D’ 意味着将我们的位置下移一行；<br>如果方格存在，’L’ 意味着将我们的位置左移一列；<br>如果方格存在，’R’ 意味着将我们的位置右移一列；<br>‘!’ 会把在我们当前位置 (r, c) 的字符 board[r][c] 添加到答案中。<br>返回指令序列，用最小的行动次数让答案和目标 target 相同。你可以返回任何达成目标的路径。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：target = “leet”<br>输出：”DDR!UURRR!!DDD!”<br>示例 2：</p>
<p>输入：target = “code”<br>输出：”RR!DDRR!UUL!R!”</p>
<p>提示：</p>
<p>1 &lt;= target.length &lt;= 100<br>target 仅含有小写英文字母。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">"abcde"</span>, </span><br><span class="line"> <span class="string">"fghij"</span>, </span><br><span class="line"> <span class="string">"klmno"</span>, </span><br><span class="line"> <span class="string">"pqrst"</span>, </span><br><span class="line"> <span class="string">"uvwxy"</span>, </span><br><span class="line"> <span class="string">"z"</span>].</span><br></pre></td></tr></table></figure>
<p>注意遍历的顺序：先 左和上  再右和下</p>
<p>原因是：最后一个z的位置 比较特殊，如果想到z位置，只能从z的上面才能到，z的右侧，z的下面都不可以到达z位置，只能上面到，所以要先进行   向左或者向上  的操作。（因为如果先进行向右或者向下 势必会遍历到非法区域）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alphabetBoardPath</span><span class="params">(self, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> target:</span><br><span class="line">            error = ord(char) - ord(<span class="string">'a'</span>)</span><br><span class="line">            row = error // <span class="number">5</span></span><br><span class="line">            col = error % <span class="number">5</span></span><br><span class="line">            左侧</span><br><span class="line">            <span class="keyword">if</span> col &lt; j:</span><br><span class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> range(j-col):</span><br><span class="line">                    result += <span class="string">'L'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> row &lt; i:</span><br><span class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> range(i-row):</span><br><span class="line">                    result += <span class="string">'U'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> row &gt; i:</span><br><span class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> range(row-i):</span><br><span class="line">                    result += <span class="string">'D'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> col &gt; j:</span><br><span class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> range(col-j):</span><br><span class="line">                    result += <span class="string">'R'</span></span><br><span class="line"></span><br><span class="line">            result += <span class="string">'!'</span></span><br><span class="line">            i = row</span><br><span class="line">            j = col</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p> <strong>注意这里存在的问题</strong>：</p>
<p>严格意义上讲，这个题并没有通过所有的测试case</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-31-下一个排列</title>
    <url>/2019/12/31/Leetcode/leetcode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找下一个排列，就是用程序模拟下我们人是怎么找下一个排列的</p>
<blockquote>
<p>举个例子  1，3，5，4，2</p>
<p>下一个排列，我们会先定位到3这个地方，因为后一个的值比3大（最大的数就是倒序排，最小的就是正序排，那么下一个排列肯定是较大的一个数）。因为只是找下一个排列，我们找到比3大的数中最小的即4，</p>
<p>交换3和4得到1，4，5，3，2</p>
<p>只找到下一个排列，所以应将4后边的进行翻转得，1，4，2，3，5即为结果</p>
</blockquote>
<p>主要就是三步：</p>
<ul>
<li>找到需要交换的位置，即存在<code>nums[i]&lt;nums[i+1]</code>,这个过程需要<strong>从后向前</strong>遍历</li>
<li>再找到需要交换的元素，即被交换元素是较大数中最小的，然后交换</li>
<li>将位置后边的翻转</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i = n<span class="number">-2</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] &lt;= nums[i]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>: <span class="comment"># 比较巧妙的是：上面如果已经是最大那么i会为-1 会直接翻转整个list</span></span><br><span class="line">            j = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= i <span class="keyword">and</span> nums[j] &lt;= nums[i]:</span><br><span class="line">                j -= <span class="number">1</span> </span><br><span class="line">            nums[i],nums[j] = nums[j],nums[i]</span><br><span class="line">        </span><br><span class="line">        self.reverse(nums,i)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, index)</span>:</span></span><br><span class="line">        left = index+<span class="number">1</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left],nums[right] = nums[right],nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>training loss nan问题</title>
    <url>/2019/12/30/Training%20loss%20nan/</url>
    <content><![CDATA[<h2 id="Training-loss-nan"><a href="#Training-loss-nan" class="headerlink" title="Training loss nan"></a>Training loss nan</h2><p>训练模型时候发现 training loss nan 了，简单查了下，会有很多情况导致。</p>
<p>我的问题就是数据有脏数据 nan的 inf的 等等…</p>
<p>总结的话就是发现nan之后 先check下数据！！！</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-47-全排列II</title>
    <url>/2019/12/29/Leetcode/leetcode-47-%E5%85%A8%E6%8E%92%E5%88%97II/</url>
    <content><![CDATA[<h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例:</p>
<p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>加入限制：<strong>含重复元素</strong></p>
<p>含重复元素带来的问题就是，会导致出现重复的排列。我们需要做的就是<strong>剪枝</strong></p>
<p>具体的剪枝操作如何进行呢？</p>
<p>回到重复元素问题，如果是数组含有重复元素，我们最好的办法是通过hash去重，或者通过预排序，预排序将重复元素都放在一起，也比较好操作。这里我们的结果都是list，list是不能进行hash的，所以使用预排序的方法。这里跟<strong>3sum</strong>的题有异曲同工之妙，通过预排序让问题更加好解决。</p>
<p>预排序之后呢？</p>
<p>预排序之后，重复元素好处理了，那么我们进行剪枝时候，可以利用排序数组的性质，将存在的重复情况跳过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>]==nums[i]:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>这里因为是回溯+剪枝，还需要考虑下状态问题，沿用<a href="">Leetcode-46-全排列</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] ==nums[i] <span class="keyword">and</span> <span class="keyword">not</span> used[i<span class="number">-1</span>]:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>当前位置如果是重复元素，并且之前的元素已经是False了，即说明已经遍历过了，那么当前元素(i)可以continue。</p>
<p>为什么之前相同元素状态是False就表示已经遍历过呢？因为for i 的循环是表示在同一层，前面的元素先于后边的元素进行遍历，如果前面的元素是False，肯定使用经过遍历再回溯修改状态为False，那么同一层的相同元素就没有必要再遍历了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        used = [<span class="literal">False</span>]*len(nums)</span><br><span class="line"></span><br><span class="line">        self.helper(<span class="number">0</span>, nums, stack, used, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, depth, nums, stack, used, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> depth == len(nums):</span><br><span class="line">            result.append(stack.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                <span class="comment"># 1.i &gt;0 i-1才不会越界</span></span><br><span class="line">                <span class="comment"># nums[i-1] == nums[i] 重复元素 且 nums[i-1]没有被遍历 则 证明会有重复排列</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>] <span class="keyword">and</span> used[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                stack.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                self.helper(depth+<span class="number">1</span>, nums, stack, used, result)</span><br><span class="line"></span><br><span class="line">                stack.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-60-第K个排列</title>
    <url>/2019/12/29/Leetcode/leetcode-60-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="第K个排列"><a href="#第K个排列" class="headerlink" title="第K个排列"></a>第K个排列</h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p>
<p>说明：</p>
<p>给定 n 的范围是 [1, 9]。<br>给定 k 的范围是[1,  n!]。<br>示例 1:</p>
<p>输入: n = 3, k = 3<br>输出: “213”<br>示例 2:</p>
<p>输入: n = 4, k = 9<br>输出: “2314”</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>延续全排列的办法，将全部排列都求出之后，找到第K个排列即可，当然，这道题这么做直接<strong>超时</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        result = []</span><br><span class="line">        stack = <span class="string">''</span></span><br><span class="line">        used = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        self.helper(<span class="number">0</span>,nums,stack,used,result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(result[k<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, length, nums, stack,used, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> length == len(nums):</span><br><span class="line">            result.append(stack)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                stack += str(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                self.helper(length+<span class="number">1</span>,nums,stack,used,result)</span><br><span class="line"></span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">                stack = stack[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gadnuwrckbj30m807s3yx.jpg" alt="image-20191229161342833"></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>回溯+剪枝</strong>，当严格意义上来讲，并没有回溯的过程，更多的体现在<strong>剪枝</strong>上</p>
<p>回溯：我们需要修改状态，然后操作，之后进行回溯，再修改状态。对应排列问题就是进入时候<code>used[i]=Ture</code>,回溯<code>used[i]=False。</code></p>
<p>剪枝：对不满足条件的状况不再进行dfs搜索解，直接跳过。</p>
<p>本题的剪枝条件是<strong>个数限制</strong>。因为就是数字的全排列，那么以任一一个数字开头的可能情况都是可以计算的。以<code>n=3</code>为例。</p>
<blockquote>
<p>n = 3,可能解为[‘123’,’132’,’213’,’231’,’312’,’321’]  即 3! 等于 6</p>
<p>当第一位确认为‘1’时，后面只能选’2’,’3’  则 2！=2</p>
<p>如果我们的输入为n=3,k=3</p>
<p>由于第一位为’1’时候，可能解为2！=2 &lt; k=3 则不必再对’1’为第一位的情况展开搜索 直接跳过</p>
<p>此时注意跳过后k = k-2 =1。</p>
<p>接下来第一位为’2’时候，可能解为2!=2 &gt; k=1，则第k个解就在这个里面，我们只需要对该情况进行搜索即可</p>
</blockquote>
<p>上面举的例子只是考虑了第一位的情况（对应递归树就是第一层），之后的每一层都是一样的，也都是进行剪枝判断就可以了。实际并没有回溯的过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_factorial</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res *= n</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        used = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        stack = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">0</span>,n,k,stack,used)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,depth, n, k, stack,used)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> depth == n:</span><br><span class="line">            <span class="keyword">return</span> stack</span><br><span class="line"></span><br><span class="line">        before = self.get_factorial(n-depth<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">          	<span class="comment"># 第一次剪枝：去过的不能再去</span></span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 第二次剪枝：解的个数&lt;k</span></span><br><span class="line">            <span class="keyword">if</span> before &lt; k:</span><br><span class="line">                k -= before</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">### 并没有回溯过程</span></span><br><span class="line">            stack += str(i)</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> self.helper(depth+<span class="number">1</span>, n, k, stack, used)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>BeautifulSoup 4 部分使用笔记</title>
    <url>/2019/12/27/BeautifulSoup4/</url>
    <content><![CDATA[<h1 id="BeautifulSoup-4-使用理解"><a href="#BeautifulSoup-4-使用理解" class="headerlink" title="BeautifulSoup 4  使用理解"></a>BeautifulSoup 4  使用理解</h1><p><strong>核心</strong>：Beautiful Soup将复杂HTML文档转换成一个复杂的<strong>树形结构</strong>,每个节点都是Python对象,所有对象可以归纳为4种: <code>Tag</code> , <code>NavigableString</code> , <code>BeautifulSoup</code> , <code>Comment</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全篇都是以这个例子进行展开</span></span><br><span class="line">html_doc = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html_doc)</span><br></pre></td></tr></table></figure>
<h2 id="基础节点类型"><a href="#基础节点类型" class="headerlink" title="基础节点类型"></a>基础节点类型</h2><ul>
<li><p>Tag：Tag节点也是最基本的节点类型。两个重要属性 name  attributes（类似字典包含id,class 等等）</p>
</li>
<li><p>NavigableString：包含在Tag中的字符串</p>
<p>tag中的字符串不能编辑，但是可以被替换成其他的字符串，用replace_with()</p>
</li>
<li><p>BeautifulSoup：</p>
<p>支持搜索文档树 和 遍历文档树的大部分方法</p>
</li>
<li><p><code>Comment</code> 对象是一个特殊类型的 <code>NavigableString</code> 对象，大部分使用用来表示注释部分</p>
</li>
</ul>
<p>Tag，NavigableString和BeautifulSoup基本上就可以表示html和XML中的所有内容了</p>
<h2 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h2><p>理解BeautifulSoup 将HTML文档解析成为DOM文档树，这个树的每个标签代表一个节点。一个Tag可能包含多个String或其他Tag，这些都是这个Tag的子节点，BeautifulSoup提供了许多操作和遍历子节点的属性</p>
<h3 id="contents-和-children"><a href="#contents-和-children" class="headerlink" title=".contents 和 .children"></a>.contents 和 .children</h3><p>遍历文档树的两个重要属性<code>.contents</code>和<code>.children</code></p>
<p>.contents 会将当前节点（TAG）的子节点以<strong>列表</strong>的形式输出</p>
<p><strong>一个节点其子节点可能有其他TAG 也可能有字符串String，string 是不可迭代的</strong></p>
<p>.children 产生<strong>生成器</strong>，可以对tag的子节点进行循环</p>
<h3 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h3><p><code>.descendants</code> 属性可以对所有tag的子孙节点进行<strong>递归循环</strong>遍历（<code>先序</code>遍历形式）：</p>
<h3 id="strings-和-stripped-strings"><a href="#strings-和-stripped-strings" class="headerlink" title=".strings 和 stripped_strings"></a>.strings 和 stripped_strings</h3><p>如果tag中包含多个字符串 ,可以使用 <code>.strings</code> 来循环获取:</p>
<blockquote>
<p>print(‘ ‘.join([string.strip() for string in soup.body.find_all(‘p’)[1].strings]))</p>
<p>soup 是BeautifulSoup对象，通过.body进入 body 标签下，进行find_all(‘p’)查找全部P标签</p>
<p>拿到[1]的p标签，然后进行strings，产生generator 通过join方式将 生成器的内容进行结合</p>
<p> 输出为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Once upon a time there were three little sisters; <span class="keyword">and</span> their names were Elsie , Lacie <span class="keyword">and</span> Tillie ;</span><br><span class="line"><span class="keyword">and</span> they lived at the bottom of a well.</span><br></pre></td></tr></table></figure>
</blockquote>
<p> <code>.stripped_strings</code> 可以去除多余空白内容(空格，空行)</p>
<h3 id="父节点-parent-和-parents"><a href="#父节点-parent-和-parents" class="headerlink" title="父节点.parent 和 .parents"></a>父节点.parent 和 .parents</h3><p>.parent 获取某个元素的父节点。</p>
<p>.parents 属性可以用递归得到元素的所有父辈节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">link = soup.a</span><br><span class="line">link</span><br><span class="line"><span class="comment"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> link.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(parent.name)</span><br><span class="line"><span class="comment"># p</span></span><br><span class="line"><span class="comment"># body</span></span><br><span class="line"><span class="comment"># html</span></span><br><span class="line"><span class="comment"># [document]</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<h3 id="兄弟节点-next-sibling-和-previous-sibling"><a href="#兄弟节点-next-sibling-和-previous-sibling" class="headerlink" title="兄弟节点.next_sibling 和 .previous_sibling"></a>兄弟节点.next_sibling 和 .previous_sibling</h3><p>同一层的标签，是兄弟节点，他们来自同一个 父节点</p>
<p>在文档树中,使用 <code>.next_sibling</code> 和 <code>.previous_sibling</code> 属性来查询兄弟节点</p>
<p>通过 <code>.next_siblings</code> 和 <code>.previous_siblings</code> 属性可以对当前节点的兄弟节点迭代输出</p>
<p>BeautifulSoup解决的思路就是：</p>
<p>先搜索String 找到可能 关键句，然后从关键句的地方进行判断进行删除</p>
<h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><p>心得：一般爬虫使用这个来爬取数据，正常都是用到的Bs4的搜索技巧，最近实习工作中，使用这个来对新闻进行修改（冗余优化），还需要使用<strong>修改</strong>技巧，修改嘛，无非就是（增删改）</p>
<p>对于增，用的比较少。（冗余优化 主要是删改）</p>
<p>对于删除，首先要定位到目标位置，需要观察一批数据的情况</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>beautifulsoup  官网中文</p>
<p><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id18" target="_blank" rel="noopener">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id18</a></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-35-搜索插入位置（一点都不easy）</title>
    <url>/2019/12/26/Leetcode/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p>
<p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p>
<p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>妈了个鸡，一点都不简单，二分这个坑。。。</p>
<p>原本的二分检索，如果检索不到target的话，跳出循环时候，会有left &gt;  right即left=right+1</p>
<p>这个时候对应两种情况:</p>
<ul>
<li>一种是由于<code>nums[mid]&lt;target</code>导致left=mid+1跳出，此时left-1&lt;target&lt;left</li>
<li>一种是由于 <code>nums[mid]&gt;target</code>导致right=mid-1跳出，此时 right&lt;target&lt;right+1 而left=right+1,即也是left-1&lt;target&lt;left</li>
</ul>
<p>即不论什么情况，只要没有检索到目标值，那么target一定介于<code>left-1</code>和<code>left</code>之间，对应插入位置就是left</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-313-超级丑数</title>
    <url>/2019/12/25/Leetcode/leetcode-313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="超级丑数"><a href="#超级丑数" class="headerlink" title="超级丑数"></a>超级丑数</h2><p>编写一段程序来查找第 n 个超级丑数。</p>
<p>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</p>
<p>示例:</p>
<p>输入: n = 12, primes = [2,7,13,19]<br>输出: 32<br>解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br>说明:</p>
<blockquote>
<p>1 是任何给定 primes 的超级丑数。</p>
<p>给定 primes 中的数字以升序排列。<br>0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。<br>第 n 个超级丑数确保在 32 位有符整数范围内。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>原本丑数就是质因数只有2，3，5的数字，这个题目扩展为丑数为一个list的质因数</p>
<p>思路都是一样的，只不过需要维护一个list的指针，以及一个丑数序列</p>
<p><code>p_list</code>是对应<code>primes</code>数组每个元素对应的指针数组，<code>p_list</code>中元素表示<code>primes</code>中质因数的指针</p>
<p><code>ugly</code>来记录超级丑数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span><span class="params">(self, n, primes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type primes: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> primes:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = len(primes)</span><br><span class="line">        p_list = [<span class="number">0</span>]*length</span><br><span class="line">        ugly = [<span class="number">0</span>]*n</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            min_value = <span class="number">2</span>**<span class="number">32</span></span><br><span class="line">            <span class="comment"># 找下一个丑数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length): <span class="comment"># 升序排列的</span></span><br><span class="line">                <span class="keyword">if</span> primes[j]*ugly[p_list[j]] &lt;= min_value:</span><br><span class="line">                    min_value = primes[j]*ugly[p_list[j]]</span><br><span class="line">            <span class="comment"># 满足条件的指针+1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length):</span><br><span class="line">                <span class="keyword">if</span> primes[j]*ugly[p_list[j]] == min_value:</span><br><span class="line">                    p_list[j] += <span class="number">1</span></span><br><span class="line">            ugly[i] = min_value</span><br><span class="line">        </span><br><span class="line">     		<span class="keyword">return</span> ugly[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-264-丑数II</title>
    <url>/2019/12/24/Leetcode/leetcode-264-%E4%B8%91%E6%95%B0II/</url>
    <content><![CDATA[<blockquote>
<p>复习要点</p>
<p>找第n个丑数，问题的basecase 我们知道了，只需要自底向上构建一个 n的丑数数组，</p>
</blockquote>
<h2 id="丑数II"><a href="#丑数II" class="headerlink" title="丑数II"></a>丑数II</h2><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例:</p>
<p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p>
<blockquote>
<p>1 是丑数。<br>n 不超过1690。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据丑数的定义，某个数如果是丑数一定是2，3，5的公倍数，那我们可以根据这个规则将丑数逐一列举出来。</p>
<p>列举的基本想法就是：如果一个数已经是丑数了，那么这个数的2，3，5倍仍然是丑数。</p>
<p>我们可以记录之前产生的所有丑数，然后维护三个指针，<code>p2</code>,<code>p3</code>,<code>p5</code>这三个指针什么用处呢？</p>
<blockquote>
<p>三个指针分别表示下一个丑数可能产生的情况：p2*2  p3*3  p5*5</p>
<p>这三个数哪个最小，就是下一个丑数，以最开始为例，第一个丑数为1,那么p2,p3,p5都指向1</p>
<p>1的下一个丑数是什么呢？ min(1*2,1*3,1*5) 为2，那么下一个丑数就是2，同时p2指针向前挪动一个</p>
<p>比如此时丑数序列已经有了[1,2,3,4,5,6,8,9,10]，p2指向6，p3指向4，p5指向3，</p>
<p>10的下一个丑数就是min(mem[p2]*2,mem[p3]*3,mem[p5]*5)</p>
<p>则下一个丑数为12</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        mem = [<span class="number">0</span>]*n</span><br><span class="line">        mem[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        p3 = <span class="number">0</span></span><br><span class="line">        p5 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            mem[i] = min(mem[p2]*<span class="number">2</span>,mem[p3]*<span class="number">3</span>,mem[p5]*<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> mem[i] == mem[p2]*<span class="number">2</span>:</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mem[i] == mem[p3]*<span class="number">3</span>:</span><br><span class="line">                p3+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mem[i] == mem[p5]*<span class="number">5</span>:</span><br><span class="line">                p5+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mem[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>又一次没写出来就是p2,p3,p5的含义搞混了</li>
<li>一定是在之前生成的丑数基础上进行操作</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-263-丑数</title>
    <url>/2019/12/23/Leetcode/leetcode-263-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>复习要点 判断是不是丑数，递归调用解决就可以了</p>
</blockquote>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例 1:</p>
<p>输入: 6<br>输出: true<br>解释: 6 = 2 × 3<br>示例 2:</p>
<p>输入: 8<br>输出: true<br>解释: 8 = 2 × 2 × 2<br>示例 3:</p>
<p>输入: 14<br>输出: false<br>解释: 14 不是丑数，因为它包含了另外一个质因数 7。<br>说明：</p>
<p>1 是丑数。<br>输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>丑数的定义已经说明白了，<code>只包含质因数2，3，5的正整数，1也是丑数</code></p>
<p>给我们一个数，只需要不断用丑数的质因数去除待测试的数即可，如果最后的结果是1则是丑数，否则不是</p>
<p>（0这个数是个坑，记得排除）</p>
<p>递归解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">3</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">5</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-23-合并K个排序链表</title>
    <url>/2019/12/23/Leetcode/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a>合并K个排序链表</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题目其实比较简单，因为其子问题就是合并两个排序链表，这个是比较简单的。如果已经能解决两个链表了，那么K个链表也好解决。这里我们采用的<strong>分治</strong>的策略。</p>
<p>对于k个链表，我们最终可以分别两两合并，然后再将合并的结果再两两合并…</p>
<p>这个过程不就是归并排序的过程嘛…</p>
<blockquote>
<p>我们回想下归并排序的过程</p>
<p>给定：[5,2,3,4,1,6]</p>
<p>[5] [2] [3] [4] [1] [6]  两两合并</p>
<p>[2,5],[3,4],[1,6] 再两两合并</p>
<p>[2,3,4,5],[1,6] 再两两合并</p>
<p>[1,2,3,4,5,6] </p>
</blockquote>
<p>归并排序我们操作的是两个元素比较大小然后决定谁在前谁在后，而本题我们解决的是链表，只需要把基本操作换成链表的合并即可。</p>
<p>模板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">()</span>:</span></span><br><span class="line">  	divide(全部)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">()</span>:</span></span><br><span class="line">    终止条件...</span><br><span class="line">    </span><br><span class="line">    中间 =  (左+右)/<span class="number">2</span></span><br><span class="line">    左结果 = divide 左边</span><br><span class="line">    有结果 = divide 右边</span><br><span class="line">  	合并 左结果，右结果</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">()</span>:</span></span><br><span class="line">  	进行合并操作</span><br></pre></td></tr></table></figure>
<p>根据上边的模板</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># divide 整个数组</span></span><br><span class="line">        <span class="keyword">return</span> self.divide(lists,<span class="number">0</span>,len(lists)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 划分操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, lists, left, right)</span>:</span></span><br><span class="line">      	<span class="comment"># 终止条件: 仅一个元素</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> lists[left]</span><br><span class="line">        <span class="comment"># 找中间</span></span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 左结果 = divide 左边</span></span><br><span class="line">        l1 = self.divide(lists, left, mid)</span><br><span class="line">				<span class="comment"># 右结果 = divide 右边</span></span><br><span class="line">        l2 = self.divide(lists, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="comment"># 合并（左结果，右结果）</span></span><br><span class="line">        <span class="keyword">return</span> self.merge2Lists(l1,l2)</span><br><span class="line">		<span class="comment"># 合并操作：本题的合并操作是 链表级别的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge2Lists</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        p1 = left</span><br><span class="line">        p2 = right</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val &lt; p2.val:</span><br><span class="line">                p.next = p1</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">elif</span> p1.val &gt;= p2.val:</span><br><span class="line">                p.next = p2</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> p1:</span><br><span class="line">            p.next = p1</span><br><span class="line">        <span class="keyword">if</span> p2:</span><br><span class="line">            p.next = p2</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-2-两数相加</title>
    <url>/2019/12/22/Leetcode/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<blockquote>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目不难，但是细节问题吧…还是坑不少的</p>
<p>下面这个解法的思路就是先对应位相加，需要进位的记录下，然后在下一位时候考虑进去。总的思路是循环加到某个链表为空，则跳出处理。那么只需要把不空的那个链表链接到结果链表后边就可以了。</p>
<p>但是少考虑这样会出现的问题。</p>
<blockquote>
<p>[1]</p>
<p>[9,9]</p>
<p>Result:[0,0,1]</p>
<p>但是我的返回结果是:[0,10]</p>
</blockquote>
<p>下面附上<strong>错误代码</strong></p>
<p>这个想要更正也可以，后边的if语句换成while，然后进行对应操作即可。但是这样实际上把问题变复杂了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">            tmp.val = (p1.val+p2.val+carry)%<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> p1.val + p2.val +carry &gt;=<span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">            p.next = p2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            p.next = p1</span><br><span class="line">        <span class="keyword">if</span> carry==<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> p.next:</span><br><span class="line">            a = ListNode(<span class="number">1</span>)</span><br><span class="line">            p.next = a</span><br><span class="line">        <span class="keyword">elif</span> carry==<span class="number">1</span> <span class="keyword">and</span> p.next:</span><br><span class="line">            p.next.val += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<p>正确思路：</p>
<p>不用提前结束为空的链表，实际过程，两个链表是同步走的，如果其中一个链表为空了，我们可认为这个部分的值<strong>为0</strong> 即可，其他操作都一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">or</span> p2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">                x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = p1.val</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">                y = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y = p2.val</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            </span><br><span class="line">            tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">            tmp.val = (x+y+carry)%<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> x+y+carry &gt;=<span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            p = p.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> carry==<span class="number">1</span>:</span><br><span class="line">            a = ListNode(<span class="number">1</span>)</span><br><span class="line">            p.next = a</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-16-最接近的三数之和</title>
    <url>/2019/12/22/Leetcode/leetcode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本还是<a href="https://mereder.github.io/2019/11/25/leetcode-15-三数之和/" target="_blank" rel="noopener">三数之和</a>的思路，但是不用考虑重复问题。毕竟是找最接近的，而不是完全命中。相对简单点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        min_error = <span class="number">2</span>**<span class="number">32</span><span class="number">-1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            right = n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[left] + nums[right] &lt; target:</span><br><span class="line">                    <span class="keyword">if</span> abs(nums[i] + nums[left] + nums[right] - target) &lt; min_error:</span><br><span class="line">                        min_error = abs(nums[i] + nums[left] + nums[right] - target)</span><br><span class="line">                        result = nums[i] + nums[left] + nums[right]</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[left] + nums[right] &gt;= target:</span><br><span class="line">                    <span class="keyword">if</span> abs(nums[i] + nums[left] + nums[right] - target) &lt; min_error:</span><br><span class="line">                        min_error = abs(nums[i] + nums[left] + nums[right] - target)</span><br><span class="line">                        result = nums[i] + nums[left] + nums[right]</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>HDFS 操作指令</title>
    <url>/2019/12/22/hadoop%20hdfs%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>其操作指令大部分跟linux下的命令差不多。</p>
<p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html</a></p>
<h2 id="FS-Shell"><a href="#FS-Shell" class="headerlink" title="FS Shell"></a>FS Shell</h2><p>调用文件系统(FS)Shell命令应使用 bin/hadoop fs <args>的形式。 所有的的FS shell命令使用URI路径作为参数。URI格式是<em>scheme://authority/path</em>。对HDFS文件系统，scheme是<em>hdfs</em>，对本地文件系统，scheme是<em>file</em>。其中scheme和authority参数都是可选的，如果未加指定，就会使用配置中指定的默认scheme。一个HDFS文件或目录比如<em>/parent/child</em>可以表示成<em>hdfs://namenode:namenodeport/parent/child</em>，或者更简单的<em>/parent/child</em>（假设你配置文件中的默认值是<em>namenode:namenodeport</em>）。大多数FS Shell命令的行为和对应的Unix Shell命令类似，不同之处会在下面介绍各命令使用详情时指出。出错信息会输出到<em>stderr</em>，其他信息输出到<em>stdout</em>。</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>使用方法：hadoop fs -cat URI [URI …]</p>
<p>将路径指定文件的内容输出到<em>stdout</em>。</p>
<p>示例：</p>
<ul>
<li>hadoop fs -cat hdfs://host1:port1/file1 hdfs://host2:port2/file2 </li>
<li>hadoop fs -cat file:///file3 /user/hadoop/file4 </li>
</ul>
<p>返回值：<br>成功返回0，失败返回-1。</p>
<h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>使用方法：hadoop fs -chgrp [-R] GROUP URI [URI …] Change group association of files. With -R, make the change recursively through the directory structure. The user must be the owner of files, or else a super-user. Additional information is in the <a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_permissions_guide.html" target="_blank" rel="noopener">Permissions User Guide</a>. —&gt;</p>
<p>改变文件所属的组。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。更多的信息请参见<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_permissions_guide.html" target="_blank" rel="noopener">HDFS权限用户指南</a>。</p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>使用方法：hadoop fs -chmod [-R] <MODE[,MODE]... | OCTALMODE> URI [URI …]</p>
<p>改变文件的权限。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。更多的信息请参见<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_permissions_guide.html" target="_blank" rel="noopener">HDFS权限用户指南</a>。</p>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>使用方法：hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]</p>
<p>改变文件的拥有者。使用-R将使改变在目录结构下递归进行。命令的使用者必须是超级用户。更多的信息请参见<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_permissions_guide.html" target="_blank" rel="noopener">HDFS权限用户指南</a>。</p>
<h3 id="copyFromLocal"><a href="#copyFromLocal" class="headerlink" title="copyFromLocal"></a>copyFromLocal</h3><p>使用方法：hadoop fs -copyFromLocal <localsrc> URI</p>
<p>除了限定源路径是一个本地文件外，和<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#putlink" target="_blank" rel="noopener"><strong>put</strong></a>命令相似。</p>
<h3 id="copyToLocal"><a href="#copyToLocal" class="headerlink" title="copyToLocal"></a>copyToLocal</h3><p>使用方法：hadoop fs -copyToLocal [-ignorecrc] [-crc] URI <localdst></p>
<p>除了限定目标路径是一个本地文件外，和<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#getlink" target="_blank" rel="noopener"><strong>get</strong></a>命令类似。</p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>使用方法：hadoop fs -cp URI [URI …] <dest></p>
<p>将文件从源路径复制到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。<br>示例：</p>
<ul>
<li>hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2</li>
<li>hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 /user/hadoop/dir </li>
</ul>
<p>返回值：</p>
<p>成功返回0，失败返回-1。</p>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>使用方法：hadoop fs -du URI [URI …]</p>
<p>显示目录中所有文件的大小，或者当只指定一个文件时，显示此文件的大小。<br>示例：<br>hadoop fs -du /user/hadoop/dir1 /user/hadoop/file1 hdfs://host:port/user/hadoop/dir1<br>返回值：<br>成功返回0，失败返回-1。 </p>
<h3 id="dus"><a href="#dus" class="headerlink" title="dus"></a>dus</h3><p>使用方法：hadoop fs -dus <args></p>
<p>显示文件的大小。</p>
<h3 id="expunge"><a href="#expunge" class="headerlink" title="expunge"></a>expunge</h3><p>使用方法：hadoop fs -expunge</p>
<p>清空回收站。请参考<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">HDFS设计</a>文档以获取更多关于回收站特性的信息。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>使用方法：hadoop fs -get [-ignorecrc] [-crc] <src> <localdst> </p>
<p>复制文件到本地文件系统。可用-ignorecrc选项复制CRC校验失败的文件。使用-crc选项复制文件以及CRC信息。</p>
<p>示例：</p>
<ul>
<li>hadoop fs -get /user/hadoop/file localfile </li>
<li>hadoop fs -get hdfs://host:port/user/hadoop/file localfile</li>
</ul>
<p>返回值：</p>
<p>成功返回0，失败返回-1。</p>
<h3 id="getmerge"><a href="#getmerge" class="headerlink" title="getmerge"></a>getmerge</h3><p>使用方法：hadoop fs -getmerge <src> <localdst> [addnl]</p>
<p>接受一个源目录和一个目标文件作为输入，并且将源目录中所有的文件连接成本地目标文件。addnl是可选的，用于指定在每个文件结尾添加一个换行符。 </p>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>使用方法：hadoop fs -ls <args></p>
<p>如果是文件，则按照如下格式返回文件信息：<br>文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID<br>如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下：<br>目录名 <dir> 修改日期 修改时间 权限 用户ID 组ID<br>示例：<br>hadoop fs -ls /user/hadoop/file1 /user/hadoop/file2 hdfs://host:port/user/hadoop/dir1 /nonexistentfile<br>返回值：<br>成功返回0，失败返回-1。 </p>
<h3 id="lsr"><a href="#lsr" class="headerlink" title="lsr"></a>lsr</h3><p>使用方法：hadoop fs -lsr <args><br>ls命令的递归版本。类似于Unix中的ls -R。</p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>使用方法：hadoop fs -mkdir <paths> </p>
<p>接受路径指定的uri作为参数，创建这些目录。其行为类似于Unix的mkdir -p，它会创建路径中的各级父目录。</p>
<p>示例：</p>
<ul>
<li>hadoop fs -mkdir /user/hadoop/dir1 /user/hadoop/dir2 </li>
<li>hadoop fs -mkdir hdfs://host1:port1/user/hadoop/dir hdfs://host2:port2/user/hadoop/dir</li>
</ul>
<p>返回值：</p>
<p>成功返回0，失败返回-1。</p>
<h3 id="movefromLocal"><a href="#movefromLocal" class="headerlink" title="movefromLocal"></a>movefromLocal</h3><p>使用方法：dfs -moveFromLocal <src> <dst></p>
<p>输出一个”not implemented“信息。</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>使用方法：hadoop fs -mv URI [URI …] <dest></p>
<p>将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。<br>示例：</p>
<ul>
<li>hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2</li>
<li>hadoop fs -mv hdfs://host:port/file1 hdfs://host:port/file2 hdfs://host:port/file3 hdfs://host:port/dir1</li>
</ul>
<p>返回值：</p>
<p>成功返回0，失败返回-1。</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>使用方法：hadoop fs -put <localsrc> … <dst></p>
<p>从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。</p>
<ul>
<li>hadoop fs -put localfile /user/hadoop/hadoopfile</li>
<li>hadoop fs -put localfile1 localfile2 /user/hadoop/hadoopdir</li>
<li>hadoop fs -put localfile hdfs://host:port/hadoop/hadoopfile</li>
<li>hadoop fs -put - hdfs://host:port/hadoop/hadoopfile<br>从标准输入中读取输入。</li>
</ul>
<p>返回值：</p>
<p>成功返回0，失败返回-1。</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>使用方法：hadoop fs -rm URI [URI …] </p>
<p>删除指定的文件。只删除非空目录和文件。请参考rmr命令了解递归删除。<br>示例：</p>
<ul>
<li>hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir </li>
</ul>
<p>返回值：</p>
<p>成功返回0，失败返回-1。</p>
<h3 id="rmr"><a href="#rmr" class="headerlink" title="rmr"></a>rmr</h3><p>使用方法：hadoop fs -rmr URI [URI …]</p>
<p>delete的递归版本。<br>示例：</p>
<ul>
<li>hadoop fs -rmr /user/hadoop/dir </li>
<li>hadoop fs -rmr hdfs://host:port/user/hadoop/dir </li>
</ul>
<p>返回值：</p>
<p>成功返回0，失败返回-1。</p>
<h3 id="setrep"><a href="#setrep" class="headerlink" title="setrep"></a>setrep</h3><p>使用方法：hadoop fs -setrep [-R] <path></p>
<p>改变一个文件的副本系数。-R选项用于递归改变目录下所有文件的副本系数。</p>
<p>示例：</p>
<ul>
<li>hadoop fs -setrep -w 3 -R /user/hadoop/dir1 </li>
</ul>
<p>返回值：</p>
<p>成功返回0，失败返回-1。</p>
<h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p>使用方法：hadoop fs -stat URI [URI …]</p>
<p>返回指定路径的统计信息。</p>
<p>示例：</p>
<ul>
<li>hadoop fs -stat path </li>
</ul>
<p>返回值：<br>成功返回0，失败返回-1。</p>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>使用方法：hadoop fs -tail [-f] URI </p>
<p>将文件尾部1K字节的内容输出到stdout。支持-f选项，行为和Unix中一致。</p>
<p>示例：</p>
<ul>
<li>hadoop fs -tail pathname </li>
</ul>
<p>返回值：<br>成功返回0，失败返回-1。</p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>使用方法：hadoop fs -test -[ezd] URI</p>
<p>选项：<br>-e 检查文件是否存在。如果存在则返回0。<br>-z 检查文件是否是0字节。如果是则返回0。<br>-d 如果路径是个目录，则返回1，否则返回0。</p>
<p>示例：</p>
<ul>
<li>hadoop fs -test -e filename </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -test -e  file_path</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测路径是否存在</span></span><br><span class="line">其对应返回这可以用shell $?  来捕捉</span><br></pre></td></tr></table></figure>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>使用方法：hadoop fs -text <src> </p>
<p>将源文件输出为文本格式。允许的格式是zip和TextRecordInputStream。</p>
<h3 id="touchz"><a href="#touchz" class="headerlink" title="touchz"></a>touchz</h3><p>使用方法：hadoop fs -touchz URI [URI …] </p>
<p>创建一个0字节的空文件。</p>
<p>示例：</p>
<ul>
<li>hadoop -touchz pathname </li>
</ul>
<p>返回值：<br>成功返回0，失败返回-1。</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-278-第一个错误的版本</title>
    <url>/2019/12/22/Leetcode/leetcode-278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<blockquote>
<p> 示例:</p>
<p>给定 n = 5，并且 version = 4 是第一个错误的版本。</p>
<p>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true</p>
<p>所以，4 是第一个错误的版本。 </p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是将二分法应用到实际的问题解决当中。</p>
<p>还有诸如类似什么两地之间的电线有一处坏了，如果你是一名电工如何最快的确定出问题的地方在哪。</p>
<p>题随不难，上代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = n+<span class="number">1</span>  <span class="comment"># 这个地方很诡异  right=n 和 right = n+1 都能过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+((right-left) &gt;&gt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>两个水桶的装水问题</title>
    <url>/2019/12/18/%E8%A3%85%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="装水问题"><a href="#装水问题" class="headerlink" title="装水问题"></a>装水问题</h2><p>一个和尚去河边挑水，带了两个桶，一个是能装4斤水，一个能装9斤水，问如何可以装一个6斤水的出来</p>
<p>（or 一个能装3斤水一个能装5斤水）</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>A桶4斤，B桶9斤</p>
<p>只能有几种操作：</p>
<blockquote>
<p>Fill A</p>
<p>Fill B</p>
<p>Empty A</p>
<p>Empty B</p>
<p>A-B</p>
<p>B-A</p>
</blockquote>
<p>我们的操作序列如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.fill B -&gt; A:0 B:9</span><br><span class="line">2.B-A 	 -&gt; A:4 B:5</span><br><span class="line">3.empty A-&gt; A:0 B:5</span><br><span class="line">4.B-A		 -&gt; A:4 B:1</span><br><span class="line">5.empty A-&gt; A:0 B:1</span><br><span class="line">6.B-A  	 -&gt; A:1 B:0</span><br><span class="line">7.fill B -&gt; A:1 B:9</span><br><span class="line">8.B-A  	 -&gt; A:4 B:6</span><br></pre></td></tr></table></figure>
<p>即此时B桶内为6斤水，完成目标</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>一个和尚去河边挑水，带了两个桶，一个是能装4斤水，一个能装9斤水</p>
<p>1),要求写出算法，目标是如何装出6斤水</p>
<p>2),假设两个桶容量任意，比如X斤和Y斤,目标是Z斤;要求写出算法</p>
<p>该问题详解请见 <a href="https://mereder.github.io/2020/03/21/Leetcode/leetcode-365-水壶问题/" target="_blank" rel="noopener">Leetcode-365-装水问题</a></p>
]]></content>
      <categories>
        <category>智力题</category>
      </categories>
  </entry>
  <entry>
    <title>Hive 日常使用</title>
    <url>/2019/12/18/Hive/</url>
    <content><![CDATA[<h3 id="命令行执行hive操作"><a href="#命令行执行hive操作" class="headerlink" title="命令行执行hive操作"></a>命令行执行hive操作</h3><p>其中设置显示表头，<code>set hive.cli.print.header=True</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive -e "set hive.cli.print.header=True; select * from 表名 limit 2"</span><br></pre></td></tr></table></figure>
<h3 id="hive-建表"><a href="#hive-建表" class="headerlink" title="hive 建表"></a>hive 建表</h3><p>建表分为内部表和外部表，内部表的意思是指元数据和对应表都在内部，如果删除表之后，对应的元数据和表数据都会被删除。</p>
<p>外部表是通过<code>external</code> 来修饰的，其表的元数据也是存放在内部，但是对应数据是存储在hdfs上的，当删除表后，对应元数据会进行删除，而数据仍会保留在hdfs上。所以建表的时候需要指定好<code>location</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> table_name</span><br><span class="line">( <span class="keyword">query</span> <span class="keyword">string</span>,</span><br><span class="line"> 	<span class="keyword">id</span>		<span class="keyword">string</span>,</span><br><span class="line"> 	pvid 	<span class="keyword">string</span>,</span><br><span class="line"> 	logid <span class="keyword">string</span>,</span><br><span class="line">  wid	  <span class="built_in">bigint</span>,</span><br><span class="line">  pos   <span class="built_in">int</span>,</span><br><span class="line">  extras <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;,</span><br><span class="line"> 	label <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (dt <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>
<h3 id="hive-表的导入"><a href="#hive-表的导入" class="headerlink" title="hive 表的导入"></a>hive 表的导入</h3><h3 id="显示建表语句"><a href="#显示建表语句" class="headerlink" title="显示建表语句"></a>显示建表语句</h3><p>目的是为了获取创建表时候的相关信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure>
<h3 id="显示数据库的所有表"><a href="#显示数据库的所有表" class="headerlink" title="显示数据库的所有表"></a>显示数据库的所有表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">in</span> db_name</span><br></pre></td></tr></table></figure>
<h3 id="insert-用法问题"><a href="#insert-用法问题" class="headerlink" title="insert 用法问题"></a>insert 用法问题</h3><p>insert into 和 insert overwrite 只能用一种字段</p>
<p>其中 Insert into 是<strong>增量加入</strong>，新加入的数据会append 到表的后边</p>
<p>Insert overwrite 是表示<strong>覆盖</strong>，新加入的数据直接覆盖原数据表</p>
<h3 id="Drop-删除表-or-清空表"><a href="#Drop-删除表-or-清空表" class="headerlink" title="Drop 删除表 or 清空表"></a>Drop 删除表 or 清空表</h3><p>Drop 表示删除表，结构+数据都删除</p>
<p>truncate 表示清空表，会保留表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name </span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> table_name</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>
<h3 id="row-number的使用"><a href="#row-number的使用" class="headerlink" title="row_number的使用"></a>row_number的使用</h3><p>row_number()    是用来给 行进行编号的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *,row_number() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">rank</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>
<p>相当于查询原有表的基础上，再添加一列记录行号，这个行号如何统计呢？</p>
<p>就看<code>over</code>内的含义，按照partition by的字段(id)进行分组，然后按照<code>score</code>的大小进行排序，然后进行编号，并将编好的序号作为<code>rank</code>列进行返回，这个列的别名是可以修改的。</p>
<p>举个例子：</p>
<blockquote>
<p>Id, score,xxx</p>
<p>A1 , 10, xxx</p>
<p>A2 ,11,xxx</p>
<p>A1 ,9,xxx</p>
<p>A3 ,0,xxx</p>
<p>A2, 10,xxx</p>
</blockquote>
<p>操作之后的效果为</p>
<blockquote>
<p>Id, score,xxx,rank</p>
<p>A1 , 9, xxx,1</p>
<p>A1 ,10,xxx,2</p>
<p>A2 ,10,xxx,1</p>
<p>A2, 11,xxx,2</p>
<p>A3 ,0,xxx,1</p>
</blockquote>
<h3 id="CTAS：create-table-as-select"><a href="#CTAS：create-table-as-select" class="headerlink" title="CTAS：create table as select"></a>CTAS：create table as select</h3><p>重点操作，可以将select的结果存储到新建的表中。CTAS的操作是<strong>原子性</strong>的，也就是意味着这个新建的表直到所有的填充操作都做完之前是看不到的。</p>
<p><strong>注意</strong>：不能create external 表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- 基本操作</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name </span><br><span class="line">	<span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span></span><br><span class="line">	<span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\t'</span></span><br><span class="line">	<span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line">	<span class="keyword">store</span> <span class="keyword">as</span> textfile</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name ....</span><br></pre></td></tr></table></figure>
<h3 id="Group-by"><a href="#Group-by" class="headerlink" title="Group by"></a>Group by</h3><p>这个操作也很坑，select部分只能有 group by的字段以及，groupby字段的聚合函数</p>
<p>即hive中限制了 出现在select后边的列必须是出现在group by 后面的，即select列必须是作为分组依据的列。</p>
<p>下面这样的就会报错</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure>
<h3 id="列反向选择"><a href="#列反向选择" class="headerlink" title="列反向选择"></a>列反向选择</h3><p>如果我们的场景是：想选择除了某列外的其他所有列，原来的写法就只能把所有需要的列都一一列出来。</p>
<p>hive 提供了正则查询的方法，只需要把不需要查找的列排除在外就可以了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">`(name|dt)?+.+`</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>
<p>上述方法就是select了排除了 <code>name</code>,<code>dt</code>两列的其他所有列</p>
<p>这里有个问题需要注意， 上边使用的 是``符号，不是单引号，所以需要设定</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.support.quoted.identifiers=<span class="keyword">None</span>;</span><br><span class="line"><span class="keyword">select</span> ....</span><br></pre></td></tr></table></figure>
<h3 id="hive-分区表的问题"><a href="#hive-分区表的问题" class="headerlink" title="hive 分区表的问题"></a>hive 分区表的问题</h3><p>创建分区表的时候需要指定 <code>PARTITIONED BY (dt string)</code>相当于也定义了一列，这一列用来做分区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> table_name</span><br><span class="line">( <span class="keyword">query</span> <span class="keyword">string</span>,</span><br><span class="line"> 	<span class="keyword">id</span>		<span class="keyword">string</span>,</span><br><span class="line"> 	pvid 	<span class="keyword">string</span>,</span><br><span class="line"> 	logid <span class="keyword">string</span>,</span><br><span class="line">  wid	  <span class="built_in">bigint</span>,</span><br><span class="line">  pos   <span class="built_in">int</span>,</span><br><span class="line">  extras <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;,</span><br><span class="line"> 	label <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (dt <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">format</span> <span class="keyword">delimited</span></span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="string">'\n'</span></span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile</span><br><span class="line">location <span class="string">'app_path'</span></span><br></pre></td></tr></table></figure>
<p>同样在使用分区表的时候，插入会有同样的问题</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">table</span> table_name <span class="keyword">partition</span> (dt=<span class="string">'2019-12-08'</span>)</span><br><span class="line"><span class="keyword">select</span> *(除了dt以外的列) <span class="keyword">from</span> table_name2</span><br></pre></td></tr></table></figure>
<h3 id="Order-by排序"><a href="#Order-by排序" class="headerlink" title="Order by排序"></a>Order by排序</h3><p>标准用法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> col1,col2...  [<span class="keyword">asc</span>|<span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>
<p>相关问题：</p>
<ul>
<li>order by 为全局排序</li>
<li>order by 需要reducer操作，且只有一个reducer不能配置，因为多个reducer无法完成全局排序</li>
</ul>
<h3 id="collect-list-和-collect-set用法"><a href="#collect-list-和-collect-set用法" class="headerlink" title="collect_list 和 collect_set用法"></a>collect_list 和 collect_set用法</h3><p>都是将分组中的某列转为一个数组返回，不同的是，collect_list不去重，collect_set去重</p>
<p>按照group by的id方式聚合，然后对col列进行collect_list</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> collect_list(<span class="keyword">col</span>) <span class="keyword">from</span> table_name <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure>
<p>距离</p>
<h3 id="开启动态分区调整"><a href="#开启动态分区调整" class="headerlink" title="开启动态分区调整"></a>开启动态分区调整</h3><h3 id="array使用"><a href="#array使用" class="headerlink" title="array使用"></a>array使用</h3><p>业务场景需要将几列数据统一到一列作为特征。array可以直接使用，定义特征即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	<span class="keyword">id</span>,</span><br><span class="line">	collect_list(<span class="built_in">array</span>(gender,age,ect)) <span class="keyword">as</span> profile,</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">from</span> table_name</span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure>
<h3 id="case-when用法"><a href="#case-when用法" class="headerlink" title="case when用法"></a>case when用法</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">case when id &gt; 10 then 1 else 0 end</span><br></pre></td></tr></table></figure>
<p>上述实现的功能就是 将id大于10的变为1，否则变为0，主要写法，一定要记得<code>end</code></p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>1.先链接from 的数据源（若有join，先执行on后条件，再链接数据源）</p>
<p>2.执行where</p>
<p>3.执行groupby</p>
<p>4.执行having</p>
<p>5.执行order by</p>
<p>写代码时候 最好也按照这个顺序书写</p>
<h3 id="hive-表数据类型一定要对齐！！！max-string-的坑"><a href="#hive-表数据类型一定要对齐！！！max-string-的坑" class="headerlink" title="hive 表数据类型一定要对齐！！！max(string)的坑"></a>hive 表数据类型一定要对齐！！！max(string)的坑</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.id,</span><br><span class="line">	a.hot_fea,</span><br><span class="line">  b.hot_fea_max </span><br><span class="line"><span class="keyword">from</span> table_test a</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span></span><br><span class="line">	<span class="keyword">max</span>(hot_fea) hot_fea_mx,</span><br><span class="line"><span class="keyword">from</span> table_test) b</span><br><span class="line"><span class="keyword">where</span> a.id=<span class="string">'123'</span></span><br><span class="line"></span><br><span class="line"><span class="number">123</span>, <span class="number">250</span>, <span class="number">99</span> 分别对应<span class="keyword">id</span>, hot_fea, hot_fea_mx</span><br></pre></td></tr></table></figure>
<p>出现了数值比max还大的情况。原因就是<strong>max的列是string的</strong></p>
<h3 id="order-by-string的坑"><a href="#order-by-string的坑" class="headerlink" title="order by string的坑"></a>order by string的坑</h3><p>使用row_number 来生成行数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">row_number() over(partiton by id order by position) as row_number</span><br></pre></td></tr></table></figure>
<p>由于其中position是string类型的，会导致排序时候出现下面这种排序方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">21</span><br><span class="line">23</span><br><span class="line">3</span><br><span class="line">31</span><br><span class="line">8</span><br><span class="line">92</span><br></pre></td></tr></table></figure>
<h3 id="hive-各语句执行顺序"><a href="#hive-各语句执行顺序" class="headerlink" title="hive 各语句执行顺序"></a>hive 各语句执行顺序</h3><p>书写顺序sql：</p>
<blockquote>
<p> select … from … where … group by … having … order by … </p>
</blockquote>
<p>执行顺序：</p>
<blockquote>
<p>from … where … select … group by … having … order by …</p>
</blockquote>
<p>其实总结hive的执行顺序也是总结mapreduce的执行顺序：</p>
<p>MR程序的执行顺序：</p>
<ul>
<li><p>map阶段：</p>
<p>1.执行from加载，进行表的查找与加载</p>
<p>2.执行where过滤，进行条件过滤与筛选</p>
<p>3.执行select查询：进行输出项的筛选</p>
<p>4.执行group by分组：描述了分组后需要计算的函数</p>
<p>5.map端文件合并：map端本地溢出写文件的合并操作，每个map最终形成一个临时文件。 然后按列映射到对应的reduceReduce阶段：</p>
</li>
<li><p>Reduce阶段：</p>
<p>1.group by：对map端发送过来的数据进行分组并进行计算。</p>
<p>2.select：最后过滤列用于输出结果</p>
<p>3.limit排序后进行结果输出到HDFS文件</p>
</li>
</ul>
<p>所以通过上面的例子我们可以看到，在进行selectt之后我们会形成一张表，在这张表当中做分组排序这些操作。</p>
<h3 id="hive-查看分区表的分区"><a href="#hive-查看分区表的分区" class="headerlink" title="hive 查看分区表的分区"></a>hive 查看分区表的分区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive -e 'show partitions table_name'</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>二分搜索真的那么简单吗？</title>
    <url>/2019/12/17/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>二分搜索可以认为是一种最简单，最常用的一种算法，这种搜索方法的前提是，数组<strong>有序</strong>。</p>
<p>有序并不是绝对意义上的有序，比如Leetcode中的搜索旋转数组，其基本思想也是通过二分来实现的，而那道题给的数组就是在有序的基础上进行了一次旋转</p>
<p>虽然整体的结构非常简单，但是其中很多细节问题，针对不同的场景就会需要不同的处理。而这些也是我们最头疼的，比如说，循环终止条件到底写<code>left&lt;right</code>还是<code>left&lt;=right</code>，缩小搜索范围的时候到底写<code>left=mid+1</code>还是写<code>left=mid</code>…等等问题</p>
<h3 id="基本二分搜索"><a href="#基本二分搜索" class="headerlink" title="基本二分搜索"></a>基本二分搜索</h3><p>基本的二分法是有框架的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">  	<span class="comment"># 初始化</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">      	mid = left + (right-left)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">          	<span class="comment"># 中间值 == target</span></span><br><span class="line">            <span class="keyword">return</span>  mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">          	<span class="comment"># 中间值小于target</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">          	<span class="comment"># 中间值大于target</span></span><br><span class="line">          	right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>这里有一个很重要的概念<strong>搜索区域</strong></p>
<p>我们初始化 <code>left=0,right=n-1</code>， 那么对应的搜索区域也就是<code>[0,n-1],左右闭区间</code>，当我们的nums[mid]不是target时，我们需要缩减搜索区域，缩减后的区域仍然是闭区间。<code>[mid+1,right]</code> or <code>[left,mid-1]</code>仍然都是闭区间的，这样我们就可以很好的理解二分的循环退出条件是 <code>left&gt;right,即left=right+1</code>,写成区间的形式就是 <code>[right + 1, right]</code>，可见这时候搜索区间为空，因为没有数字既大于等于 right+1位置的数，还要小于right位置的数，所以这时候 while 循环终止是正确的，退出循环。</p>
<p>while(left &lt; right) 的终止条件是 left == right，即left和right相同，写成区间的形式就是 [right, right]也就是nums[right]这个数，这时候搜索区间非空，但此时 while 循环终止了。也就是说这区间 num[right] 数本身被漏掉了，没有被搜索到，如果这时候直接返回 -1 就是错误的。</p>
<h3 id="寻找最左侧的二分查找"><a href="#寻找最左侧的二分查找" class="headerlink" title="寻找最左侧的二分查找"></a>寻找最左侧的二分查找</h3><p>这个的背景就是，我给出一个数组，我要查找的数在数组中是重复的，我需要返回最左侧的数组下标。即</p>
<blockquote>
<p>nums=[1,2,3,3,3,3,4],target=3,返回下标应该是2</p>
</blockquote>
<p><strong>注：感觉自己也不能说为啥这么做，感觉刚像是这么做了，然后进行解释</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findfirst</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">if</span> left == len(nums):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p>还是<strong>搜索区域</strong>的概念，先看下我们此时的搜索区域是个什么。left=0,right = n，那么搜索区域也就是<code>[left,right)</code>左闭右开区间，所以对应的循环跳出条件也就是<code>left==right</code>时候会跳出，此时搜索区域也就是<code>[right,right)</code>确实是空的。</p>
<p>然后我们要找的是target的左边界，所以会不断收缩右边界，那么也就有了，当<code>nums[mid]==target</code>时候，没有直接返回，而是<code>right=mid</code>。</p>
<p>再看下区间收缩过程，原本的为<code>[left,right)</code>，经过mid切分后，我们的缩小过程是<code>left=mid+1 or right = mid</code>，此时切分的区域为：<code>[left,mid)区域和[mid+1,right]区域</code>这样也确保了所切分区域跟之前不会发生重叠，且不会有遗漏。</p>
<p>最最最后！这样只是有target的时候是没问题的，但是如果数组中不含target，最终返回的会是首元素。所以还需要进行判断。</p>
<h3 id="寻找最右侧的二分查找"><a href="#寻找最右侧的二分查找" class="headerlink" title="寻找最右侧的二分查找"></a>寻找最右侧的二分查找</h3><h3 id="可参考题目"><a href="#可参考题目" class="headerlink" title="可参考题目"></a>可参考题目</h3><p>使用场景</p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>一些比较好的文章</title>
    <url>/2019/12/17/%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>&lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt;<br><!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! --></p>
<p><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"></p>
<p><TITLE>一些比较好的文章——算法工程师</TITLE></p>
<p><H1>Bookmarks</H1></p>
<p><DL><p>
    <DT><H3 ADD_DATE="0" LAST_MODIFIED="0" PERSONAL_TOOLBAR_FOLDER="true">收藏栏</H3>
        <DT><H3 ADD_DATE="1529200449" LAST_MODIFIED="1576590963">微信文章</H3>
        <DL><p>
            <DT><H3 ADD_DATE="1575196586" LAST_MODIFIED="1575215324">机器学习</H3>
            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU5Mjc4MjIzOA==&mid=2247487458&idx=2&sn=0821894f0873498965da3a3a7c804b61&chksm=fe1b3913c96cb00581b3936a5b529e1b89c67b03c780cec05946d7f48797bacf3baadafc4a87&mpshare=1&&srcid=&sharer_sharetime=1574656521699&sharer_shareid=fabaad189d906f15f7285708003fb5a1&from=timeline&scene=2&subscene=1&clicktime=1574657130&enterid=1574657130#rd" target="_blank" rel="noopener" ADD_DATE="1575207302" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深入理解网红算法XGBoost​</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&mid=2650411869&idx=3&sn=07f296eea77340fe9fe9e3414d89412f&chksm=becd950789ba1c1149fa4ad4248c199d067cbcf1b7a2fae0e46fe2b2d1168a1e2523e6eb153f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207431" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文详尽系列之K-means算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&mid=2650411867&idx=3&sn=5522d62b74a3ed6fb77b0e715e55c214&chksm=becd950189ba1c17509a8467ef24e7942f6ce1a9ee0f70e0c3e9bddbcc04e69d31015a23532e&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207445" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文详尽系列之EM算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247487550&idx=1&sn=2626998e443eb5c9052abc13fd3b8c7e&chksm=e870c173df0748654e149794d37e578fb7faa2e2ef9e9fc6528ea10c17d76d90083a44d48059&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207456" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文详尽系列之CatBoost</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247487494&idx=1&sn=01cc822880d5ded2a3685bf88d9fe25a&chksm=e870c14bdf07485ded9589fc0f0533e4bb0cc66cb0ed849a51a3c78df7439be6acfb6397216d&mpshare=1&scene=1&srcid=&sharer_sharetime=1574079741216&sharer_shareid=8724c7983f20914ec3c0c086bba89335#rd" target="_blank" rel="noopener" ADD_DATE="1575208599" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文详尽系列之逻辑回归</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU3OTQzNTU2OA==&mid=2247485640&idx=1&sn=e3582b64096c9a221db4ab0f4f630810&chksm=fd676597ca10ec8198aff93e776979b329d8745d863b49f440ed1466c6398cf875bdd916b8e8&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212311" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">30分钟学会LightGBM</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485568&idx=1&sn=af15a42e91f2d19bf3909a9ae3e8a9bf&chksm=e9d01841dea79157be56b13da422ca17ce702a1673a93928f8dc8d76ab5b1555ae18d938157d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212348" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">终于有人把XGBoost 和 LightGBM 讲明白了，项目中最主流的集成算法！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486130&idx=3&sn=877e4c3ae03cd08a1c08c51181b330ba&chksm=9704810ea073081818fe2de3dae5bbc1010a0eec0dec4b04252a71ae2ee81083c9217c9c7a92&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212360" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最常用的决策树算法（一）：ID3、C4.5、CART</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486130&idx=4&sn=d24c394dd54f0b6c031b777f2909313a&chksm=9704810ea0730818a3a1d21c3f389440eb1e47050520475afda1dc888b8d5039aa2e83bea6d2&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212379" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最常用的决策树算法（二）Random Forest、Adaboost、GBDT 算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486130&idx=5&sn=cc0665891f36544479b7884d098412b5&chksm=9704810ea07308180c56ea3b55481abcd99d270211ea5bc2e4566fa6be8b71a7541931a01f20&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212387" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最常用的决策树算法（三）：XGBoost 和 LightGBM</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486989&idx=2&sn=f582435c65a20e5c5c0978a68bc38a28&chksm=e870df40df0756563fa00bf776852bd2d635493a25a077a7e031c759639bbdd6cf6d6ae1f91b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212736" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">极端类别不平衡数据下的分类问题研究综述，终于有人讲全了！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247487642&idx=1&sn=fc54fe96e68791a9ef33626c4f12e518&chksm=fb39b591cc4e3c872a7e2abb77ffaaab831318f12e8146cdaddb820364a8cc5cd0b9f925bb29&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212756" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">干货 | 对数线性模型之 Logistic 回归、SoftMax 回归和最大熵模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486796&idx=1&sn=08add8f76894f4f39fa95d78876254fb&chksm=e870dc01df075517152e13d86312fcc25ed874669f3cddd6bded97eb1b4783114a792a90ee7f&mpshare=1&scene=1&srcid=&sharer_sharetime=1572786925811&sharer_shareid=8724c7983f20914ec3c0c086bba89335#rd" target="_blank" rel="noopener" ADD_DATE="1575212791" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最常见核心的决策树算法—ID3、C4.5、CART（非常详细）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485541&idx=1&sn=b914a4ba2250597a4bc48f45401b0c45&chksm=e9d018a4dea791b20ce2a6752a2f4bb2ce222713d7cade58a40974a3ddd78e78adc53a73ff86&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212814" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习中的 7 大损失函数实战总结（附Python演练）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU3OTQzNTU2OA==&mid=2247485589&idx=1&sn=1690aee572191e1af0364fcb0f71c07c&chksm=fd6765caca10ecdc15dd1c609c89c4f0e09d4a6d47ce7c074f9ec77506e1ce8163eea53a1208&mpshare=1&scene=1&srcid=&sharer_sharetime=1572176345349&sharer_shareid=808295d573831eb57288f1fc0ad3ac69#rd" target="_blank" rel="noopener" ADD_DATE="1575213372" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">20分钟学会DBSCAN聚类算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAxMDk0OTMwOA==&mid=2247483716&idx=2&sn=3526f0e5034d692aeddcafba12b43948&chksm=9b49c697ac3e4f817c96f47cac20c4c90f9426957c930bdfc84d50e391f8652585f2a4ea013c&mpshare=1&scene=1&srcid=&sharer_sharetime=1572149544623&sharer_shareid=7d8f204d5d176257ab84cbc58463d2f6#rd" target="_blank" rel="noopener" ADD_DATE="1575213384" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习算法之LR</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610691&idx=1&sn=cb086414137170b210a1374c9dcb323c&chksm=f1296aa4c65ee3b2ecc25b91e338370f51ce5a702d7d25f423e84c49737d9b03b70c7e669881&mpshare=1&scene=24&srcid=&sharer_sharetime=1572059307308&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213533" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐收藏 | 决策树、随机森林、bagging、boosting、Adaboost、GBDT、XGBoost总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485444&idx=2&sn=b84999e79ea8dbdb6a5b55a317cbecaa&chksm=e9d018c5dea791d39d73b2fec353fe9ba86bb9b6e02e5ae1bce9504d9695b0a22096f7d068d7&mpshare=1&scene=24&srcid=&sharer_sharetime=1571654574645&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213791" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">详解机器学习中的熵、条件熵、相对熵、交叉熵</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494362&idx=1&sn=46e73b1bff8beb40afba33fb12b4dce5&chksm=fbd758b6cca0d1a0ca1b2d0a2c115c5b891624975bdd16137706eb4aafdc550ac9a20809613b&mpshare=1&scene=24&srcid=1012P2mw5CsbzaW8tDPIK9LY&sharer_sharetime=1570842866673&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214199" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习评估指标 AUC 综述</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU5MjEwMTE2OQ==&mid=2247488888&idx=3&sn=44002e20e73961bc0038be44d6a63f83&chksm=fe25bf26c9523630067fd43a349699dd20ff8e73a5d65848d7577344abfb1bfb844ce5936950&mpshare=1&scene=24&srcid=&sharer_sharetime=1570353016861&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214371" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">不足20行Python代码，高效实现K-means均值聚类算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486257&idx=1&sn=6f04234257b6b08ae9b9b4752f6178b1&chksm=e870da7cdf07536a484a225e50c525ce33f89f37380857d2c0cad6bd1404229c4bda9fbefd67&mpshare=1&scene=1&srcid=&sharer_sharetime=1570014608667&sharer_shareid=8724c7983f20914ec3c0c086bba89335#rd" target="_blank" rel="noopener" ADD_DATE="1575214544" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习领域必知必会的12种概率分布（附Python代码实现）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247508566&idx=2&sn=0844ce062822be67386d35e9e95a8e02&chksm=e99e91afdee918b951ba380de7dffa5af051c272b801f2c2cab41c115324e94550e4f940063b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214563" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">学点基本功：机器学习常用损失函数小结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247490380&idx=2&sn=31031b66fe7df26dfb31ea7c04b06a9c&chksm=eb7c3687dc0bbf9107db656191b716d66bdc5e7d7a806d74d084a7df24b324098a9264babdc4&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214713" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">先验分布与后验分布，认真看看这篇</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486101&idx=1&sn=53d7d6b37f2c90a288d6b365af33761e&chksm=e870dbd8df0752ce7fe83cef50f7541bda1ae888e2256776654f36c81dd1524316cb62d81dc0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214733" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">XGBoost超详细推导，终于有人讲明白了！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247490204&idx=1&sn=5a7e3d307639db60f7174530d09e922e&chksm=eb7c3757dc0bbe41a088a02ab1736d941449a3aa4ae82583a90fb6b070cef6034e9c81564b1d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214936" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">模型评估指标AUC和ROC，这是我看到的最透彻的讲解</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750545&idx=1&sn=6ee9a126932a20460d963261515a75c0&chksm=bd1259dc8a65d0ca843b9862020a121a595ab9547353cff217ddc46da933ec0633b34229189c&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215154" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">XGBoost缺失值引发的问题及其深度分析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247486980&idx=1&sn=413db8b20d19ef22bfbce05ecd0e0ece&chksm=fb39ab0fcc4e22198067163a173a6c49275e747559711bb823fae3c8f945dcf2147df23da427&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener" ADD_DATE="1575215324" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">DBSCAN聚类算法原理总结</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196593" LAST_MODIFIED="1575868321">深度学习</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484166&idx=1&sn=52017f26cf6ab9e10cd4deb66ac815f1&chksm=fc92b9b0cbe530a65829b6c2d84fb4d701e210c045d625d18ecc5ac36824e683810f485bc2a8&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208575" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">残差网络解决了什么，为什么有效？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247487710&idx=2&sn=7760bde74bc02a6203a07bc750c98345&chksm=fb39b5d5cc4e3cc3e42063c90942daf8faaf1c688f4eed3a5b227f48348f3feac6f7a7b7945f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575210080" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">三层神经网络</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247487139&idx=1&sn=256eb21930ff9c331551f945eee9d5ef&chksm=e870dfeedf0756f89c6f633ec54c82adff8df0ec23b75017553b7758253463a7ebdaa3567808&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575210139" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">矩阵求导了</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485487&idx=1&sn=1e5e79062218b1748b05a7a0235df7da&chksm=e9d018eedea791f85dafeedc4989ba37b4bf3ca2ef12bba1d4b6a674b9d5fcd140d3aea251f7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213443" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">详细解读LSTM与GRU单元的各个公式和区别</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610653&idx=1&sn=e8d57af2b44d4f7b12581b136a4b8ef4&chksm=f1296afac65ee3ecff858596e283e0f121b11206a0be47a333458c2f2b587ac9b89793b21ba6&mpshare=1&scene=24&srcid=&sharer_sharetime=1572059339433&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213516" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐收藏 | Dropout、梯度消失/爆炸、Adam优化算法，神经网络优化算法看这一篇就够了</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484021&idx=1&sn=3d5738889aefa9e5969112a1917458e4&chksm=fc92b8c3cbe531d522e4514f8e9b8ee0b0fd6fa4d1d24758445af1dd898a4aace844c0ecd0a0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213600" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">走马观花Google TF-Ranking的源代码</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU4NTY4Mzg1Mw==&mid=2247485885&idx=1&sn=9371ab42ae8f8383e390ee7281feff90&chksm=fd878f5fcaf006491642eb4480a551e0aee4feecade6773ae4940087a686fd062cb7e56c7a94&mpshare=1&scene=1&srcid=&sharer_sharetime=1571841604558&sharer_shareid=ea858e8c591aa98c750152f703babf33#rd" target="_blank" rel="noopener" ADD_DATE="1575213622" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深入剖析深度学习中Batch Size大小对训练过程的影响</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3OTAyMjcyMw==&mid=2247484686&idx=1&sn=d40a7ea6fe88ebdcf95e429ff22ccc8d&chksm=cf0b82e2f87c0bf49b83818fc9b1e15f6ccc84b69f19c9098abc7677135f8fc50c2d5bf40857&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213893" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【DL】一文读懂深度学习中的Normalization模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486527&idx=1&sn=712ba2518092c53ba4d3db3dfdfd477d&chksm=e870dd72df075464acc72b6b8fee0823c60500754a5819f8c856ccbcb1e00a66d3ae7266f6a8&mpshare=1&scene=1&srcid=&sharer_sharetime=1571277975785&sharer_shareid=8724c7983f20914ec3c0c086bba89335#rd" target="_blank" rel="noopener" ADD_DATE="1575213901" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">如何通俗易懂地解释卷积？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487474&idx=2&sn=d46c6c70345a894564c917d727bedb38&chksm=eb501b61dc279277e9f42083f1d2723b7e5e7614307231356298e2bcebb462458535af147fea&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213924" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Multi-task Learning(Review)多任务学习概述</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&mid=2247500269&idx=1&sn=067b36f177fa97124691aacec3ffca3e&chksm=96ea1e6da19d977b88de33f3e8efe21d1660076b45d9aa32dcf0b60b66d4cf2fb998054f09cd&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214133" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">BN究竟起了什么作用？一个闭门造车的分析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247508784&idx=5&sn=b8f5466969507c44739362ac3133e907&chksm=e99e90c9dee919df986b51d236544443557f09bfee7c76c3d5ce6e7b870f301a8065e8df5e4a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214217" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">TensorFlow中的计算图</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494208&idx=1&sn=50a940f4ce6093cd6c75f84e6c8efd59&chksm=fbd7582ccca0d13a270878d4aeeda8de15cc4be694b86185a95a74fee4aa9ae90efe87fe1bad&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214680" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度度量学习中的损失函数</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247486989&idx=2&sn=29ccf3cebfb860e0286936e50f519f02&chksm=eb501a9edc279388b75babd25b68687883ba998d5470c6db745a11a1268c9d2efcf8e51523d0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215162" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">BN、LN、IN、GN、SN归一化</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTU3Njg4Mw==&mid=2247484505&idx=1&sn=ba3bd929b0531e6195cbfd198d5030a4&chksm=fbd37f05cca4f613a936c30c4baf76dbb949bbe153f3f5f5420035c1394fbab18b3de2dc773a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215219" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Tensorflow常用函数使用说明及实例简记</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247487087&idx=1&sn=52dbf276829ff5215b4005919fe8124c&chksm=fb39ab64cc4e2272e3842afaeea927a93df00e345be76d96981440c94d196ab9679593707515&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener" ADD_DATE="1575215255" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文彻底搞懂BP算法：原理推导+数据演示+项目实战（上篇）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247487859&idx=1&sn=44a5eb7c14d5b8d5a45d4727b14d09f5&chksm=fb39b478cc4e3d6eefc5a9493b94833c2518878230da56ee306b85714a631c150b755a51cda0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868321" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【CNN】很详细的讲解什么以及为什么是卷积（Convolution）！</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196597" LAST_MODIFIED="1575550735">面试</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487709&idx=2&sn=b0a0e580f8e9f25c015aad9f7a714973&chksm=eb50044edc278d58134dacb2accc3182d4fcede07bd5fb90b5b0ea8c0c9439b68c64d73d8dac&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196777" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【面试题】机器学习与深度学习常见面试题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487575&idx=1&sn=b2c0c2b5986eff0a6ed67c7ee0a0498f&chksm=eb5004c4dc278dd29da3ef87c3098e97350b1e0e49520aa993014d3741c48d2ff71c9acab3f9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212430" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【干货】22道机器学习常见面试题目</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485557&idx=1&sn=94c064d486795dff139828dab350070c&chksm=e9d018b4dea791a297dee2cb6b7dd8375f4d8cdafdb4af734a74850fe0cd311db1508349b885&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212509" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">面经分享|中科院老哥的算法&amp;开发岗面经总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485536&idx=1&sn=5c5e62585a73273bf4adb5f61bb42de1&chksm=e9d018a1dea791b76a811ed4a5734634cce44d7763eeec9b734448045bd68001618e83ba9233&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212835" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">决策树算法十问及经典面试问题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzUzNjcyODU5MQ==&mid=2247483979&idx=1&sn=78c62345c189f3b6fe59cccffc190473&chksm=faf0872bcd870e3debdf522cf8be9cd17b7aa365b03bc9d3177e35f8a2129e2771185d305398&mpshare=1&scene=24&srcid=&sharer_sharetime=1572276675082&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575212951" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">SVM---这可能是最直白的推导了</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610332&idx=1&sn=5a90a97db4670ba2dbced9286474d964&chksm=f1296b3bc65ee22df8ae8027305bf35cc9be86098f16ec84be5279f65ddb31a5de5185594fa6&mpshare=1&scene=24&srcid=&sharer_sharetime=1572059430619&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213508" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">MLK | 机器学习常见算法优缺点了解一下</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485481&idx=2&sn=26c13008a1a88534e847f02af7a2f454&chksm=e9d018e8dea791fea8277a4726520549cbd5be2ca8b0be3c1fe2f688845334c0e89a7508107f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213592" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">六道腾讯、百度、美团常爱问的面试智力题和答案</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484315&idx=2&sn=3c901e2ef8b8714572a7d1b317641cfe&chksm=ce921de7f9e594f1720fe4b76d1aa9fc2512f544ead42b79ee0da319288d93749fe16a0f77f0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213744" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">超详细SVM（支持向量机）知识点，面试官会问的都在这了。。。</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485444&idx=1&sn=71b8b810f0188b5827bef43c882928e0&chksm=e9d018c5dea791d38a7a64767543594e0c2dc0d5190f32ef9f36f53b72c6182e1df351a87f24&mpshare=1&scene=24&srcid=&sharer_sharetime=1571654588338&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213757" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">机器学习与深度学习核心知识点总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIxNDgzNDg3NQ==&mid=2247486416&idx=1&sn=b8839a7df04816a6d90cdec600e25d39&chksm=97a0c004a0d74912f3909a9abffc8f614e491e02598a0888348b0a2361b900e1af304eafed89&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214148" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">互联网技术面试最后反问面试官思路及问题整理分享</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484276&idx=1&sn=ece3498bc8570bb063851767d0dac9ed&chksm=ce921d08f9e5941ec2c86ec3ab1c747dbef62478deba4480045a85ae5f80dcd5080a06caeb7f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214192" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">面试中问你 Batch Size大小对训练过程的影响</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486295&idx=2&sn=4321b94213cf559ab9f0c549c92eb3a0&chksm=e870da1adf07530ca9d226f31b9a11c962e7b157c7e11e9f5de4285d70b61c678af6db421c7e&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214386" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">算法工程师常见面试问题及相关资料汇总（附简历模板）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484237&idx=1&sn=013e2bf9499a160bd8f892c024461a7f&chksm=ce921d31f9e594272637f77386315a3b52f85b46177f6a5afc57c0a4e3858e1918242bc1e6d1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214755" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一道有悖直觉的概率题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485159&idx=1&sn=d429aac8370ca5127e1e786995d4e8ec&chksm=e9d01626dea79f30043ab80652c4a859760c1ebc0d602e58e13490bf525ad7608a9610495b3d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215082" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">珍藏版 | 20道XGBoost面试题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485018&idx=1&sn=c803466f48ba64919495f9a7d89473fb&chksm=e9d0169bdea79f8dc97b35b5892d176b0fb51de5554aaf08eba920a45e782355dea8b81bbfd0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215171" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">带答案分享-算法面试中的趣味题目</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247484667&idx=1&sn=1e3d7a7e40acf15259c12c48ce638a5b&chksm=e9d0143adea79d2cb747e253767d9646484ec74569f175ed1e5123373093120a69fe959419cd&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215288" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">带答案面经分享-L1正则&amp;L2正则</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247484647&idx=1&sn=5ee98e0d264dcc0430b8f5d9dc092975&chksm=e9d01426dea79d30a498fa36f851bce50ff46e5c85b4def39246cfbd58b21b33bf46a1fdecfd&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215295" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">带答案面经分享-面试中最常考的树模型！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU3NTgyODQ1Nw==&mid=2247486084&idx=1&sn=fcfbba75e5a3190d7b4551849cb91c73&chksm=fd1c7202ca6bfb14d419b350cbb8b01aa67ed4e3f608e421653edf1ddc64e33b4630e5927652&token=1719948296&lang=zh_CN#rd" target="_blank" rel="noopener" ADD_DATE="1575215302" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">必会的 24 道 Shell 脚本面试题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247484473&idx=2&sn=99c63abe7593924eda5537da4be4d2c6&chksm=e9d014f8dea79dee7061a9013a6de10b89d889c89129e530aaec81f614a4b2953bd66c9bfde2&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215338" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">头条广告算法面经！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247484266&idx=1&sn=b00a44332ae66a8ffd1b3a4eb387e386&chksm=e870d227df075b316a81ce8f2e2f53303247596d8d4b148263013425ce34caeb192aace84f34&mpshare=1&scene=2&srcid=0406h1C5FHq4btQnJ4f5gnFa&from=timeline#rd" target="_blank" rel="noopener" ADD_DATE="1575215369" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">决策树，逻辑回归，PCA-算法面经</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486926&idx=2&sn=48bb3547b4cebe17dc2bc06e686b9073&chksm=97048672a0730f64867ccd32d6d5d425e6cc75dc638ac2f640e128dac29bbfedf1c2ce16d325&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575550735" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AI基础：图解Transformer</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196612" LAST_MODIFIED="1575868395">推荐</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483809&idx=1&sn=e0c98e0e5e672b7401b27733f3385389&chksm=9b7c9848ac0b115ef7c71d145946c961607a2af9828f4836c1fab3421b37897c7502d2baf41a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208724" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">用户画像必会的行为偏好计算方法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495039&idx=1&sn=35905df6cd4ef33d2ce505d284d3c8ad&chksm=fbd75f13cca0d605c17bf7a8b3b899b7798a590008625fcffbf00d77c2451249bbdc086d6b18&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212747" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统中模型训练及使用流程的标准化</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484100&idx=1&sn=0d64e42e1ca702e3266e2853ab224687&chksm=fc92b872cbe53164448ff5b56a3e7d0c1265ba2f47dab481b505a81d697834607e29f7e528db&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212913" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Contextual Bandit算法在推荐系统中的实现及应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485422&idx=2&sn=cc938ca96dae791e252eaa47300276c1&chksm=e9d0172fdea79e39a5bbbe94f00560335af10a61d7c1718c6fb53432a33ec140942e88a2a407&mpshare=1&scene=24&srcid=&sharer_sharetime=1571212582482&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213961" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统数据集大列表</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485303&idx=1&sn=9116b1708be7a3d83f2d30a926dfdeb5&chksm=e9d017b6dea79ea099fbcd1743ea0f06e14851c7dc8e842703ad048b4df6fb25cf41b8af1382&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214670" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">RS Meet DL(65)-负采样点击率修正的那些事</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU3Njc2ODczNw==&mid=2247483816&idx=1&sn=c635327405456447bfe9508b53e324d3&chksm=fd0f9e26ca7817308612a7de78a987658ab5f54ab4d60fe70b0877bf77da1e3793bc27edb0f9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214725" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">透着浓浓工业风的Facebook深度学习推荐系统论文</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485950&idx=1&sn=907f9c059ee6546f6316b7d898e13692&chksm=fb5730e4cc20b9f27f0f21226774390d1f0823b48c8de303f5dd75a30ce405a09cfa72b6d5f7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214800" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统应该如何保障推荐的多样性？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485677&idx=1&sn=1b369da4c7a7f69cba3f6716b78fea50&chksm=fb5731f7cc20b8e1a0d0e2aae4fbbd03ea6560a55a2d0766086ea31ada4199a85fbd6e4f1ed7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215048" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Exact-k：组合推荐的秘密</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485723&idx=1&sn=91074cb7c7366a29353d57e6ed59e26c&chksm=fb573001cc20b91721fc715585e8269b9f27fdd27d063080ac1d0f365e5f52e39e85b6d94a3a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215061" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐算法之E&amp;E</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485737&idx=1&sn=42597b00b6db51b1e4dd8bb75cf646eb&chksm=e9d019e8dea790fe4558866a7522af34370c305922b3047c89fe90435474104e16a66d2a902b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868292" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐算法三视角</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484199&idx=1&sn=3c2d3f9aa389d4bc30192d429599822c&chksm=fc92b991cbe53087539a2f19fddf02edefe089396136d25b4684039724794bf5f217529f9dd1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868307" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">微信算法工程师带你一文了解「推荐系统」 领域的最新进展</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196617" LAST_MODIFIED="1575868280">NLP</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487713&idx=2&sn=f2a5bd681f8377b8e6fc53960d0612ae&chksm=eb500472dc278d64dd7adae709f3337a1903614a343c3564b0ea361d81d68287b024f85647de&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196754" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【干货】长文详解Attention的前世今生</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247487554&idx=1&sn=ddb75eab39c2aae578e812792974e759&chksm=e870c10fdf0748190ca29c4b80dfd10c72211527cd0784a909a68810bd158458d6ea36e0dbee&mpshare=1&scene=24&srcid=&sharer_sharetime=1574645218342&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575207317" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">All Attention You Need</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487657&idx=2&sn=b58e4343b41dd8c1f70d5ac009a89172&chksm=eb50043adc278d2cd3bf61d27205d2e4125a19a11ee42a52dee30795cc20ca933ac623021d54&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208623" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【NLP】浅谈 Transformer-based 模型中的位置表示</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&mid=2247500808&idx=1&sn=57141f4690836d60ef8ed58497bb6619&chksm=96ea1b88a19d929e4c468aebebc0dfa657e6f200ed96ef0107c81ad0540c936bcddb92811c85&mpshare=1&scene=24&srcid=&sharer_sharetime=1573467011879&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575212301" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">从三大顶会论文看百变Self-Attention</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483689&idx=1&sn=479c022f717892aeba183c16a7d13220&chksm=9b7c98c0ac0b11d6c17180ae539e63ab925831b47822b1154c471f2e57f551d8b55e4776bbf3&mpshare=1&scene=24&srcid=&sharer_sharetime=1573017209241&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575212496" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">绝对干货！NLP预训练模型：从transformer到albert</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&mid=2650411752&idx=3&sn=dc7f5cdd72da5df431c8427126f47baf&chksm=becd94b289ba1da4535ebbc168d088435eabb0c57854b6c32386f46558481562f7624d4a9ed4&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212826" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">word2Vec总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3OTAyMjcyMw==&mid=2247485068&idx=1&sn=0d0ea8d0b66cd4b553a47924e2abde3c&chksm=cf0b8160f87c0876a092e409feadaa42438f3ca55618f9f866de4de7f26a7a814f8a1314ea95&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212934" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【NLP实战】快速掌握常用的向量空间模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486615&idx=1&sn=0dfd0d28f5c23d9bf1a3e771db555026&chksm=e870dddadf0754cc044f60c685606b2c26b1112cf6662fbe4be9aef98cad683c499e2bec23ad&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213423" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【NLP】 深入浅出解析BERT原理及其表征的内容</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247490559&idx=1&sn=3648f0e755ae95cea0cebe69a16e9e19&chksm=eb7c3634dc0bbf229f95eb6372765038b1ad30de5762d4e7c1daa15f94b2f75e0a781466fa88&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214379" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">文本数据的特征提取都有哪些方法？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTU3Njg4Mw==&mid=2247484595&idx=1&sn=7e88477786bb7f96413aef4054d61d20&chksm=fbd37fefcca4f6f96f17ccfad2e5681b05c8062d4939bddd6662a19b1d20f956ad63f7af5fc1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215210" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">论文阅读 | ELMO详述</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247486779&idx=3&sn=b10aa65e9c91a2e4c23916147accb86f&chksm=eb5019a8dc2790befced65c554ed315602d6f40432425d52f7eabe26072be80ec617d028dea9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215269" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">从One-hot, Word embedding到Transformer，一步步教你理解Bert</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486914&idx=2&sn=4c7f590f7f5e3bf888c89086fac57a07&chksm=9704867ea0730f68d3efb48dc8893829cf9a877abbebaea95d22cae8d5a15d6029d5fc7e78d7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575424348" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AI基础：词嵌入基础和Word2vec</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485721&idx=2&sn=6665df59312644ed446b67d2aea0646b&chksm=e9d019d8dea790ce8a9f5d4fef8dfaf01dee86460193668c1a8c099b98058125272102d81f77&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575550761" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">特征工程|空间特征构造以及文本特征构造</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486959&idx=2&sn=030848835e4666ccc48f88815d80c31f&chksm=97048653a0730f4509dec65b08390c0bb757dde8439cfd7451b6e5368ec812ee2e0a18412845&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868280" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AI基础：一文看懂BERT</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196622" LAST_MODIFIED="1575214266">C++</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484681&idx=2&sn=6b78f50bfd040df0f8e18a00248d8c96&chksm=9f2a9d51a85d144702a30e1a1893c5c4a2f69042a5cddecdfe63628a76c53f3922d5f3077603&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196764" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">C++与C中的const关键字有何差别？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484645&idx=1&sn=0d206643984806af496863a92f597741&chksm=9f2a9cbda85d15ab36dabc022e2d79ab0ca335ac725171b434d2c011c8f9b9539a4b78176bf3&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208634" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">图说C++对象模型：对象内存布局详解</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484639&idx=1&sn=8281dc3b0175457af79662d5800df22c&chksm=9f2a9c87a85d15915d925900edb382d42c018eff0a2000e70b367a118474c749b3c222d227f6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575210124" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">函数，从编辑到编译</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484625&idx=1&sn=4c8a87c7a2176fb49d56e60b21639da6&chksm=9f2a9c89a85d159f637de77e867979a8c5e04d393f15864c38e5fb3e359e5d4156dfbf0d4173&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212523" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">C++ 异常机制分析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484573&idx=2&sn=41a7725d0364ac2a6a929ac7f8e93cc8&chksm=9f2a9cc5a85d15d3fd5eb1a46caed32f78588bf028a07386ffd8fcbf57e4f64b60b5beede311&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213810" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">细说new与malloc的10点区别</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484558&idx=1&sn=660f62f7a3ce4780f40d7f140505ba4d&chksm=9f2a9cd6a85d15c0d5a6a4d771825bcd04bb5e10907c20366678c88fb8ef9143f7a3df254838&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213884" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">C++ 顺序容器基础知识总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484517&idx=1&sn=f367201862e666d9e880f95045a730cb&chksm=9f2a9c3da85d152bb062a0bff2eb40fce6abaf18eb2e270c8ddda8ded4ee6950bf87fa641d9d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214258" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">C++ 工程师校招面试考点汇总</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA3MTU1MzMzNQ==&mid=2247484520&idx=1&sn=812669fc85ac58defc1b251908edd375&chksm=9f2a9c30a85d15268d84a04fc98ea30553bf6121403e80719b92f22312b605a228f2c88e20c9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214266" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">你们要的C++面试题答案来了--基础篇</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196627" LAST_MODIFIED="1575214580">Python</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247491008&idx=1&sn=b3ce39dd6bae639a5744027ce870b6a2&chksm=eb7c300bdc0bb91d333dc55adde999497dad9b27613308521f9577eab98417ac4f8d4c287bcf&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212448" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Python要点总结，我使用了100个小例子！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247490860&idx=1&sn=7e623b25d04fd157e24281191e373ded&chksm=eb7c30e7dc0bb9f13aa04f861ba97fb30d568d1d52d1581c83c0fc804296c2d26b90602106ea&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213614" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Python列表生成式12个小功能，你常用哪几个？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247508668&idx=3&sn=af77a77f93a3a2c7d27a573f0e5e7141&chksm=e99e9145dee918539e3f31e27223b5cf21777b77e3c9379910db5f24d03ea605d7eac64acdb9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214351" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">24式加速你的Python</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzMjY0MjE1MA==&mid=2247488340&idx=1&sn=572a046a414e830e209e8ea1c7cc92e0&chksm=e890905ddfe7194b2478fa00075469b83d997133290aef42d6c2af0db3aca1b46a6543823e11&mpshare=1&scene=1&srcid=1006yYgqNuFLOKxal8UIdw2q&sharer_sharetime=1570373954581&sharer_shareid=cca782c357f6c145b41a8f02429cfadb#rd" target="_blank" rel="noopener" ADD_DATE="1575214362" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">盘一盘 Python 系列特别篇 - 面向对象编程</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0OTU5OTI4MA==&mid=2247487279&idx=1&sn=ed65c8160af724c8fd321b7b590148e2&chksm=fbac2e70ccdba766e0cb9f38d3998f022e43890c62caaedf443def939ef5f7b20b15e0504fc1&mpshare=1&scene=24&srcid=0930GamV35ySHAnwY3HRb1Qo&sharer_sharetime=1569807689911&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214580" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">17个Python骚操作，你都Ok吗？</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196633" LAST_MODIFIED="1575215397">Java</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485808&idx=1&sn=1013253533d73450cef673aee13267ab&chksm=cea246bbf9d5cfad1c21316340a0ef1609a7457fea4113a1f8d69e8c91e7d9cd6285f5ee1490&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208654" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">新手也能看懂的线程池学习总结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247489989&idx=1&sn=76fc6b53ac9c7e9a3bf127e6ace66c3c&chksm=e9c5e074deb26962dcb2aa82df61e93847b60b106f92fa0b38f7d8cea07d12d7eb3f8cf180a5&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214949" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">面试官：线程顺序执行,这么多答案你都答不上来？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485015&idx=1&sn=5daa243c3359b88fc88b951f9d08b273&chksm=cea2499cf9d5c08a7698559a2fc27078c6b35856bc2d3588172bf64708c115d4b35d3de80cd9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215397" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">关于Java基础你不得不会的34个问题</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196644" LAST_MODIFIED="1575868271">大数据</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485651&idx=1&sn=d6938dc815abcf589884ac4c75b5b76f&chksm=e9d01812dea79104c3744ad2b8c5807e8bbc8990ed305f23bfdfd968798cd38c52aaadbdb427&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207335" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Spark学习记录|RDD分区的那些事</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1NjM1ODEyMg==&mid=2247484594&idx=1&sn=b9544db3d5a5df068932d5196e64be44&chksm=ea26a737dd512e21ed37485317f1f04dc08e3599d27177b3308a3d5d766db8809580173eb461&mpshare=1&scene=24&srcid=1028viAPbFbuPfHckHt4hBlQ&sharer_sharetime=1572192951887&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213331" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">大数据分析工程师面试集锦6-HDFS</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1NjM1ODEyMg==&mid=2247484557&idx=1&sn=c67166866a77c4ff66079a0a68d72e9c&chksm=ea26a708dd512e1ef7181fef9e1d5ac7f20b00d96f71582c2e02c3c53251b360119de5cb0912&mpshare=1&scene=24&srcid=10284EheCZe0742FhhTEEvUS&sharer_sharetime=1572192940074&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213348" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">大数据分析工程师面试集锦5--Spark面试指南</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610686&idx=1&sn=1331f4c63e66a66496cf21b07ee8bc68&chksm=f1296ad9c65ee3cfa8612043b83d150676c5cc83df7a96ab9d74648e6a5a69ad7d097d1fd4bf&mpshare=1&scene=24&srcid=&sharer_sharetime=1572059315365&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575213523" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文带你搞清楚什么是“数据倾斜”</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247484981&idx=1&sn=8c587787a049578fd483a8d4d4000553&chksm=e9d016f4dea79fe2a2757dfd004e717583bd9a592c77497c641ee762057ce29688443c0cd359&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214830" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">算法人必懂的Hive知识-四道Hive面试&amp;笔试题解析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247507755&idx=5&sn=ea10cfe7f0263b9eb87b490904b204dc&chksm=e99eecd2dee965c4767c2a253f96cd6d08724f19aeabf266a4225a560d8e55b0fef6423a3db1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215100" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">如何应对大数据分析工程师面试Spark考察，看这一篇就够了</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485921&idx=2&sn=5704ddca211870ed1ac2ca76d2441e8f&chksm=cea2462af9d5cf3ccbb346b2908e9bc05e963de329d33f1f6744d40480106cc5409e098860d1&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575868271" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最新 | 10 道 BAT 大厂海量数据面试题（附题解+方法总结）</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196648" LAST_MODIFIED="1576590745">比赛</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247486823&idx=2&sn=0da7cadbb4113e88cc75b0d2ada47078&chksm=970486dba0730fcd4cee4b318aabfe20a87738a39009e9fb6076ee6594b64745f7bf5d41dbea&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196660" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AI基础：特征工程-类别特征</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1Nzc1NjI0Nw==&mid=2247484689&idx=1&sn=0d8d986ef83e9859a413e5092bdebcad&chksm=fc31bf29cb46363fac6e567f39babae494f183955cde92fb605643898987b43a1d1480f673ab&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196673" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">科大讯飞工程机械核心部件寿命预测挑战赛冠军分享</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610972&idx=1&sn=bc8773722eefe5d9cd4f9acd910908d9&chksm=f12969bbc65ee0addd06fb4b556f9b166a46bb80b53750bccd092ad87ffd2d0dea7425c519da&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196741" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">特征工程系列：时间特征构造以及时间序列特征构造</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTA0NDEwNA==&mid=2649610948&idx=1&sn=27499a3d0b0915b7993f042888569870&chksm=f12969a3c65ee0b58343805c2af2f018f9fd97e4f7baf9250d8dafaa0339ba54baf8bad3879c&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207276" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">MLK | 一文理清集成学习知识点(Boosting&amp;Bagging)</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1Nzc1NjI0Nw==&mid=2247483848&idx=1&sn=543ed8056ebe0ecc880e132e319eaf7d&chksm=fc31bbf0cb4632e60cca70eb65d0911e45ffc1221d457651948a473057e1571275309b6c9408&mpshare=1&&srcid=0923QF77HfU9LuXb1myrYvRD&sharer_sharetime=1569246891410&sharer_shareid=c5fe03d072516208a37563362f0311b6&from=timeline&scene=2&subscene=2&clicktime=1573048853&enterid=1573048853#rd" target="_blank" rel="noopener" ADD_DATE="1575212422" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">竞赛集成CookBook</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1Nzc1NjI0Nw==&mid=2247484561&idx=1&sn=71965b0b07c5cdb1b1a2b1166a3b0396&chksm=fc31bea9cb4637bff01c4e9fcb10b6fcc0692b527dd1e2479bbbfd825299daa5b08658a4ebda&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212964" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Kaggle竞赛宝典方案汇总</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486476&idx=2&sn=61d4a37dd7c4c5e5201e5114315ce85d&chksm=e870dd41df075457b347089cf8840353305696cd6e1c876da787a0dfe476969d6766bd1d2dd7&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214181" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文简述如何使用嵌套交叉验证方法处理时序数据</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486412&idx=1&sn=170c8ae517afa3739b553bc6406b7305&chksm=e870da81df0753972a9f82d6723e71ccdd09ff02b176c49e7a474e121de5f6bad4cfac5ba3e5&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214274" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文讲解特征工程 | 经典外文PPT及中文解析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA4MTk3ODI2OA==&mid=2650342180&idx=1&sn=e82d0829e2cee371402a51d92cf9c48d&chksm=878115d7b0f69cc18971bd7514431c84a7709968a3718df7b684d6aa2ec587b8788bee2c2ac3&mpshare=1&scene=24&srcid=1001SvGXqrez5fEVzrul3ckg&sharer_sharetime=1569861140389&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214571" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">特征工程(四): 类别特征</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247486041&idx=1&sn=e64c8dbefb342db326f3860792d0e424&chksm=e870db14df07520253e15bafa78bff743b367211f783bb7d6fa18c42230fa64ac26cc55326c3&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214766" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文梳理2019年腾讯广告算法大赛冠军方案</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&mid=2247485783&idx=1&sn=aaf30d238581bed4c3f3dcbc325f4295&chksm=e870d81adf07510c2308b74ed7377706693077432cca5b740e297a5f0b64e6f74f5dbfbfa30b&mpshare=1&scene=1&srcid=&sharer_sharetime=1569166924229&sharer_shareid=f2c339398e3f2b64bd28d9acd013a411#rd" target="_blank" rel="noopener" ADD_DATE="1575214775" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">竞赛专题（四）特征工程-竞赛中的必杀技</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483936&idx=1&sn=8faf2b0fb67359265096c8193877c86e&chksm=9b7c9bc9ac0b12df822870807ab75f49135ee59b868cf5ae98ef36623698de03efd8f3ab58aa&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1576590745" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">风控特征—时间滑窗统计特征体系</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196688" LAST_MODIFIED="1575215388">数据结构与算法</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI2NjA3NTc4Ng==&mid=2652081686&idx=2&sn=efe3d60204bacd3f7aea33a433d7a37c&chksm=f17485f3c6030ce55847939b463f500712c6738725abb679eca14b463bbde3ed8466af6a75df&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196787" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">经典动态规划：高楼扔鸡蛋</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484377&idx=1&sn=3db94956969494f35e1c3035adaaecb3&chksm=ce921da5f9e594b3f3185c0d42cb6d7dabac3cbac02a8321bb05ba03cc4fd656c5e549086348&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196802" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">回溯算法详解</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485814&idx=2&sn=704cee4eaaec8fc98765899bdeec988e&chksm=cea246bdf9d5cfab168380240e9a20927930a905665b0d89e15207122f29ccc5afba0df37615&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208588" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">告别动态规划，连刷40道动规算法题，我总结了动规的套路</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0MzMxNDY5Ng==&mid=2247485710&idx=1&sn=c8a87c05323d2053413796ae4d5cb3b7&chksm=fb0c0f69cc7b867f99a524f0dc15ecab455666284d1af5209364bb137b59461c0a06d81790eb&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208702" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">谁能想到，求最值的算法还能优化？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI2NjA3NTc4Ng==&mid=2652081592&idx=2&sn=851b2558c574b43b392ce44073e85621&chksm=f174865dc6030f4b5f17618ccdd107846e9ed18d6dc4511a5de158a6382f1d61157754d39db6&mpshare=1&scene=24&srcid=&sharer_sharetime=1572918928163&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575212607" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">图解“红黑树”原理，一看就明白！</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484232&idx=1&sn=3221dd842ff10f50505bd820c1462bd6&chksm=ce921d34f9e59422efcda7fe727c318cc6bb22fe14a23e986050aa1b0e9f5531c79f73e281c6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214810" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文解决背包问题（上）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247503579&idx=5&sn=3394c2e1fc42738152f5d42e14365933&chksm=e99efd22dee97434c1f7693be116581d5f203fec9a792280f99be80a2a07e4a3d82a8883ef0b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215379" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">算法面试经常需要你手写的三个排序算法（Python语言）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484985&idx=1&sn=93343d355abf36c77a361c9931cbe2d1&chksm=fa0e69b8cd79e0ae1e6b57665a456da5f421cc92fe6934337f1eb1e18c3fd6a3c1adc8ca88c2&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215388" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">几道和「二叉树」有关的算法面试题</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196725" LAST_MODIFIED="1575213735">广告</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485696&idx=1&sn=e9d0e9ef271f6f996b0d33cf7016fc2d&chksm=e9d019c1dea790d798b13875bbced246e89d36057a5c44b2bc3a74f58dcf450ba2d9398402be&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575196730" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">计算广告系列(三)-通过单品拍卖的例子通俗理解机制设计</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&mid=2247485470&idx=1&sn=02ba16ba150743927b4a387a43a20bdc&chksm=e9d018dfdea791c9e6582ee8342a42bc961d2493575245875f76a3828a58a0336d7ea33cadd4&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213735" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">RS Meet DL(67)-计算广告中的COEC简介</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1575196701" LAST_MODIFIED="1575215195">其他</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483815&idx=1&sn=116857bdd7363a145533f8f3e4ef2faf&chksm=9b7c984eac0b1158ff08f2f796351e896c63d47b7e9b88633b8183b7afa497ff0180d802b2e0&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207492" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">让算法工程师们事半功倍的PyTorch Tricks集合</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0OTU5OTI4MA==&mid=2247487563&idx=3&sn=a77e2341461f603939fdc6da9fb59538&chksm=fbac3114ccdbb802c23522f544ce8d6019e8e42e0b02949b988ae41144d34cf2370a4d103db5&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212331" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【Git学习笔记4】关于远程仓库的必知、创建与合并分支（fast foeward模式）及解决冲突</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=Mzg3MDA3NTE1NQ==&mid=2247484334&idx=1&sn=9f59515ee62a5aede81a802de044caaf&chksm=ce921dd2f9e594c4cea350210a9dc310c9532d57e1280f301f6f07013719635f11b1b4342b2e&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213321" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最近学到的Git知识，大厂的Git机制还是很方便的</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&mid=2650865446&idx=1&sn=68c1bcc9827376b5c7f227a7b769c545&chksm=8b661863bc11917547825276507e65eaf84743327276d2cac325fd906ce4113082b1990c1923&mpshare=1&scene=1&srcid=&sharer_sharetime=1570626733972&sharer_shareid=36e02e48fe2d9ffeff241f6d8df8edf2#rd" target="_blank" rel="noopener" ADD_DATE="1575214304" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">count(1)、count(*) 与 count (列名) 的执行区别</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485532&idx=1&sn=518a99348719e8d92227a584bb413dc3&chksm=fb573146cc20b850f189670eee84ba05928e030f26eead628929b3529003813b3207e95bb671&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215038" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">电商行业，你必须掌握的9大推荐策略</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI3ODgwODA2MA==&mid=2247487106&idx=2&sn=72c66c30246b186db9b53f07756ce65f&chksm=eb501a11dc279307bbb91a732355718e4c944b4c9ac1d6a76b38e4ea276ae2ceeaaaccc791e5&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215093" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【Linux】最常用命令：简单易学，但能解决95%以上的问题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzMzMzOTI3Nw==&mid=2247484902&amp;idx=1&amp;sn=d677261fda90b67bf5eda886447a4f77&source=41#wechat_redirect" target="_blank" rel="noopener" ADD_DATE="1575215195" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">学会这21条，你离 Vim 大神就不远了！</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576153953" LAST_MODIFIED="1576590801">论文</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495222&idx=1&sn=6b5db8a1e243ea4dd8c6b02e5558e85d&chksm=fbd75c5acca0d54c56860d0b7d2e2dfb2dc703c17a2cbc821f8e85780b2ea760ebf2cdf5940a&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575210114" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">[ ICDE2020 ] SeqFM：基于多视图自注意力的动态序列感知 CTR 预测模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483881&idx=1&sn=6532870e6ad5b85cbfffa8cba69a9d0b&chksm=fc92bb5fcbe53249422b416577ad07a04eaa7c291a9aa4660b579ee84bd4ae1273852d91d74d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214001" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">效果炸裂，阿里推出深度树匹配召回升级版JTM</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483918&idx=1&sn=650e788a11bb64b55db62185176e38ca&chksm=fc92b8b8cbe531ae7b094ab18eda9250fbac0c83b54d66697905fc17b5919379d9ccb694f367&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213876" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">AutoInt:使用Multi-head Self-Attention进行自动特征学习的CTR模型</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483724&idx=1&sn=03c24d7661e7a5c3fab6b84f12794111&chksm=fc92bbfacbe532ecc25c654185d721589c294b3136c65f26f68351aea8991efb81d51bde9d72&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215231" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Google最新论文，首次引入自动网络设计高效解决大规模深度推荐模型的特征嵌入问题</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483793&idx=1&sn=3d828d00f99e294640b77a748bc14cbf&chksm=fc92bb27cbe53231e7d4ea6c6a20e4d6f70587712cb6808286ee75c484b5867096dd7cb41195&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214283" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度CTR预估新积木ONN模型源码阅读与调参经验</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484197&idx=1&sn=20e749add71bf9fab9415c0dec69b27d&chksm=fc92b993cbe530851e37e09dc226bae1deaa163951c64ff5cd74c0d969c5878e5071c519d051&mpshare=1&scene=24&srcid=&sharer_sharetime=1575627524712&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575868395" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度推荐系统之序列化建模2019最新进展</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzMzYwNzY2NQ==&mid=2247484861&idx=1&sn=6203fa9537091b21a83679efc4595dd3&chksm=e8825d23dff5d4352a6e03ba7e77d427a0f8d3614dd45202c117e24075d96a596819df7ce3de&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215121" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">R&amp;S[18] | SIGIR2018：深度学习匹配在搜索与推荐中的应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&mid=2247501800&idx=1&sn=faa374bddb4237ae2ecfce06fb1d03d8&chksm=96ea1868a19d917e0674d17e70eea31eed76bdbb7b186e5be85b716b4a147b5cddedc5cd20e7&mpshare=1&scene=1&srcid=&sharer_sharetime=1576141140885&sharer_shareid=870ce2544b04a88b189d627d7134fc8f#rd" target="_blank" rel="noopener" ADD_DATE="1576154199" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">2019年，异质图神经网络领域有哪些值得读的顶会论文？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247496007&idx=1&sn=c0e0d603533c69a66d8ff93b54396ebd&chksm=fbd7432bcca0ca3de60cdde385c995f5e99dc79f34e254ae8eef579301017a727aa47ec5e20f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1576590801" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">用户行为序列推荐模型</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576153971" LAST_MODIFIED="1576154167">召回</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483810&idx=1&sn=0b15e1f4ff020fd746f11085995aade0&chksm=9b7c984bac0b115d59ad5ac44e86b88c9d4e2caa0468dfc63159241118e3a72663f598c87d2c&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208553" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【Graph Embedding】node2vec-算法原理，实现和应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483667&idx=1&sn=2798a11dce733bd088f25536774811f1&chksm=9b7c98faac0b11ecba756a74da563ba05de0c3bef5c019d313bd920d0598ebb2a33ce1a3527a&mpshare=1&scene=1&srcid=&sharer_sharetime=1572581142370&sharer_shareid=75450ee52aab1158cd74c57711ea459c#rd" target="_blank" rel="noopener" ADD_DATE="1575212888" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【Graph Embedding】DeepWalk算法原理，实现和应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483722&idx=1&sn=2f27f0a5e9d85a669faad20d522bc61f&chksm=9b7c98a3ac0b11b56c170e143b190e740b76a69bdde9ae37d0f1b5438a55bafcd8173d9f185f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212409" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【GraphEmbedding】LINE：算法原理，实现和应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247483886&idx=1&sn=272ec1f7aa48c58d260830ad70767892&chksm=fc92bb58cbe5324eb7763e57e6f607bc5464c1cf7ce2dfcd116c49259ad0d84471d198242e63&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213988" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">最新！五大顶会2019必读的Graph Embedding相关的论文</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIwODI2NDkxNQ==&mid=2247485824&idx=3&sn=42278b4d73f3fe47bffddc984acfec70&chksm=9704823ca0730b2aa8f8b8b1097e7e2961e8af03d630058792eb8ca0ea6645f16d4bd414c25d&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212802" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">员外带你读论文：LINE: Large-scale Information Network Embedding</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247507146&idx=3&sn=c52992bbe6e3773d556664c01bf261c9&chksm=e99eef33dee966255ee6074c8b1a49c6834d66c012520e78d0b3197b38fed8b4e158806d6414&mpshare=1&scene=24&srcid=08232rJhcvJCZfvR8Tp6SMaH&sharer_sharetime=1566914149500&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575215110" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">从原理到落地，七大维度读懂协同过滤推荐算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247507514&idx=3&sn=ca17da426a894954b506a5a45c53bd57&chksm=e99eedc3dee964d533bff4b79416462827b54099ef47f5d8c50f12efca05c036c22dd9a6d25b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215143" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">从原理到落地，七大维度详解矩阵分解推荐算法</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NDgwNzIwMQ==&mid=2247483949&idx=1&sn=a4e0d7338774ce29b874ab3a543c45dd&chksm=fb77c263cc004b75a2c670113ed61bce4caa22c7a4d6b3ed5cc8294f9164a2b801619c66911f&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215280" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统从零单排系列(七)--Airbnb实时个性化推荐之Embedding真的好用吗？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486205&idx=1&sn=a49655032683d555793de48ee864791c&chksm=fb5733e7cc20baf12a7d644b7d2e91bf7ee883a486c528002e7a4088173f6c460c787c07e77e&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213866" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【回顾】推荐系统中基于深度学习的混合协同过滤模型</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576153978" LAST_MODIFIED="1576154127">排序</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&mid=2650411766&idx=2&sn=b589d5c3c5303cc0748422aa374b6c75&chksm=becd94ac89ba1dba78aaa5322d30d49bd044c8a7096afd8f66056b746db1426e9be66dbd29c2&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212464" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度CTR预估模型的演化之路2019最新进展</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483683&idx=1&sn=109758c46d326e138ecffeb6b7439ac1&chksm=9b7c98caac0b11dc928a04cb3e534c18be0698f23f46f7a64e3dca172e737fcb336abe2fe83d&mpshare=1&scene=1&srcid=&sharer_sharetime=1572656095251&sharer_shareid=75450ee52aab1158cd74c57711ea459c#rd" target="_blank" rel="noopener" ADD_DATE="1575212849" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【CTR预估】CTR模型如何加入稠密连续型和序列型特征？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485341&idx=1&sn=79291b284b8456810df579ea41a8208d&chksm=fb573e87cc20b7913bc15cfe69eddac0d1de79e84b5d8cdf195438a96e19d13777cf06359367&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214997" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统之排序</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzAwNzQ1ODk1MA==&mid=2247483892&idx=1&sn=b1d7a75eca9796076e67efc6bee0e115&chksm=9b7c981dac0b110b7bc61b6ed625d82f73cc372b5624efbc9a2cde1704799828c1415b5d87d7&mpshare=1&&srcid=&sharer_sharetime=1575864732287&sharer_shareid=52006a0d19edf83d2b8be98f4d8fe935&from=timeline&scene=2&subscene=1&clicktime=1575864843&enterid=1575864843#rd" target="_blank" rel="noopener" ADD_DATE="1575868263" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Learning to rank基本算法小结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247484862&idx=1&sn=742e078ed875922a12a881ec87b5f624&chksm=fb573ca4cc20b5b2ec388d5d5ab4a4ea33fb72d447b664ad2bb2c896103c6c76ca6484feb705&mpshare=1&scene=24&srcid=&sharer_sharetime=1568428307082&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214959" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一文看懂 FM ( Factorization Machine ) 模型的各种变式</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576154244" LAST_MODIFIED="1576154250">搜索</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU5ODUxNzEyNA==&mid=2247485100&idx=1&sn=4c0b4e6a887df2a1496668127d6d1214&chksm=fe43b247c9343b51d1c9127a31b194f6476f2cfe41cbda63f92c74d26e80b46398e07baae291&mpshare=1&scene=1&srcid=&sharer_sharetime=1576123032213&sharer_shareid=65030b4340b230b9f1037ac3abfe34e5#rd" target="_blank" rel="noopener" ADD_DATE="1576154250" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">淘宝搜索模型如何全面实时化？首次应用于双11</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576214119" LAST_MODIFIED="1576214233">广告分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494579&idx=1&sn=b5274f98c5cfae81d1af68944d3252df&chksm=fbd759dfcca0d0c9f8ab04bebee04b0d7fd6fdd3eae87d3ef475fb26e03b402999c31621d034&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213935" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">爱奇艺效果广告的个性化探索与实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494020&idx=1&sn=df65908cdaf57d02eee8280d86d66949&chksm=fbd75be8cca0d2fe2d69d89a70eced34ba467acbf26fefe1bf40edea36a07e76406612383fd5&mpshare=1&&srcid=&sharer_sharetime=1570510270764&sharer_shareid=90667dd07c937c48cb4022a5f8a7c3b0&from=timeline&scene=2&subscene=1&clicktime=1570512805&enterid=1570512805#rd" target="_blank" rel="noopener" ADD_DATE="1575214344" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">OCPC 广告算法在凤凰新媒体的实践探索</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494094&idx=1&sn=4c32130746752039fba45a5ba6b7eedb&chksm=fbd75ba2cca0d2b45533b2464418873e366f1e733a5b92d8ad1a754d2390334e5443f8fa60b3&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214699" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">阿里妈妈：品牌广告中的 NLP 算法实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485921&idx=1&sn=833bef050627a5689162e1f5a9b40393&chksm=fb5730fbcc20b9edd3640c3fb808028f746b05f98691b4ce9d699a3551dc0dba969e5f9ed1d6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214822" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">微博广告推荐策略工程架构体系演进</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576214149" LAST_MODIFIED="1576214260">其他分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486603&idx=1&sn=0a825a889fe2014c584cbf3d7fe62975&chksm=fb573591cc20bc8794d005aae0a3f7be50f3d02fa527b9f546576ca57087262406dde6fd2957&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207476" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【推荐实践】微博在线机器学习和深度学习实践（文末附PPT下载链接）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247493934&idx=2&sn=6d4dadb2c34ac0cff635e52a5bf96be3&chksm=fbd75b42cca0d2545065580ebb6a9c7796cefb90b718b1f25c78c5b0a6d3d0c2eb1aa668777b&mpshare=1&scene=2&srcid=&sharer_sharetime=1569288966045&sharer_shareid=90667dd07c937c48cb4022a5f8a7c3b0&from=timeline&clicktime=1569289112#rd" target="_blank" rel="noopener" ADD_DATE="1575214747" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">电商多目标优化小结</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247486585&idx=1&sn=d7cb9680e694b78953912e2163dcf986&chksm=e9293176de5eb8601cb50bc920873b9a953109e1e37bd4c2633d62bcfb75aed71e6803af0488&mpshare=1&scene=24&srcid=0917IPhiZz6f3LDk4kI8ekRT&sharer_sharetime=1568682799879&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214850" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">一天造出10亿个淘宝首页，阿里工程师如何实现？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485187&idx=1&sn=1e819a18fb0503e579c0fc6e116d46d9&chksm=fb573e19cc20b70fd03d37b81027c48bb7009854500b5b67755b866272faf7b0efb11a08344e&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556747382&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214865" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度学习在 Airbnb 中的探索与应用（附论文下载链接）</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485219&idx=1&sn=d16340f84ddecdb16858d7fcb67c4c80&chksm=fb573e39cc20b72fdb5ca437cbc8daa4c08638534105d21d4874ef8db74808c2001c2480947f&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556689824&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214885" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">相关性特征在图片搜索中的实践</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576590855" LAST_MODIFIED="1576590980">电商推荐分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486297&idx=1&sn=dc5128d9e852e5731c86b677c7208f84&chksm=fb573243cc20bb558b35ad717f9f78d94973c4427b7bb02701ac9873f325123a3cb922a7acda&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213433" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">大众点评信息流推荐中基于文本生成的创意优化实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484034&idx=1&sn=22fde92cc742c5fbb7874c4fc25b3169&chksm=fc92b834cbe53122459ccc417388e7b0340524196ef805936de00ec019e1f4b6d8977bb77ff9&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213364" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">蘑菇街内容信息流排序实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486348&idx=1&sn=1fe7605a7d2483811f075a3d01c824bd&chksm=fb573296cc20bb80d8efd1fd6f70f37dd495cacec856b6b428ebba39c65accde0e406a549d31&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212926" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【推荐实践】强化学习在美团“猜你喜欢”的实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247484612&idx=1&sn=9526d939740fd18aefe63ad13a472c6b&chksm=fb573ddecc20b4c8a6348fea0ba6d8c8e2763922afd917a77db1a415f247ebbc9686ea584e91&mpshare=1&scene=24&srcid=&sharer_sharetime=1570802964071&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214208" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">2.5亿用户的美团智能推荐系统是如何构建的</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485192&idx=1&sn=21661e2dcf00b661b9077b4670f39a79&chksm=fb573e12cc20b704589c38ab09a988fa73f9b4e92f390ff7eead1aa6a8dd8e76cda8b7c6be21&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556728663&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214874" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">电商推荐系统及思考</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485407&idx=1&sn=fba5509bcb018eca5c4dacd409b627c4&chksm=fb573ec5cc20b7d39ef7d1c2383928f7f16d0c4d9ff248f450da10968b22df1c5b9d2669df5b&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556606971&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214908" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">京东电商推荐系统实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485196&idx=1&sn=a1d7621136291e23da4a0bd5c0aa62bb&chksm=fb573e16cc20b7002cecb3ae5acd7340505d4e54ecbf8c3bf22a0595b6465dbefb5593ac8f1b&mpshare=1&scene=24&srcid=&sharer_sharetime=1568428219564&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214969" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【推荐应用】Embedding技术在民宿推荐中的应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzI0NTE4NjA0OQ==&mid=2658362441&idx=1&sn=f5411e0ebd33baed8264ed7320f77e41&chksm=f2d5af27c5a22631b1fcda81a7853a354be45cb75ac842a24d062107b71e3fd2ef119610c01c&mpshare=1&scene=1&srcid=&sharer_sharetime=1576509433838&sharer_shareid=65030b4340b230b9f1037ac3abfe34e5#rd" target="_blank" rel="noopener" ADD_DATE="1576590825" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">解密淘宝推荐实战，打造 “比你还懂你” 的个性化APP</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576590866" LAST_MODIFIED="1576590983">视频、新闻分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247486975&idx=1&sn=8c5bacd451b8d08a3517dc691872f6cf&chksm=fbd4bf93cca336858770741723368e687958d3f19ff20aec614d72e2ab17fdfe68a973d278a5&mpshare=1&&srcid=&sharer_sharetime=1573370069415&sharer_shareid=03acd21ed792ec103a2d36489130b8a0&from=timeline&scene=2&subscene=1&clicktime=1573370821&enterid=1573370821#rd" target="_blank" rel="noopener" ADD_DATE="1575212322" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">「干货」YouTube 基于深度神经网络推荐系统剖析</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU2ODA0NTUyOQ==&mid=2247484131&idx=1&sn=eb8551059b248f20e96b36a566a64ae8&chksm=fc92b855cbe53143b53eabc4a0a148779a3d9ee46c1bb6921fab781adadea5ead8a33b57ef49&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212398" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Hulu视频推荐如何提升推荐中的多样性</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247486369&idx=1&sn=94c06edcbb3e94538ca99cda3362c453&chksm=fb5732bbcc20bbadf339f8a970402992e9c4cd1b9ad1485a52f03574f8195f92c45c2b840421&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212904" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">YouTube 多目标排序系统：如何推荐接下来收看的视频</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494558&idx=1&sn=10a6332147d713230d0fa4dbf9cdc897&chksm=fbd759f2cca0d0e4f5d39887a86b1d6efae13ad0540dc191fdbc8bb29120d0081a90c97b35f6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575213978" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">深度学习技术在美图个性化推荐的应用实践</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247494398&idx=1&sn=cd08a71c4a7ec9a2d81107603fc4c437&chksm=fbd75892cca0d184585075b3315fe0386d37c174995a5a4b27e02db4117a13897678dbcb52ed&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214141" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">UC 信息流推荐模型在多目标和模型优化方面的进展</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485914&idx=1&sn=98ef79659c5c0246c081e7c2c205b7f6&chksm=fb5730c0cc20b9d6684a9279037611d474df036602c1ed28d301b71306e998a26173792f8c88&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575214841" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">快看漫画个性化推荐探索与实践.pdf(附下载链接)</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247484887&idx=1&sn=238cc7643c3901ff3d45326a134ac2cf&chksm=fb573ccdcc20b5db01fa4f88c717f6d4dda21307ce4f325b7ee796c88223e1bb02ecb1a4dbda&mpshare=1&scene=24&srcid=0915EC89bqiY9QAf6dZdSrd0&sharer_sharetime=1568556193226&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214928" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">今日头条推荐系统原理</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485521&idx=1&sn=5e0ee98e2f10f1b38bc5b3168b13ff7b&chksm=fb57314bcc20b85db1b2b6948677d2e859d182090a6278bc275e0dcd28d7564a6ac39f12baca&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215020" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Hulu：视频广告系统中的推荐算法实践</A>
            </DL><p><br>            <DT><H3 ADD_DATE="1576590883" LAST_MODIFIED="1576590976">其他推荐分享</H3><br>            <DL><p>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495507&idx=1&sn=a1e0cf988d2e366be58faf1110e4d885&chksm=fbd75d3fcca0d429b33c5a49053dd99a03e603b3230e950d0109f3c9dbe7ede21e1fa2a86752&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575207287" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">RALM: 实时 Look-alike 算法在微信看一看中的应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495381&idx=1&sn=4dfd39fe16a402ffef8e32235aa36b21&chksm=fbd75cb9cca0d5af552d9958a3a08690d2767a3f0165537108231bff157fbaf28bd45760ea6b&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575208715" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">如何从 0 到 1 构建个性化推荐？</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247495109&idx=1&sn=eccf1f678affd8272ace63dfa207c23a&chksm=fbd75fa9cca0d6bfd723de5cc78631993670f99567fd3457a63187232105c854bd189acc4fe6&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575212440" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">Airbnb 基于 Embedding 技术的实时个性化推荐</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247484814&idx=1&sn=38c68015123ee1bda8dd687ae215b8f4&chksm=fb573c94cc20b582d189f9ce54b865fbf696868f1fd598b5c2105a4abc97a8e92ccf26c761d7&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556943700&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214858" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">【干货分享】深度学习新技术在搜狗搜索推荐中的深化应用</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485223&idx=1&sn=2deaad3a5b2de8058f865a6849e95f79&chksm=fb573e3dcc20b72bcc4b03e699a8b9ffc25e04bee4ad0782e12b2c297ce9af0cd255010e9578&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556668471&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214900" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">推荐系统燃料：数据那些事儿</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485485&idx=1&sn=5d8b178ecee969b0bbc9112de0416344&chksm=fb573137cc20b8215a2506ab27640cc4d27561fb2bd430b72dd6b3369ce40e1fada147bb4369&mpshare=1&scene=24&srcid=&sharer_sharetime=1568556583821&sharer_shareid=25511684309da72acf1dabc0d556d03a#rd" target="_blank" rel="noopener" ADD_DATE="1575214920" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">多维度分析：推荐效果明显的产品属性</A>
                <DT><A HREF="https://mp.weixin.qq.com/s?__biz=MzU0NjkxMDMyNQ==&mid=2247485395&idx=1&sn=8e862c796b1b25370add04f7995e8296&chksm=fb573ec9cc20b7dfaee91a2594a51ae46249d120e13646ca1ca215285bfe59c8e05ceefb62b4&scene=0&xtrack=1#rd" target="_blank" rel="noopener" ADD_DATE="1575215010" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVklEQVQ4jYWTsYsdZRTFf+fO7LxdVwW38L1dEfwjorGwEVMJgpq1sLaJnSipRJjONIqNxMo2ECMGAoENkZAuMdvaCIIWyb6nawxrkue8mbnH4s0um8pTfXzfueccvsuBQ9QEx3GDcrwzXh/vjNe5QfnE2zGuADBCGGDrytbbTr9J5xPg5wfaH5TaVejqvbfuXT4+I2qCmhxfGJ8sntJXhF4lgB6WkoNNASSQvtU/9kez92e3qQkBvPDd+A2P4gfEM+5NjALPjdMJoFBoTWSTqBCYf9TkO3ffm/2orQsbL7qqfqJkAnTq2DW+DvEh4Q0AUvchzwudcskJoKRjqsXilaCqzsZqTGhpVKpEcW7v9OwzxLWoQlGFENeWd3FOpUpamliNCVV1VpvfT36l4CV6Uisq3PoO8nU5zjj8HIBSf1v5DdYprehlt9lTKOj5TVuXNueWR0drqSSNhB8Zpz38gbQu3Bgv7CMuagL5/rBVC8kL93mQrdMWkpCcdh5k64V7IQEmwPaDsHRTlWQ7jQ0EohSSsc1SCFECYWzbqUqSuBlk+yUN/6pQGOfgoCGiDoWAw3OvUqKlSdovYm97fzfTH0cVIS2TYPLQfRgGk7bbiChjNYpMfzI9/dedoCam29Pz+bg7o0ItIlQqpKW70BIrinhaKxT82T3sP5i+O/0aiKDGgOblYoeCEeLA6V8wjW2GFHN3/jnnfN4/yJOz7dm3Q6GypEbU5Bprr3nhS+2i+3T/2f3fJ81k0+mJQqnUbG9j7y6v0x21sSafaChXGfF/uEiBhwYP+A//pT7utR8A2gAAAABJRU5ErkJggg==">腾讯手Q游戏中心的个性化推荐技术框架与实战</A>
            </DL><p><br>        &lt;/DL&gt;<p><br>    &lt;/DL&gt;<p><br>&lt;/DL&gt;<p></p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-34-在排序数组中查找第一个和最后一个位置</title>
    <url>/2019/12/17/Leetcode/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA/</url>
    <content><![CDATA[<h2 id="在排序数组中查找第一个和最后一个位置"><a href="#在排序数组中查找第一个和最后一个位置" class="headerlink" title="在排序数组中查找第一个和最后一个位置"></a>在排序数组中查找第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]<br>示例 2:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是个二分查找的变形！！！二分的框架是很简单，但是其细节问题非常致命，简单举几个例子，右边界什么时候是n什么时候是n-1，缩小范围后，什么时候是right = mid-1，什么时候是right=mid。。。。等等</p>
<p>其实这些问题都是一个最重要的概念没有搞清楚，即<strong>查找区域</strong>。</p>
<blockquote>
<p>自己还是觉得大佬的表述更加的逻辑清楚，自己讲出来就不是那么回事了</p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">二分查找算法细节详解</a></p>
</blockquote>
<p>如何界定我们的查找区域也就限制了我们一系列的操作。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findfirst</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = len(nums)</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">if</span> left == len(nums):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] != target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findlast</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = len(nums)</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[left<span class="number">-1</span>] != target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [findfirst(nums,target),findlast(nums,target)]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>京东搜索架构</title>
    <url>/2019/12/17/%E4%BA%AC%E4%B8%9C%E6%90%9C%E7%B4%A2%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="京东搜索架构"><a href="#京东搜索架构" class="headerlink" title="京东搜索架构"></a>京东搜索架构</h2><h3 id="召回过程"><a href="#召回过程" class="headerlink" title="召回过程"></a>召回过程</h3><p>分词—— 倒排索引——倒排链表</p>
<p>大量空 query  做负反馈调节</p>
<p>倒排链 没有交集的 返回空query</p>
<p>搜索意图识别、纠错、term weight</p>
<p>倒排 keyword-&gt;sku result   用于召回阶段</p>
<p>正排 skuid-&gt; 商品详情 用于粗排精排</p>
<p>召回（捞）的过程： KNN 召回（H）+个性化召回（C）</p>
<p>相关性召回</p>
<p>粗排：</p>
<p>质量、热度、品牌、个人偏好</p>
<p>25个分片 每个分片保留300个  最后保留7500个商品</p>
<p>精排：</p>
<p>入口 7500的数量</p>
<p>95%的用户 前10页  85%用户不会超过前4页  </p>
<p>GMV 流水 或者 营收</p>
<p>list = 30 精排结果返回 目前支持最高30个 </p>
<p><strong>优质增量，不截断</strong></p>
<p><strong>1️⃣</strong>拼购精选、2️⃣hotscore大于50、</p>
<p>3️⃣战略单品、4️⃣医药o2o</p>
<p>手机壳</p>
<p>推荐/搜索/广告 公司流量的三驾马车</p>
<h4 id="意图理解"><a href="#意图理解" class="headerlink" title="意图理解"></a>意图理解</h4><p>query process-&gt; 运营干预 —&gt; op-web()yemian</p>
<p>意图识别，只靠单纯的pair对是实现不了的 还需要结合 用户维度的特征：时间地点画像 ，指导搜索引擎如何来返回结果</p>
<p>运营干预的理解：</p>
<blockquote>
<p>结合国家政策或者时事热点，来限制搜索意图。比如港独的产品，是如何做到下架的</p>
</blockquote>
<p>透传？</p>
<p>H-search： 深度学习 修饰词</p>
<p>C-search：个性化 search</p>
<h3 id="多次阶段——漏斗模型"><a href="#多次阶段——漏斗模型" class="headerlink" title="多次阶段——漏斗模型"></a>多次阶段——漏斗模型</h3><p>2次召回截断</p>
<p>第三次截断为粗排序 粗排结果为7500个</p>
<p>第四次精排</p>
<h3 id="工程架构"><a href="#工程架构" class="headerlink" title="工程架构"></a>工程架构</h3><p>缓存问题</p>
<blockquote>
<p>一级缓存，1分钟，针对单页，解决10%的流量</p>
<p>二级缓存，翻页缓存，应对同一用户翻页请求，缓存10页，失效1分钟；导航区缓存，包含品牌、分类、属性汇总，失效30分钟。 服务器上给用户维护了（单商品的变化，对品牌分类汇总信息的冲击不大）</p>
<p>三级缓存，</p>
</blockquote>
<h3 id="产品思维"><a href="#产品思维" class="headerlink" title="产品思维"></a>产品思维</h3><p>马太效应问题</p>
<p>爆款产品的解决：不投广告也照样top排序，所以出现爆款产品并不是一件很好的事情</p>
]]></content>
  </entry>
  <entry>
    <title>Shell 命令基础</title>
    <url>/2019/12/17/shell%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Shell命令基础"><a href="#Shell命令基础" class="headerlink" title="Shell命令基础"></a>Shell命令基础</h2><p>日常linux下工作除了基本的命令行命令之外 还需要积累一些shell 脚本的基础知识</p>
<h3 id="基本符号问题"><a href="#基本符号问题" class="headerlink" title="基本符号问题"></a>基本符号问题</h3><p>` `  ！！！不是单引号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`` 键盘右上角的符号，并不是单引号，这个用来包住命令 tmp=`echo '123'`就是将内部的命令运行结果包起来</span><br><span class="line">等价于 $() 即 tmp=$(echo '123')</span><br></pre></td></tr></table></figure>
<h3 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h3><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for((i=0;i&lt;$n;i++)); # 这样可以像C语言一样写</span><br><span class="line">do xxxxxx</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dt=$1</span><br><span class="line">if [ ! $dt ];then</span><br><span class="line">    do something</span><br><span class="line">else:</span><br><span class="line">	  do something</span><br><span class="line">	  exit 1  # 强制退出</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h4 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义一个函数</span></span><br><span class="line">test_func()&#123;</span><br><span class="line">		hive -hiveconf table_name=$&#123;table_name&#125; \</span><br><span class="line">				-hiveconf ...\</span><br><span class="line">				-f test.hql</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用</span></span><br><span class="line">test_func</span><br></pre></td></tr></table></figure>
<h3 id="source-用法"><a href="#source-用法" class="headerlink" title="source 用法"></a>source 用法</h3><p>激活脚本，比如.sh文件中定义了一些变量，完全可以通过source一个.sh文件来使得脚本中定义的变量生效</p>
<p>但是有个问题，这个生效的声明周期仅限于在该会话内，再开一个终端是不能用的</p>
<h3 id="df-和-du"><a href="#df-和-du" class="headerlink" title="df 和 du"></a>df 和 du</h3><ul>
<li>du: disk-usage 显示文件或者目录所占磁盘空间</li>
</ul>
<p>du工作原理，会对待统计文件逐个调用<code>fstat</code>这个系统调用</p>
<ul>
<li>df:disk-free  检查磁盘空间（所以并不能看某个目录的占得磁盘大小）</li>
</ul>
<h3 id="查看文件挂载在哪里"><a href="#查看文件挂载在哪里" class="headerlink" title="查看文件挂载在哪里"></a>查看文件挂载在哪里</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h &lt;path&gt; 即可查看</span><br></pre></td></tr></table></figure>
<h3 id="shell-脚本里面多行注释"><a href="#shell-脚本里面多行注释" class="headerlink" title="shell 脚本里面多行注释"></a>shell 脚本里面多行注释</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "123"</span><br><span class="line"></span><br><span class="line">&lt;&lt; COMMENT</span><br><span class="line">test </span><br><span class="line">&lt;&lt;</span><br></pre></td></tr></table></figure>
<h3 id="sort-用法"><a href="#sort-用法" class="headerlink" title="sort 用法"></a>sort 用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">主要的几个参数：</span><br><span class="line">-k 3  按照第3列进行排序</span><br><span class="line">-r  默认升序，-r进行逆序</span><br><span class="line">-n numerical  如果按照字符串排序会出现  23排在8前面  -n则是按照数值大小排序</span><br><span class="line">-t ”,“ 按照逗号分割，  '\t'这个有点特殊  需要  $'\t' 这样用</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从标准输入 获取</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 表示先输出一段文本内容</span></span><br><span class="line">read -p  "please input: " num</span><br><span class="line">echo $num</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Git 常用工作流</title>
    <url>/2019/12/17/git%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<h3 id="git-基本工作流"><a href="#git-基本工作流" class="headerlink" title="git 基本工作流"></a>git 基本工作流</h3><p>初级 以及讲解  配合业务 使用</p>
<ul>
<li><p>从线上拉回代码</p>
</li>
<li><p>开发前建立一个分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b marys-feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进行开发</p>
</li>
<li><p>然后将开发的结果push上去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进行 git push -u origin  branch_name</p>
</li>
<li><p>提  merger request </p>
</li>
</ul>
<h3 id="更换branch名字"><a href="#更换branch名字" class="headerlink" title="更换branch名字"></a>更换branch名字</h3><p>git branch -m oldname newname</p>
<p>然后再走一遍新的工作流，将新的branch 上传至 origin</p>
<p><a href="https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-feature-branch.md#小红开始开发一个新功能" target="_blank" rel="noopener">https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-feature-branch.md#%E5%B0%8F%E7%BA%A2%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%96%B0%E5%8A%9F%E8%83%BD</a></p>
<h3 id="只克隆branch-到本地"><a href="#只克隆branch-到本地" class="headerlink" title="只克隆branch 到本地"></a>只克隆branch 到本地</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b branch_name  git_address</span><br></pre></td></tr></table></figure>
<h3 id="Git-版本回退到某一个"><a href="#Git-版本回退到某一个" class="headerlink" title="Git 版本回退到某一个"></a>Git 版本回退到某一个</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard  commint_id</span><br></pre></td></tr></table></figure>
<h3 id="完整地址"><a href="#完整地址" class="headerlink" title="完整地址"></a>完整地址</h3><p><a href="https://github.com/oldratlee/translations/tree/master/git-workflows-and-tutorials" target="_blank" rel="noopener">https://github.com/oldratlee/translations/tree/master/git-workflows-and-tutorials</a></p>
<p><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Apach pig 日常使用总结</title>
    <url>/2019/12/16/Apache%20pig/</url>
    <content><![CDATA[<h2 id="Apach-Pig"><a href="#Apach-Pig" class="headerlink" title="Apach Pig"></a>Apach Pig</h2><p>最近需要用到pig这个东西，故做简单的学习记录</p>
<p>首先 pig的基本组成单元是关系，就是内部存储的东西都是关系</p>
<p>是一种简单的分析工具， 其基础是运行在hadoop基础上，那么就涉及到基础的文件加载和存储问题</p>
<h3 id="pig加载数据"><a href="#pig加载数据" class="headerlink" title="pig加载数据"></a>pig加载数据</h3><p>加载数据的目的是将raw data 加载进pig的关系中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">relation_name = LOAD 'input_file_path' USING function as schema;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"></span><br><span class="line">student = LOAD 'hdfs://localhost:9000/pig_data/student_data.txt' </span><br><span class="line">   USING PigStorage(',')</span><br><span class="line">   as ( id:int, firstname:chararray, lastname:chararray, phone:chararray, </span><br><span class="line">   city:chararray );</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>relation_name</strong> - 我们必须提到要存储数据的关系。</li>
<li><strong>Input file path</strong> - 我们必须提到存储文件的HDFS目录。（在MapReduce模式下）</li>
<li><strong>function</strong> - 我们必须从Apache Pig提供的一组加载函数中选择一个函数（ <strong>BinStorage，JsonLoader，PigStorage，TextLoader</strong> ）。</li>
<li><strong>Schema</strong> - 我们必须定义数据的模式，可以定义所需的模式如下 -</li>
</ul>
<p>还有一种是加载hive表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">result = load 'hive表' using</span><br></pre></td></tr></table></figure>
<h3 id="pig-存储数据"><a href="#pig-存储数据" class="headerlink" title="pig 存储数据"></a>pig 存储数据</h3><p>是将转化为关系的数据，存储在hdfs上（local也可以）</p>
<h3 id="FOREACH-GENERATE的使用"><a href="#FOREACH-GENERATE的使用" class="headerlink" title="FOREACH, GENERATE的使用"></a>FOREACH, GENERATE的使用</h3>]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Transformer详解</title>
    <url>/2019/12/16/Transformer%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Transformer-详解"><a href="#Transformer-详解" class="headerlink" title="Transformer 详解"></a>Transformer 详解</h2><p>这个基本是面试重点，在理解这个transformer结构上，可以从宏观开始，然后逐步深入到其中的细节问题。</p>
<h3 id="说在前面："><a href="#说在前面：" class="headerlink" title="说在前面："></a>说在前面：</h3><p>  重点讲解Transformer、BERT部分，transformer-XL、XLNet优化部分做介绍</p>
<ol>
<li><p>一个概念：什么是自回归，什么是自编码？</p>
<p>常规的语言模型从左到右或从右向左都属于自回归模型，就是只依赖于上文或只依赖于下文</p>
<p>GPT就是典型的自回归（从左到右），ELMo也是，只不过其将两个方向的LSTM的hidden state 进行了concat，以来表示上下文。这种自回归方式主要适合生成类任务：文本摘要，机器翻译</p>
<p>BERT 属于去噪声自编码（Denoising Autoencoder）自编码的过程是可以见到上下文的。什么是去噪自编码呢。以BERT为例子，就是在预训练的过程中引入噪声（mask）然后masked LM的目的就是通过上下文来预测mask，达到去噪的目的。这种模式在阅读理解、SQuAD等任务上表现很好，因为这些任务是允许看到上下文的。</p>
</li>
<li><p>Transformer重要参考资料（阅读顺序排列）：</p>
<p>Attention is all your need论文、The Illustrated Transformer（详细讲解Transformer流程）、</p>
<p>The Annotated Transformer（transformer Pytorch版实现）、Transfomer Google官方实现</p>
<p>（Tensor2Tensor）</p>
<p>阅读之后至少清楚模型内部的数据（向量或矩阵）的流动（训练阶段的流动方式、测试阶段的流动方式）</p>
<ol>
<li><p>position encoding<br>理解实现方式、解决的问题</p>
</li>
<li><p>Multi-head attention</p>
<p>理解QKV的生成过程、</p>
<p><strong>重点</strong>理解</p>
<p>Multi-head是如何实现的、了解整个模型需要学习的参数是哪些</p>
<ol>
<li>self-attention<br>理解计算原理、实现方法、重点了解矩阵之间计算</li>
<li>masked self-attention<br>理解mask的作用，mask的实现方式。清楚masked self-attention 和 self-attention 的差别</li>
<li>encoder-decoder attention<br>理解该部分attention 的数据来源</li>
</ol>
</li>
<li><p>一些细节</p>
<ol>
<li>add&amp;Norm 也是有学习参数的</li>
<li>最后decoder的输出层还有一个Linear+softmax</li>
<li>在测试阶段Greedy decoding策略 和 Beam Search策略</li>
</ol>
</li>
<li><p>问题</p>
<ol>
<li>重点明白Transformer的不能解决长文本依赖的问题（受制于实现过程的内存限制、否则其序列长度是可以不受限制的）</li>
</ol>
</li>
</ol>
</li>
<li><p>Transformer-XL</p>
<p>重要参考资料：</p>
<p>Transformer论文、官方简要+动图、官方代码（未看）</p>
<ol>
<li>理解Transformer的操作过程（训练、测试），知道Transformer的弊端</li>
<li>重点理解下 Transformer 的主要组件是 decoder-only (就是只使用transformer的decoder 部分，不是完整的transformer的 encoder+decoder结构)</li>
<li>清楚下Transformer-XL解决Transformer存在问题的总体思想</li>
<li>Segment-lever Recurrence 的实现方式</li>
<li>Relative Positional Encoding 的实现方式</li>
</ol>
</li>
<li><p>BERT</p>
<p>重要参考资料：</p>
<p>BERT原文、illustrated-bert（捎带GPT ELMo）、官方源码、BERT文本分类</p>
<ol>
<li><p>背景知识<br>自编码、自回归<br>了解GPT、ELMo 跟BERT的关系</p>
</li>
<li><p>理解BERT用的只是Transformer的encoder（可以见到上下文，只部分mask）</p>
</li>
<li><p>embedding<br>了解BERT的丰富Embedding（token+segment+position）</p>
</li>
<li><p>两个创新点：<br>重点明白Masked LM 的实现，以及Loss 计算方式<br>重点明白Next Sequence Prediction的原理，以及Loss计算方式</p>
</li>
<li><p>应用<br>了解BERT对各任务的应用场景：sequence level  和 token level</p>
</li>
<li><p>一些问题<br>BERT切词方式：在源码的 tokenization.py<br>BERT的pre-traing 和 fine-tuning过程不一致问题<br>BERT还可以做feature-based 形式，后边拼接自己的模型</p>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>XLNet</p>
<p>重要参考资料：</p>
<p>XLNet原文、跟其他模型对比and论文解读、XLNet与Bert对比</p>
<ol>
<li>背景知识：BERT+Transformer-XL</li>
<li>主要方法：<br>Permutation Language Modeling 方式 用自回归的方式达到见到上下文信息<br>Architecture:Two_Stream Self-Attention for target-Aware representations(本次分享未涉及到)<br>从Transformer-XL 借鉴经验</li>
<li>XLNet 未讲解部分，还需要大家之后单独了解下</li>
</ol>
</li>
<li><p>思考</p>
<ol>
<li>NLP -&gt; Nvidia League Player</li>
<li>刷榜模型或方法层出不穷</li>
<li>实际工作中有哪些可以展开的工作</li>
</ol>
</li>
</ol>
<h3 id="Embedding层"><a href="#Embedding层" class="headerlink" title="Embedding层"></a>Embedding层</h3><p>Transformer的embedding层比较特殊的地方就是引入了Position embedding，为什么需要这样一个embedding？原因是由于后边进行self-attention的时候，每个词之间都可以进行交互，这样解决了长期依赖的问题，但是由于缺少了原有语言的顺序，那么<code>i am a boy</code>和<code>am boy a i</code>是没有区别的了，反正两两之间都会计算score.</p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>Encoder是个模块，简单的理解实际上就两部分，一部分是Mult-head Attention 另一部分是一个Positionwise FeedForward，当然还有两个小模块add&amp;norm。</p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>今天又理解了一个  Layernormalization和 batchnormalization的区别</p>
<p>针对的归一化维度是不一样的。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>百度信息流算法？面经</title>
    <url>/2019/12/16/%E9%9D%A2%E7%BB%8F/%E7%99%BE%E5%BA%A6%E4%BF%A1%E6%81%AF%E6%B5%81%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="百度信息流算法？面经"><a href="#百度信息流算法？面经" class="headerlink" title="百度信息流算法？面经"></a>百度信息流算法？面经</h2><p>为什么要给标题打个问号呢？ 因为我是真的好奇，我自己投的到底是不是算法工程师…因为二面面试问的问题，真的是之前面别的地方算法从来没有问过的…也算给自己提个醒吧…算法工程师不仅仅需要掌握那些玄幻的算法什么….更重要的还是工程师嘛。。。</p>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>简单的自我介绍，说下自己之前做的项目，然后：</p>
<p>会不会c c++ java，我说自己java还可以，面试官紧接着问java的字符串的三种形态 stringbuffer  stringbuild什么的清楚嘛？</p>
<p>我：java写但是确实仅限于写题，具体的一些细节和底层的东西确实没有接触过。也就在大二时候用过，最近可能确实很久没用了，不太熟悉。。。</p>
<p>面试官：你用c写个堆排序吧…</p>
<p>（其实堆排序自己写起来问题倒是不大，但是c语言…用久了python 根本不记得c的一些写法了，包括最开始变量定义都写错了，也算完整写下来了吧….）</p>
<p>然后面试官问了一个算法设计题目：</p>
<blockquote>
<p>给你一批数据，有id和score，然你根据score的值大小进行加权采样，即根据score分数，从中抽取n个样本</p>
<p>Id score</p>
<p>0    3</p>
<p>1    5</p>
<p>2    10</p>
<p>3    1</p>
<p>。。。</p>
</blockquote>
<p>问怎么实现？</p>
<p>我提的思路是，可以根据score的分数对样本进行copy，也就是说对于score=3，那我就把id复制3次，对于score=10，我就把对应id复制10次，再将复制之后的整体数据进行打散，然后再随机抽取n个，由于样本中的样本分布已经被之前的操作所改变，所以完全可以达到加权采样的效果。但是这样操作的问题就是，如果数据量很大，那么你都进行复制，数据量会更大，其实是不太友好的。</p>
<p>然后看我简历有awk 和Linux，问了几个简单的命令。</p>
<p>一面给的评价还是positive的吧，问题不太大。</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>（我开始还以为是压力面，但是谁知道 人家真的就是二面….）</p>
<p>简单的聊一下项目，问下我的研究生的方向（本人研究生方向是云计算与服务工程，但是自己并没有去做相关的内容）然后针对项目中的知识点进行细致的提问，比如 lstm+crf 如果只有lstm会怎样，只有crf会怎样。项目没有问很多吧。</p>
<p>然后就是写题其实题目也很简单，写一个单链表的反转….问题就是，只能用c来实现，c语言确实很久没有写了，导致写出来的代码不伦不类，很被动。</p>
<p>然后写完单链表的反转之后他对代码不是很满意…确实很多c语言的写法可能都记不清楚了，又写了一个快排，快排的partition我也是写了一个可能跟他印象中不一样的（这会面试体验挺不好的…跟你印象中的不一样就不对了?）然后说我写的c语言不行…然后开始问我c语言的基础，全局变量和局部变量区别，说到了堆栈，就问我堆栈具体怎么实现的。</p>
<p>从这开始就进入了完全被动状态…甚至怀疑自己投错了岗位</p>
<p>问我怎么理解类，类有哪些特性</p>
<p>开始问数据库的一些知识：数据一致性，数据一致性是通过什么来实现的？（这个完全没有印象）</p>
<p>操作系统的进程线程的区别（这个还好）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实总体面完的感觉还是很糟糕的，原因一方面是感觉跟之前面其他公司的感觉完全不一样，没有推算法 没有将项目，没有机器学习相关，直接全是计算机基础。另一方面就是，自己的计算机基础真的是糟糕…可能这也是自己着力避开这些，想通过算法工程师来解决吧…但是说到底这些都是计算机专业的基础课…虽然学过忘记了…还是尽量多复习复习吧，明年秋招，尽量别被这种问题卡主。</p>
]]></content>
  </entry>
  <entry>
    <title>Dropout学习与总结</title>
    <url>/2019/12/14/dropout%E9%A2%84%E9%98%B2%E8%BF%87%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<h2 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h2><p>关于一个新东西的三连：是什么，为什么，怎么用</p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Dropout 是训练<strong>深度</strong>神经网络时采取的一种手段，来预防过拟合。在训练过程中，随机的以一定的概率“临时”抛弃掉某些节点。具体来讲，dropout作用于每个<strong>小batch</strong>训练数据，由于其随机丢弃部分神经元的机制，相当于每次迭代都在训练不同的神经网络结构。</p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>Dropout为什么会有这样的效果呢？类比bagging方法，其实达到了集成学习的效果。从bagging的集成角度来讲，传统意义上的bagging集成方法涉及多个模型的训练与评估，当网络参数规模庞大时，这种集成方式需要消耗大量的运算时间和空间。而Dropout是在小批量上进行操作，类似一种轻量级的bagging集成近似，能够实现指数级数量神经网络的训练与评估。</p>
<p>原理就是，在dropout具体实现过程中，要求每个神经元节点激活值以一定的概率p被“丢弃”（被置0）。对于有N个神经元节点的神经网络，使用Dropout 可以看做是有$2^n$ 个模型的集成（即每个神经元都可以选择 存在或者不存在），他们共享部分权值，并且具有相同的网络层数，而且模型整体的参数数目不变，大大简化了运算。每次训练都会随机挑选一批不同的神经元进行组合优化，这个过程会减弱全体神经元之间的联合适用性，减少过拟合的风险，增强泛化能力</p>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>主要涉及两个过程一个是训练过程，一个是预测过程，在训练过程我们采取了概率p来丢弃神经元，那么在运行预测过程（一次前向传播）的时候，我们不在对神经元进行丢弃，相反，我们使用概率p乘在每个神经元上，以恢复训练过程中，某神经元只有概率p存在神经网络中。</p>
<p>使用Dropout前的前向传播：</p>
<script type="math/tex; mode=display">
z_{i}^{(l+1)} = w_{i}^{(l+1)}y^l+b_{i}^{(l+1)} \\ 
y_{i}^{(l+1)} = f(z_i^{l+1}) \\
f是激活函数</script><p>使用dropout后的前向传播</p>
<script type="math/tex; mode=display">
r_{i}^{(l)} \sim Bernoulli(p) \\
\hat{y}^{(l)} = r^{(l)} \dot \ y^{(l)}  \\
z_{i}^{(l+1)} = w_{i}^{(l+1)}y^{(l)}+b_{i}^{(l+1)} \\ 
y_{i}^{(l+1)} = f(z_i^{(l+1)}) \\
f是激活函数</script><p>由此可见，是先对前一层的神经元进行“丢弃”再执行传播操作。</p>
<h3 id="一些细节的理解"><a href="#一些细节的理解" class="headerlink" title="一些细节的理解"></a>一些细节的理解</h3><p>每次dropout的是神经元，并不是权值，也就是说权值参数矩阵始终是在更新的。每一次计算$W^T X$的时候，其中X中部分神经元被置为0。这样相当于“丢弃”了这部分神经元。</p>
<p>训练过程，对于未被丢弃的神经元，还需要乘以$\frac{1}{1-p}$使得总体的分布情况保持一致。</p>
<p>预测过程，对于全部的神经元，都需要乘以概率p，来恢复训练过程中，某个神经元以概率p存在神经网络中。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>中心极限定理</title>
    <url>/2019/12/11/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><h3 id="数学表述"><a href="#数学表述" class="headerlink" title="数学表述"></a>数学表述</h3><h3 id="独立同分布的中心极限定理"><a href="#独立同分布的中心极限定理" class="headerlink" title="独立同分布的中心极限定理"></a>独立同分布的中心极限定理</h3><p>设随机变量X1，X2，……Xn，……独立同分布，并且具有有限的数学期望和方差：E(Xi)=μ，D(Xi)=σ20(k=1,2….)，则对任意x，分布函数</p>
<p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/f31fbe096b63f624c0ee83e68a44ebf81b4ca3a0.jpg" alt="img"></p>
<p>满足</p>
<p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/faf2b2119313b07e435bb59901d7912396dd8cb9.jpg" alt="img"></p>
<p>该定理说明，当n很大时，随机变量</p>
<p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/77094b36acaf2edda57f1a01861001e93801934f.jpg" alt="img"></p>
<p> 近似地服从标准正态分布N(0，1)。因此，当n很大时，</p>
<p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/d62a6059252dd42af4b35875093b5bb5c8eab8b2.jpg" alt="img"></p>
<p> 近似地服从正态分布N(nμ，nσ2)．该定理是中心极限定理最简单又最常用的一种形式，在实际工作中，只要n足够大，便可以把独立同分布的随机变量之和当作正态变量。这种方法在数理统计中用得很普遍，当处理大样本时，它是重要工具。</p>
<p>从数学公式到例子的理解，重点应该关注下 什么叫随机变量，随机变量也是一个样本的分布情况，</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>这个例子讲的挺明白，但是目前跟中心极限定理的数学表达还对不上</p>
<p><a href="https://blog.csdn.net/mingyuli/article/details/81141758" target="_blank" rel="noopener">https://blog.csdn.net/mingyuli/article/details/81141758</a></p>
<p>中心极限定理告诉我道们，当样本量足够大时，样本均值的分布慢慢变成正态分布</p>
<h2 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h2><p>对于一份数据集，其分布可能并不是正太分布的。但是我们可以通过采样操作，比如每次采样n=50个，一共采样m个样本集，那么这个样本集的分布是符合正太分布的。</p>
<p>比如整个数据集合的均值可能为1，方差为2。我们抽出来了m个样本，可能这m个样本中，有的样本均值为0，有的样本均值为0.9，有的为1.2有的为2.0 。但是这m个样本的分布是符合正太分布的。</p>
<p><strong>中心极限定理意味着即使数据分布不是正态的，从中抽取的样本均值的分布也是正态的</strong></p>
]]></content>
      <categories>
        <category>概率与统计面试题</category>
      </categories>
  </entry>
  <entry>
    <title>头条广告算法面经</title>
    <url>/2019/12/10/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="头条广告算法面经"><a href="#头条广告算法面经" class="headerlink" title="头条广告算法面经"></a>头条广告算法面经</h2><p>定向广告组，主要做 微信looklike类似的场景</p>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>LR推</p>
<p>写题 </p>
<p>迭代二分，递归二分</p>
<p>关于业务上的问题：</p>
<blockquote>
<p>这边做的主要是召回侧，定向召回，目前也在尝试各种其他方法，主要做的是 look-like（微信看一看的定向投放）</p>
</blockquote>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>项目问题</p>
<p>什么是极大似然估计 </p>
<p>什么是中心极限定理（抽样样本的均值 服从高斯分布）</p>
<p>（面试官感觉百度过来的）</p>
<p>写题：</p>
<p>将ip地址转为一个int32的数</p>
<blockquote>
<p>255.255.255.0 是一个字符串 要求最终返回的结果是一个int32</p>
<p>解法就是个位运算， 移位再加下一个</p>
</blockquote>
<p>紧接着 问了一个经典百度问题 hhhh</p>
<p>1T文件，存储的是ip地址，给一个128MB的内存，问如何统计出出现次数最高的前10个</p>
<p>这个问题真的得好好分析一下，现场分析的有点混乱。重点是前面的问题是可以拿过来利用的，就是一个ip地址对应一个唯一的int32  </p>
<blockquote>
<p>提了拆成不同文件，来计数，提了计数后通过堆排来过滤</p>
</blockquote>
<p>再一个问题：</p>
<p>给1，2，3三个数，然后给一个数组，这个数组就是由这三个数组成的，其中某个数可能重复很多，问如何排序</p>
<p>举个栗子[1,2,3,1,2,3,1,2,3] 排序后：[1,1,1,2,2,2,3,3,3]</p>
<blockquote>
<p>当时的思路就是 快排呗…结果被面试官嘲笑了，我就给你限制到这三个数</p>
<p>后来想了下，三个变量来记录1，2，3的个数就可以了，完事之后可以通过计数器，输出相应个数的对应值。</p>
</blockquote>
<p>然后面试题进一步进阶为：</p>
<p>现在不上三个数了，现在有一堆实例，他们都是从一个对象具体来的，比如 一个物体，其中某一个属性的值有1，2，3三种，请根据这个属性值对所有实例进行排序。</p>
<blockquote>
<p>这样就不能用上边的方法了，因为1跟1都是一样的，但是这里只对一个属性就行排，每个实例中除了该属性可能一样，其他都不一样。问怎么排序</p>
</blockquote>
<p>这个回答的就不是很好了</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>之后在网上看到的有人分享的</p>
<p>一面：</p>
<p>1、 给一个有序数组，没有重复值，给一个数组sum，从数组中找出和为sum的两个数，打印出所有可能的组合。</p>
<p>2、 两个字符串的公共子串（连续的）长度。</p>
<p>3、 数据倾斜的一道题。</p>
<p>4、 问wide和deep之间的区别。</p>
<p>5、 问AUC如何计算。</p>
<p>6、 问youtube deep network里面如何解决softmax处理对象数量巨大的问题，提到了霍夫曼树和负采样，然后问负采样怎么回事儿，然后问如何解决大数据量下的负采样。</p>
<p>7、 问youtube deep network里产生了用户和物品向量后，如何应用到在线的，主要想问如何快速获取用户喜欢的物品，是论文题提到的一个工程方法，提前建立好相应的索引。</p>
<p>二面</p>
<p>1、 将一颗二叉树转成双向链表。</p>
<p>2、 用mapreduce或spark实现itemCF中物品相似度的计算。</p>
<p>3、 如何解决L1正则不可导的那一点。</p>
<p>4、 FM和LR的区别，主要讲FM的特点。</p>
<p>5、 问AUC。</p>
<p>6、 问LR为什么不能用MSE，然后引导我回答出来的，先让我写LR的损失，然后让我推导一下使用MSE之后的梯度，观察有什么劣势。</p>
<p>7、 问AdaGrad算法原理及其特点（都是围绕学习率的，我只回答出了一个，实际上有两个，然后面试官给我讲解了一下）。</p>
<p>三面</p>
<p>问第三个项目的几个点：</p>
<p>AUC</p>
<p>线上优化器</p>
<p>神经网络优化器</p>
<p>CTR模型：注重wide&amp;Deep中wide与deep之间的区别</p>
<p>论文</p>
<p>算法题：</p>
<p>K个排序的列表，融合成一个有序列表</p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-11-盛最多水的问题</title>
    <url>/2019/12/10/Leetcode/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="盛最多水的问题"><a href="#盛最多水的问题" class="headerlink" title="盛最多水的问题"></a>盛最多水的问题</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(height)<span class="number">-1</span></span><br><span class="line">        res = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">                res = max(res, height[i]*(j-i))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = max(res, height[j]*(j-i))</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-148-排序链表</title>
    <url>/2019/12/10/Leetcode/leetcode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4<br>示例 2:</p>
<p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路很简单，基于归并排序过程。那么就涉及到两个过程，一个是划分，一个是合并</p>
<ul>
<li>链表的划分依靠于快慢指针，得到一半一半的链表</li>
<li>链表的合并就是基于合并两个有序链表</li>
</ul>
<p>思路较为简单，但是写的过程有一些小坑，即时避开。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(head)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, head)</span>:</span></span><br><span class="line">      	<span class="comment"># 小坑1：不仅仅要看空指针 还有处理单头  否则会死循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 快慢指针</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        p = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            p = slow</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="comment"># ！！！ 最坑的地方</span></span><br><span class="line">        <span class="comment"># 目的是为了断开链表，一定要通过 next为空来断开</span></span><br><span class="line">        <span class="comment"># 原本写的  tail = slow , slow = None </span></span><br><span class="line">        p.next = <span class="literal">None</span></span><br><span class="line">				</span><br><span class="line">        <span class="comment"># 处理左侧</span></span><br><span class="line">        left = self.helper(head)</span><br><span class="line">        <span class="comment"># 处理右侧</span></span><br><span class="line">        right = self.helper(slow)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#######合并两个有序链表过程#########</span></span><br><span class="line">				<span class="comment"># 哑头，方便处理</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p1 = left</span><br><span class="line">        p2 = right</span><br><span class="line">        p3 = dummy</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val &lt; p2.val:</span><br><span class="line">                p3.next = p1</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p3.next = p2</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            p3 = p3.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> p1:</span><br><span class="line">            p3.next = p1</span><br><span class="line">        <span class="keyword">if</span> p2:</span><br><span class="line">            p3.next = p2</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>也是链表排序，同样满足题意：基于快排的链表排序</p>
<p><a href="https://mereder.github.io/2019/11/25/单链表的快排/" target="_blank" rel="noopener">单链表快排</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-51-N皇后</title>
    <url>/2019/12/09/Leetcode/leetcode-51-N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qs3y3nfhj307607o748.jpg" alt="img"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<blockquote>
<p>示例:</p>
<p>输入: 4<br>输出: [<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p>
<p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]<br>解释: 4 皇后问题存在两个不同的解法。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>刚刚掌握了回溯法的套路，然后就打算拿个hard的题目试试，就发现了这个N皇后问题，发现自己拿回溯法套路完全套不上去，问题出在：</p>
<ul>
<li>递归的是什么？ </li>
<li>状态怎么表示？！！！这个也是最大的问题</li>
</ul>
<p>看完官方题解之后，大呼 秒啊~</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qs80oinhj307e06t0st.jpg" alt="秒啊"></p>
<p>首先说递归的是什么，我们要找的就是皇后的排列位置，也就是说，每一行肯定会放一个皇后，那么具体这个皇后放在哪个位置（哪一列上）就需要通过其他条件来判，比如第一行第一个皇后可以随便放，但是第二行的皇后再放的时候就需要考虑，是否会被前面放置的皇后打到….依次类推，直到最后一行也放置好一个皇后为止。</p>
<p>由此可以看到，回溯的depth是指行数（0——N-1），而在一行内，还需要罗列每一个位置即坐标对从（depth,0）….(depth,N-1)</p>
<p>再看看状态转移怎么表示，我们的目的是找到一种表示，能够来表示，当某一个皇后落位之后，其影响的其他位置都不可以有棋子。</p>
<blockquote>
<p>西洋棋中，皇后的特性是，可以横着，竖着，斜着</p>
</blockquote>
<p>我们已经通过递归的特性使得每一行不会有重复的了，所以我们需要一个表示列的状态，确保每一列只可以有一个。其次，对于斜着，有两个方向，一种是平行于主对角线，另一种是平行于辅对角线。</p>
<p>！！！trick来啦</p>
<p>对于平行于主对角线上的元素，其$row-col$都是一个常量</p>
<blockquote>
<p>举个例子：主对角线上(0,0)(1,1)…(n-1,n-1)    行标-列标=0</p>
<p>那么平行于主对角线的一条比如:(1,0),(2,1)….(n-1,n-2)  行标-列标 = 1</p>
</blockquote>
<p>那么我们只需要确定同一个斜线上只有一个皇后就好了</p>
<p>同样，对于平行于辅对角线，其$row+col$都是一个常量</p>
<p>下面进行我们的操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># 两个trick： 通过这两个trick 可以很快的得出 某一条线路能否放一个皇后</span></span><br><span class="line">        <span class="comment"># 同一条主对角线（平行于主对角线）上的元素，都符合 row-col = constant</span></span><br><span class="line">        <span class="comment"># 同一条副对角线（平行于副对角线）上的元素，都符合 row+col = constant</span></span><br><span class="line">        <span class="comment"># 不在同一列就是通过 列的来判断</span></span><br><span class="line">        stack = []   <span class="comment"># 用来存储一个临时结果</span></span><br><span class="line">        res = []	<span class="comment"># 用来存储最终结果</span></span><br><span class="line">        main_diagonal = [<span class="number">0</span>]*(<span class="number">2</span>*n)  <span class="comment"># 定义的主对角线状态存放</span></span><br><span class="line">        sub_diagonal = [<span class="number">0</span>]*(<span class="number">2</span>*n)		<span class="comment"># 定义辅对角线的状态存放</span></span><br><span class="line">        lie = [<span class="number">0</span>]*n						<span class="comment"># 定义对列的状态存放</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_position</span><span class="params">(row,col)</span>:</span></span><br><span class="line">            lie[col] = <span class="number">1</span></span><br><span class="line">            main_diagonal[row-col] = <span class="number">1</span></span><br><span class="line">            sub_diagonal[row+col] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">remove_positon</span><span class="params">(row,col)</span>:</span></span><br><span class="line">            lie[col] = <span class="number">0</span></span><br><span class="line">            main_diagonal[row-col] = <span class="number">0</span></span><br><span class="line">            sub_diagonal[row+col] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(row,col)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> (lie[col]+main_diagonal[row-col]+sub_diagonal[row+col]) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_result</span><span class="params">()</span>:</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="comment"># i 行 j列</span></span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> sorted(stack):</span><br><span class="line">                tmp.append(<span class="string">'.'</span>*j+<span class="string">'Q'</span>+<span class="string">'.'</span>*(n-j<span class="number">-1</span>))</span><br><span class="line">            res.append(tmp)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack1</span><span class="params">(row)</span>:</span></span><br><span class="line">            <span class="comment"># 逐行确定，每一行肯定可以确定一个位置（列）</span></span><br><span class="line">            <span class="comment"># 下面就是经典的回溯框架（套路）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n): </span><br><span class="line">              	<span class="comment"># 1. 检查是否满足可以进入的条件（本题就是可以放置皇后）</span></span><br><span class="line">                <span class="keyword">if</span> check(row, i):</span><br><span class="line">                  	<span class="comment"># 2. 将可以的结果加入stack中进行记录</span></span><br><span class="line">                    stack.append((row, i))</span><br><span class="line">                    <span class="comment"># 3. 记录状态加入</span></span><br><span class="line">                    add_position(row, i)</span><br><span class="line">										<span class="comment"># 4. 对于是否满足条件，如果满足条件则将结果进行输出</span></span><br><span class="line">                    <span class="comment">#    不满足继续进行递归</span></span><br><span class="line">                    <span class="keyword">if</span> row == n<span class="number">-1</span>:</span><br><span class="line">                        add_result()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        backtrack(row+<span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 5. 回弹过程，拿掉前面加入的记录</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                    <span class="comment"># 6. 更改记录状态</span></span><br><span class="line">                    remove_positon(row,i)</span><br><span class="line">         </span><br><span class="line">        <span class="comment"># 回溯更经常将递归结束条件写在外边</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">backtrack2</span><span class="params">(row)</span>:</span></span><br><span class="line">            <span class="comment"># 1. 递归结束条件</span></span><br><span class="line">            <span class="keyword">if</span> row == n:  <span class="comment"># !!!!注意这个地方与上边的区别，</span></span><br><span class="line">                add_result()</span><br><span class="line">                <span class="keyword">return</span>    </span><br><span class="line">            <span class="comment"># 逐行确定，每一行肯定可以确定一个位置（列）</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n): </span><br><span class="line">                <span class="comment"># 2. 检查是否满足可以进入的条件（本题就是可以放置皇后）</span></span><br><span class="line">                <span class="keyword">if</span> check(row, i):</span><br><span class="line">                  	<span class="comment"># 3. 将可以的结果加入stack中进行记录</span></span><br><span class="line">                    stack.append((row, i))</span><br><span class="line">                    <span class="comment"># 4. 记录状态加入</span></span><br><span class="line">                    add_position(row, i)</span><br><span class="line">										<span class="comment"># 5. 递归下一层</span></span><br><span class="line">                    backtrack(row+<span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 6. 回弹过程，拿掉前面加入的记录</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                    <span class="comment"># 7. 更改记录状态</span></span><br><span class="line">                    remove_positon(row,i)</span><br><span class="line"></span><br><span class="line">        backtrack1(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># backtrack2(0)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>专业书籍书单</title>
    <url>/2019/12/09/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<h2 id="专业书籍书单"><a href="#专业书籍书单" class="headerlink" title="专业书籍书单"></a>专业书籍书单</h2><p>如果仔细的品味完这些书，保证自己的能力能得到质的飞越！！！</p>
<h3 id="基本刷题"><a href="#基本刷题" class="headerlink" title="基本刷题"></a>基本刷题</h3><ul>
<li>[ ] Leetcode（186/1200）</li>
<li>[x] 剑指offer</li>
<li>[ ] 编程思想</li>
</ul>
<h3 id="机器学习大方向"><a href="#机器学习大方向" class="headerlink" title="机器学习大方向"></a>机器学习大方向</h3><ul>
<li>[ ] 统计学习方法</li>
<li>[ ] 机器学习（西瓜书）</li>
<li>[ ] 百面机器学习</li>
<li>[ ] 强化学习精要</li>
<li>[ ] 推荐系统</li>
</ul>
<h3 id="算法工程师基本技能"><a href="#算法工程师基本技能" class="headerlink" title="算法工程师基本技能"></a>算法工程师基本技能</h3><ul>
<li><p>编程语言</p>
<ul>
<li>python 核心编程</li>
<li>java ？？？ </li>
</ul>
</li>
<li><p>大数据方向</p>
</li>
<li><p>[ ] Spark内核机制解析以及性能调优</p>
</li>
<li><p>[ ] Hive编程指南</p>
</li>
</ul>
<h3 id="其他维度的培养"><a href="#其他维度的培养" class="headerlink" title="其他维度的培养"></a>其他维度的培养</h3><ul>
<li>[ ] 产品思维</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>机器学习中的评价指标——ROC,AUC</title>
    <url>/2019/12/09/ML/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87AUC/</url>
    <content><![CDATA[<h2 id="ROC"><a href="#ROC" class="headerlink" title="ROC"></a>ROC</h2><p>ROC曲线是 receiver operating characteristic curve的简称。（受试者工作特征曲线）</p>
<p>其横坐标为<strong>假阳性率(False Positive Rate,FPR)</strong>， 纵坐标为<strong>真阳性率(True Positive Rate, TPR)</strong></p>
<script type="math/tex; mode=display">
FPR = \frac{FP}{N} \\
TPR = \frac{TP}{P} \\</script><p>对于假阳性率、真阳性率，需要一点实际例子来进行理解。拿我之前做过的识别三俗文章的例子来理解。对于一批样本100个，其中三俗文章（正例）有6篇，非三俗文章（负例）94篇，我们建立一个简单的文本分类模型来识别这批数据，我们分类器的结果是，100篇中，判为三俗的有8篇，但是真正三俗的仅为5篇，剩余92篇均判为非三俗，其中有1篇判错。</p>
<p>模型整体准确率为：</p>
<script type="math/tex; mode=display">
\frac{5+91}{100} = 96\%</script><p>针对三俗类别来说的精确率为:</p>
<script type="math/tex; mode=display">
\frac{5}{8} = 62.5\% \\ 
即 分类正确的正样本个数占分类器判定为正样本个数的比例</script><p>针对三俗类别来说的召回率为:</p>
<script type="math/tex; mode=display">
\frac{5}{6} = 83.3\% 
即分类正确的正样本个数占实际正样本个数的比例</script><p>假阳性率为:</p>
<script type="math/tex; mode=display">
FPR = \frac{3}{94}  \\
即 被误判为三俗的样本，占真实非三俗样本总数的比例</script><p>真阳性率为：</p>
<script type="math/tex; mode=display">
TPR = \frac{5}{6} \\
即分类正确的三俗样本，占实际三俗样本个数的比例，跟召回率一样</script><h3 id="如何绘制ROC曲线"><a href="#如何绘制ROC曲线" class="headerlink" title="如何绘制ROC曲线"></a>如何绘制ROC曲线</h3><p>关键点在于：<strong>每个截断点都对于一个TPR和FPR</strong></p>
<p>绘制ROC曲线的过程，就是不断枚举截断点（分类阈值）的过程，通过动态调整截断点，从最高分的得分开始，逐渐调整到最低点，其中每一个截断点都对应一个坐标（FPR,TPR），将这些点连成线就构成了ROC曲线。</p>
<h2 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h2><p> AUC即 area under curve ,指的是ROC曲线下的面经，该值能够量化地反映基于ROC曲线衡量出的模型性能。AUC一般取值0.5-1之间，AUC越大，说明分类器越可能把真正的正样本排在前面，分类性能越好。（对于排序来说，就是把正样本排的越靠前）。</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-46-全排列</title>
    <url>/2019/12/09/Leetcode/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="Leetcode-46-全排列"><a href="#Leetcode-46-全排列" class="headerlink" title="Leetcode-46-全排列"></a>Leetcode-46-全排列</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>回溯方法</strong>：“不撞南墙不回头”</p>
<ul>
<li><p>思考怎么撞到南墙——通过递归来达到</p>
</li>
<li><p>思考回溯的“南墙”是什么——递归的终止条件</p>
</li>
<li>思考回头的话怎么回头——状态记录</li>
</ul>
<blockquote>
<p>res: 结果集，[[],[],[]…] 的数据形式</p>
<p>used: 用来进行状态记录，使用过的将不能再使用，用来保证全排列过程，前面出现的字符，后边不在出现</p>
<p>stack: 用来存放结果，其中包含了回溯的加入和回退过程，</p>
<p>depth: 用来记录递归的深度（全排列字符串的个数），当depth等于字符串长度时，也就是某一种排列形成，我们将其排列结果加入到结果集中</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span>  <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        used = [<span class="literal">False</span>]*len(nums)</span><br><span class="line">        stack = []</span><br><span class="line">        self.helper(res,stack,<span class="number">0</span>, nums, used)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, res, stack, depth, nums, used)</span>:</span></span><br><span class="line">        <span class="comment"># 迭代出口  回溯所说的：撞到南墙</span></span><br><span class="line">        <span class="keyword">if</span> depth == len(nums):</span><br><span class="line">            res.append(stack.copy()) <span class="comment"># 需要copy否则stack是动态变化的 会在res中变化</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">              	<span class="comment"># 不断前进过程</span></span><br><span class="line">                stack.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">								<span class="comment"># 递归操作，递归深度不断加深</span></span><br><span class="line">                self.helper(res,stack,depth+<span class="number">1</span>,nums,used)</span><br><span class="line">								<span class="comment"># 一旦撞到南墙，则开始回头</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-17-电话号码的组合</title>
    <url>/2019/12/08/Leetcode/leetcode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="电话号码的组合"><a href="#电话号码的组合" class="headerlink" title="电话号码的组合"></a>电话号码的组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pj84tjdlj30dv0ckdhp.jpg" alt="img"></p>
<p>示例:</p>
<p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先肯定需要一个映射表的，来映射数字到字母组的关系。</p>
<p>其次，根据数字的顺序，字母也是有前后顺序的。感觉上写几层循环枚举就可以解决了，但是进一步发现，循环的层数是不确定的，所以用递归来解决。</p>
<p>递归：</p>
<ul>
<li>递归的出口就是，生成的字符串长度与数字长度相等</li>
<li>每次递归的操作：<ul>
<li>将字符拼入待生成字符串</li>
<li>递归进入下一层，将当前生成字符串传入，且数字字符串向下移动一位</li>
<li>将拼入的字符删掉（回溯的过程）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        table = &#123;<span class="string">'2'</span>:<span class="string">'abc'</span>,</span><br><span class="line">                 <span class="string">'3'</span>:<span class="string">"def"</span>,</span><br><span class="line">                 <span class="string">'4'</span>:<span class="string">"ghi"</span>,</span><br><span class="line">                 <span class="string">'5'</span>:<span class="string">"jkl"</span>,</span><br><span class="line">            		 <span class="string">'6'</span>:<span class="string">"mno"</span>,</span><br><span class="line">                 <span class="string">'7'</span>:<span class="string">"pqrs"</span>,</span><br><span class="line">                 <span class="string">'8'</span>:<span class="string">"tuv"</span>,</span><br><span class="line">                 <span class="string">'9'</span>:<span class="string">"wxyz"</span>&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(table,res, <span class="string">''</span>,digits,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, table, res, string, digits,index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(string) == len(digits):</span><br><span class="line">            res.append(string)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        tmp = string</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> table[digits[index]]:</span><br><span class="line">            tmp += ch</span><br><span class="line">            self.helper(table,res,tmp,digits,index+<span class="number">1</span>)</span><br><span class="line">            tmp = tmp[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>剑指</strong>上面记得有一段，大部分递归问题都可以通过画成树状结构来进行分析。其实这个题也是，从根到叶子节点的一条完整路径就是一个可能的结果。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-647-回文子串</title>
    <url>/2019/12/08/Leetcode/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p>示例 1:</p>
<p>输入: “abc”<br>输出: 3<br>解释: 三个回文子串: “a”, “b”, “c”.<br>示例 2:</p>
<p>输入: “aaa”<br>输出: 6<br>说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”.<br>注意:</p>
<p>输入的字符串长度不会超过1000。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>处理回文问题最好用的一个方式就是<strong>中心扩散</strong>，即从中间向两边扩散。</p>
<p>扩散的过程不仅可以记录回文子串内容，还可以记录长度，还可以记录个数（只要始末位置不一样就算一个回文串）</p>
<p>本题就是让字符串中每一个字符都当一次中心，然后通过中心扩散来统计不同回文串的个数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> center <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            count += self.centerSpread(s,center,center) <span class="comment"># 奇数对称</span></span><br><span class="line">            count += self.centerSpread(s,center,center+<span class="number">1</span>) <span class="comment"># 偶数对称</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">centerSpread</span><span class="params">(self, s,l,r)</span>:</span> <span class="comment"># 中心扩散</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&gt;=<span class="number">0</span> <span class="keyword">and</span> r &lt; len(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l-=<span class="number">1</span></span><br><span class="line">            r+=<span class="number">1</span></span><br><span class="line">            count+=<span class="number">1</span> <span class="comment"># 起止位置不同就算一个</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-18-四数之和</title>
    <url>/2019/12/08/Leetcode/leetcode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p>
<p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跟三数之和思路是一样的，我们复习下：</p>
<blockquote>
<p>三数之和中，我们先通过预排序，让数组有序。然后固定一个数，然后移动剩下的两个数（双指针）</p>
<p>即：预排序+固定一个+双指针</p>
</blockquote>
<p>对于四数之和，我们采用同样的方案，只不过这里需要更改的是，我们固定<strong>两个数</strong></p>
<ul>
<li>特判，特殊情况直接处理</li>
<li>预排序</li>
<li>固定一个数a<ul>
<li>处理相同情况</li>
<li>再固定一个数b<ul>
<li>处理b的相同情况</li>
<li>定义双指针</li>
<li>双指针进行移动<ul>
<li>4sum == target添加结果</li>
<li>4sum &lt; target: 移动左指针</li>
<li>4sum &gt; target: 移动右指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> range(n<span class="number">-3</span>):</span><br><span class="line">            <span class="keyword">if</span> a &gt; <span class="number">0</span> <span class="keyword">and</span> nums[a] == nums[a<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> range(a+<span class="number">1</span>,n<span class="number">-2</span>):</span><br><span class="line">                <span class="keyword">if</span> b &gt; a+<span class="number">1</span> <span class="keyword">and</span> nums[b] == nums[b<span class="number">-1</span>]: <span class="comment"># 注意条件，一定是b &gt;a+1不能跟a再比较</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                l = b+<span class="number">1</span></span><br><span class="line">                r = n<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    <span class="keyword">if</span> nums[a]+nums[b]+nums[l]+nums[r] == target:</span><br><span class="line">                        res.append([nums[a],nums[b],nums[l],nums[r]])</span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l+<span class="number">1</span>]:</span><br><span class="line">                            l+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r<span class="number">-1</span>]:</span><br><span class="line">                            r-=<span class="number">1</span></span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">                        r-=<span class="number">1</span>  </span><br><span class="line">                    <span class="keyword">elif</span> nums[a]+nums[b]+nums[l]+nums[r] &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: </span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-992-K个不同整数的子数组</title>
    <url>/2019/12/08/Leetcode/leetcode-992-K%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="K个不同整数的子数组"><a href="#K个不同整数的子数组" class="headerlink" title="K个不同整数的子数组"></a>K个不同整数的子数组</h2><p>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。</p>
<p>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）</p>
<p>返回 A 中好子数组的数目。</p>
<blockquote>
<p>示例 1：</p>
<p>输出：A = [1,2,1,2,3], K = 2<br>输入：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].<br>示例 2：</p>
<p>输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</p>
</blockquote>
<p>提示：</p>
<blockquote>
<p>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= A.length<br>1 &lt;= K &lt;= A.length</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>方案比较巧妙的办法是：</p>
<p>K个不同整数的子数组 = 用至多K个不同整数的结果 -  至多K-1个不同整数的结果</p>
<blockquote>
<p>以【1，2，3】为例，K=3时候，</p>
<p>至多K个包含:[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]</p>
<p>至多K-1个包含: [1],[2],[3],[1,2],[2,3],[1,3]</p>
<p>做差结果 就是 [1,2,3]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithKDistinct</span><span class="params">(self, A: <span class="string">'List[int]'</span>, K: <span class="string">'int'</span>)</span> -&gt; 'int':</span></span><br><span class="line">        <span class="keyword">return</span> self.subarraysWithAtMostKDistinct(A, K) - </span><br><span class="line">      										self.subarraysWithAtMostKDistinct(A, K<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithAtMostKDistinct</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        lookup = collections.defaultdict(int) <span class="comment"># 字典记录整数情况，为1是表示出现一次，为0表示没有</span></span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:   <span class="comment"># 通过右移来扩展 包含不同整数</span></span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &gt; k: <span class="comment"># 一旦满足k个就进行左移，循环跳出的时候，正好是K个不同整数</span></span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res += r - l </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>还没搞懂</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-6-Z字形变换</title>
    <url>/2019/12/07/Leetcode/leetcode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<blockquote>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<p>L   C   I   R<br>E T O E S I I G<br>E   D   H   N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
</blockquote>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p>string convert(string s, int numRows);</p>
<blockquote>
<p>示例 1:</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”<br>示例 2:</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:</p>
<p>L       D      R<br>E   O E    I  I<br>E C    I H   N<br>T       S      G</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这种题上来就先模拟下这个的生成过程，模拟过程中就能找到一定的规律：</p>
<ul>
<li>先从上下下，再从下向上</li>
<li>总是在 0行或者 n-1行转换反向</li>
<li>不要受Z字形诱导，最后的输出结果就是按行从上到下将字符串拼接</li>
</ul>
<p>举个例子：</p>
<blockquote>
<p>LEETCODEISHIRING </p>
<p>结果是：</p>
<p>L    C      I     R<br>E T O E  S  I  I G<br>E    D     H    N</p>
<p>过程1：</p>
<p>L</p>
<p>E</p>
<p>E</p>
<p>过程2换方向：</p>
<p>LC</p>
<p>ET</p>
<p>E</p>
<p>再换方向：</p>
<p>LC</p>
<p>ETO</p>
<p>ED</p>
<p>依次类推最终结果是：</p>
<p>LCIR<br>ETOESIIG<br>EDHN</p>
<p>最终按行输出就是：</p>
<p>LCIRETOESIIGEDHN</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        direction = <span class="literal">False</span> <span class="comment"># True 为向下，False向上</span></span><br><span class="line">        res = [<span class="string">''</span>]*numRows</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            res[row] += ch <span class="comment"># 字符串直接把字符接到后边</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">0</span> <span class="keyword">or</span> row == numRows<span class="number">-1</span>: <span class="comment"># 看是否需要换方向</span></span><br><span class="line">                direction = <span class="keyword">not</span> direction</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> direction: <span class="comment"># True 为向下，False向上</span></span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row -= <span class="number">1</span></span><br><span class="line">				<span class="comment"># 结果按行拼接起来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-5-最长回文子串</title>
    <url>/2019/12/07/Leetcode/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<blockquote>
<p>示例 1：</p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p>
<p>输入: “cbbd”<br>输出: “bb”</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先判断一个字符串是不是回文字符串，就是看该字符串是否是中心对称的。</p>
<ul>
<li>奇数个时:   aba对称</li>
<li>偶数个时：aa对称</li>
</ul>
<p>现在是从一个字符串中，找出最长的回文字符子串，只需要遍历一遍字符串，假设每个位置都是一个回文子串的中心，然后根据是否是回文串来验证，记录长度最大的回文子串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            oddsres = self.helper(s, i, i)</span><br><span class="line">            evenres = self.helper(s, i, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mx &lt; len(oddsres):</span><br><span class="line">                mx = len(oddsres)</span><br><span class="line">                res = oddsres</span><br><span class="line">            <span class="keyword">if</span> mx &lt; len(evenres):</span><br><span class="line">                mx = len(evenres)</span><br><span class="line">                res = evenres</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, s, i, j)</span>:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">-1</span> <span class="keyword">and</span> j &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                res = s[i:j + <span class="number">1</span>]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># i和j 已经不等了</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>分析：总的遍历为o(N)，两种对称方式的遍历为o(2N)，总的时间复杂度为o(N^2)</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口问题</title>
    <url>/2019/12/07/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B3%BB%E5%88%97%E9%A2%98%E7%BB%84/</url>
    <content><![CDATA[<h2 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a>滑动窗口问题</h2><p>题组：</p>
<ul>
<li>[x] 3.无重复字符的最长子串</li>
<li>[ ] 30.串联所有单词的子串</li>
<li>[x] 76.最小覆盖子串</li>
<li>[ ] 159.至多包含两个不同字符的最长子串</li>
<li>[ ] 209.长度最小的子数组</li>
<li>[ ] 239.滑动窗口最大值</li>
<li>[ ] 567.字符串的排列</li>
<li>[ ] 632.最小区间</li>
<li>[ ] 727.最小窗口子序列</li>
<li>[ ] 992.有k个不同整数的子数组</li>
</ul>
<p>For <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        lookup = collections.defaultdict(int)</span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &lt; r - l:</span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res, r - l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>For <a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank" rel="noopener">159. Longest Substring with At Most Two Distinct Characters</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lookup = collections.defaultdict(int)</span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &gt; <span class="number">2</span>:</span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res, r - l) </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>For <a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">340. Longest Substring with At Most K Distinct Characters</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lookup = collections.defaultdict(int)</span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &gt; k:</span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res, r - l) </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>For <a href="https://leetcode.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener">992. Subarrays with K Different Integers</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithKDistinct</span><span class="params">(self, A: <span class="string">'List[int]'</span>, K: <span class="string">'int'</span>)</span> -&gt; 'int':</span></span><br><span class="line">        <span class="keyword">return</span> self.subarraysWithAtMostKDistinct(A, K) - self.subarraysWithAtMostKDistinct(A, K<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithAtMostKDistinct</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        lookup = collections.defaultdict(int)</span><br><span class="line">        l, r, counter, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lookup[s[r]] == <span class="number">1</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> counter &gt; k:</span><br><span class="line">                lookup[s[l]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lookup[s[l]] == <span class="number">0</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res += r - l </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://mp.weixin.qq.com/s/6YeZUCYj5ft-OGa85sQegw" target="_blank" rel="noopener">五分钟学算法-滑动窗口</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-76-最小覆盖子串</title>
    <url>/2019/12/07/Leetcode/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</p>
<blockquote>
<p> 示例：</p>
<p>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”<br>说明：</p>
<p>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口，基本思想分为两步：</p>
<ul>
<li>滑动窗口右边界，产生可能的解（子串）</li>
<li>再滑动窗口左边界，优化产生的解，让解尽可能小</li>
</ul>
<p>基本套路：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">		window.add(s[right])  <span class="comment"># 右侧不断扩展过程</span></span><br><span class="line">		right+=<span class="number">1</span></span><br><span class="line"> 		...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> 满足条件的解:   <span class="comment"># 直到处理的结果不再满足条件</span></span><br><span class="line">      	left-right 作为结果</span><br><span class="line">    		window.remove(s[left])</span><br><span class="line">        left+=<span class="number">1</span>					<span class="comment"># 满足条件下，左侧不断收缩过程</span></span><br></pre></td></tr></table></figure>
<p>滑动窗口适用解决的问题：</p>
<blockquote>
<p>跟字符串相关的匹配问题，求最优（最长或者最小串）</p>
</blockquote>
<p>对应到本题上，我们要求的最小覆盖子串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        window = defaultdict(int)</span><br><span class="line">        needs = defaultdict(int)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> t:</span><br><span class="line">            needs[ch] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>   <span class="comment"># 左边界</span></span><br><span class="line">        r = <span class="number">0</span>		<span class="comment"># 右边界</span></span><br><span class="line">        match = <span class="number">0</span></span><br><span class="line">        mn = <span class="number">999999999</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):  <span class="comment"># 右边界不断扩，直到结尾</span></span><br><span class="line">            ch = s[r]</span><br><span class="line">            <span class="comment">#右移过程##################################</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> needs:</span><br><span class="line">                window[ch] += <span class="number">1</span>  <span class="comment"># 只记录待匹配字母</span></span><br><span class="line">                <span class="keyword">if</span> window[ch] == needs[ch]:</span><br><span class="line">                    match += <span class="number">1</span>  <span class="comment"># 右移过程记录匹配到的个数</span></span><br><span class="line">            r += <span class="number">1</span>  <span class="comment"># 右移一次</span></span><br><span class="line">            <span class="comment">##########################################</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> match == len(needs):  <span class="comment"># 条件：当前匹配的个数 等于 需求匹配的个数</span></span><br><span class="line">                <span class="keyword">if</span> mn &gt; r - l:  <span class="comment"># 与最优结果比较，更新我们的最优结果</span></span><br><span class="line">                    mn = r - l</span><br><span class="line">                    res = s[l:r]</span><br><span class="line">                <span class="comment">#左移过程##################################</span></span><br><span class="line">                <span class="keyword">if</span> s[l] <span class="keyword">in</span> needs:  <span class="comment"># 左侧是待匹配的字母，进行左移时，进行记录</span></span><br><span class="line">                    window[s[l]] -= <span class="number">1</span> <span class="comment"># </span></span><br><span class="line">                    <span class="keyword">if</span> window[s[l]] &lt; needs[s[l]]:</span><br><span class="line">                        match -= <span class="number">1</span>   <span class="comment"># 这里会打破条件，导致不匹配，说明不能继续左移了，跳出再右移</span></span><br><span class="line">                l += <span class="number">1</span> <span class="comment"># 左移一次</span></span><br><span class="line">                <span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们也能清楚的感受到，用####标注出来的两个部分基本就是我们的左移和右移的过程，不过需要带着这个题的理解进行使用。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-32-最长有效括号</title>
    <url>/2019/12/06/Leetcode/leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<blockquote>
<p>复习要点</p>
</blockquote>
<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:</p>
<p>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="简单粗暴没通过"><a href="#简单粗暴没通过" class="headerlink" title="简单粗暴没通过"></a>简单粗暴没通过</h4><p>上来最简单的肯定是 暴力解法啊，就是罗列所有可能的字符情况，然后逐个判断是否有效。</p>
<p>然后就挂了… 超出时间限制，case中218/230，有一部分通不过。于是想了几个简单的优化方法</p>
<ul>
<li>有效字符串肯定是以’(‘开头，以’)’结尾</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s: 空返回</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> len(s)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">')'</span>:</span><br><span class="line">                    count-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> count == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 枚举的过程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>: <span class="comment"># 优化</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(s)):</span><br><span class="line">                    <span class="keyword">if</span> s[j] == <span class="string">')'</span>:  <span class="comment"># 优化</span></span><br><span class="line">                        <span class="keyword">if</span> valid(s[i:j+<span class="number">1</span>]):</span><br><span class="line">                            l = j-i+<span class="number">1</span></span><br><span class="line">                            mx = max(mx,l)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
<h4 id="最优化想到dp"><a href="#最优化想到dp" class="headerlink" title="最优化想到dp"></a>最优化想到dp</h4><p>首先由于括号匹配的特殊性，最长的有效括号肯定是以’)’结尾的，所以我们只需要dp来统计’)’为尾的情况的最大值。</p>
<p>然后就需要考虑下转移状态，也就是说第i个位置以’)结尾’的最长有效长度怎么计算的问题：</p>
<p>只需要考虑两种情况，即i-1位置是’(‘还是’)’：</p>
<p>当i-1位置为’(‘：</p>
<blockquote>
<p>那么构成 ….()，肯定是在前面的基础上能+2，前面如果都无效那就是0+2，前面如果也有效就是前面的长度+2。这里所说的前面就是 dp[i-2]的结果</p>
</blockquote>
<p>当i-1位置为’)’:</p>
<blockquote>
<p>那么就构成….))，这个怎么计算有效呢？就需要参考dp[i-1]的长度，实际问题就变成了….(有效))，如果前面有效的子串前面还有个’(‘那就可以在前面有效子串的基础上长度+2，<strong>注意</strong>，还需要再加上再前面的有效子串的长度，举个栗子！！！<br>01234567<br>( ) ( (  ) ( ) )，当第7位时，由于第6位是’)’，且第6位已经计算好了结果为dp[6]=4，即从下标3，4，5，6这四个有效长度，此时计算第七位时，会直接用： 当前位置7-前面有效长度4-1=2，此时下标2为’(‘，与7匹配上，所以后边总的有效长度为 4+2，此时！！！ 前面也是有效的括号即dp[1]=2，那么总的结果应该是4+2+2</p>
<p>即dp[7] = dp[6]+2+dp[7-dp[6]-2]</p>
<p>(有空了一定画个图)</p>
</blockquote>
<ul>
<li>以’)’结尾考虑：<ul>
<li>其前一位为’(‘: dp[i] = dp[i-2] + 2</li>
<li>其前一位为’)’ 且 i-dp[i-1] -1 为’(‘：dp[i] = dp[i-1]+2 + dp[i-dp[i-1]-2]</li>
</ul>
</li>
<li>以’(‘结尾不考虑</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>]*len(s)</span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">')'</span>: <span class="comment"># 只需要判断 ')即可'</span></span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    <span class="keyword">if</span> i<span class="number">-2</span> &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[i] = dp[i<span class="number">-2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> s[i<span class="number">-1</span>] == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i-dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>:</span><br><span class="line">                      	<span class="comment"># dp[i-1]+2表示新形成的有效子串长度，dp[i-dp[i-1]-2]表示之前有效子串</span></span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span> + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]</span><br><span class="line">                        </span><br><span class="line">                mx = max(mx,dp[i])</span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
<p>其实最后只要中间过程的最大值，所以不会像一般dp过程，dp数组的最后一个元素才是结果。</p>
<h4 id="更优的解法"><a href="#更优的解法" class="headerlink" title="更优的解法"></a>更优的解法</h4><p>从左向右遍历一次，遇到’(‘，left++，遇到’)’，right++，当left==right时，取max(2*left,max),当right&gt;left，说明字符串无效，令left=right = 0</p>
<p>上述过程再从右向左重复一次，不同之处是，从右向左过程，当left&gt;right时，说明字符串无效，令left=right=0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从左到右</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                mx = max(left*<span class="number">2</span>,mx)</span><br><span class="line">            <span class="keyword">elif</span> right &gt; left:</span><br><span class="line">                left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从右到左</span></span><br><span class="line">        left,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                mx = max(left*<span class="number">2</span>,mx)</span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                left,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-20-有效括号</title>
    <url>/2019/12/06/Leetcode/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: “()”<br>输出: true<br>示例 2:</p>
<p>输入: “()[]{}”<br>输出: true<br>示例 3:</p>
<p>输入: “(]”<br>输出: false<br>示例 4:</p>
<p>输入: “([)]”<br>输出: false<br>示例 5:</p>
<p>输入: “{[]}”<br>输出: true</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先说只有一种类型的括号的话，我们的解决方案（这也是<a href="https://mereder.github.io/2019/11/29/leetcode-22-括号生成/" target="_blank" rel="noopener">Leetcode-22-括号生成</a>题目中的一个步骤）。</p>
<p>如果只有一种括号，我们在遍历字符串的时候，只需要注意两个问题：</p>
<ul>
<li>遍历过程中 左边个数&gt;=右边个数</li>
<li>遍历结束后 左边个数 == 右边个数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(s)</span>:</span></span><br><span class="line">  	count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">      <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">      <span class="keyword">elif</span> i == <span class="string">')'</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">   	<span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>对应这个问题，上述方法就行不通了，因为涉及到三种不同的符号，单考虑一种括号的顺序正确是没用的，还需要考虑到括号之间的交叉，比如:</p>
<blockquote>
<p>{ [ } ]</p>
</blockquote>
<p>单个符号的顺序没有问题，但是总的就是不正确的括号。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n5vtuvdhj30v40h2myu.jpg" alt="Leetcode官方解答"></p>
<p>我们可以看到，如果一整个字符串都是有效的，那么其子字符串肯定也是有效的，那么最小的子问题就是一对相邻括号是匹配的。</p>
<p>那么可以通过删除掉匹配到的括号，逐步将问题解决。具体操作。</p>
<p><strong>（图来自Leetcode官方解答，他们的图画的真的好，就拿过来了）</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n66bcjb7j30ls04ct8u.jpg" alt="image-20191206181715420"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n675t327j30i404m3yp.jpg" alt="image-201912061817155"></p>
<p>这样可以通过栈来解决，匹配到的就出栈，否则就进栈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> a==<span class="string">'('</span> <span class="keyword">and</span> b == <span class="string">')'</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">'['</span> <span class="keyword">and</span> b == <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">'&#123;'</span> <span class="keyword">and</span> b == <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(s[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> match(stack[<span class="number">-1</span>], s[i]):</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-26-删除排序数组中的重复项</title>
    <url>/2019/12/05/Leetcode/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<blockquote>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>说明:</p>
<p> 为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:(引用问题嘛，传值传引用)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>虽然是个easy的题，但是一开始确实没有很好的思路，其实每次做数组的题老是不会灵活的使用指针（也就是数组的下标），每次都是只有依次遍历的指针。没有灵活使用</p>
<p>这个题使用两个指针(i慢，j快)</p>
<ul>
<li>i指针用来指示有效数字（即无重复数）</li>
<li>j指针用来遍历数组所有数，重复就跳过，不重复就赋值到 i+1</li>
</ul>
<p>比较好的是数组是排好序的，所以单次遍历就能把重复数都找出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != nums[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-81-搜索旋转的排序数组II</title>
    <url>/2019/12/05/Leetcode/leetcode-81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</url>
    <content><![CDATA[<h2 id="搜索旋转的排序数组ii"><a href="#搜索旋转的排序数组ii" class="headerlink" title="搜索旋转的排序数组ii"></a>搜索旋转的排序数组ii</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<p>示例 1:</p>
<p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true<br>示例 2:</p>
<p>输入: nums = [2,5,6,0,0,1,2], target = 3<br>输出: false<br>进阶:</p>
<p>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>变数是出现<strong>重复的数</strong>了</p>
<p>原本的思路是：</p>
<ul>
<li><p>如果 mid == target 直接返回</p>
</li>
<li><p>前半部有序（指的是[3,4,5,6,7,0,12]，中间划开前面是[3,4,5,6]有序，后边是[7,0,1,2]不完全有序）</p>
<ul>
<li>target落在有序序列，即left—-mid中，则查找这个范围所以right = mid-1</li>
<li>target落在无序序列，即mid—right中，则left = mid+1</li>
</ul>
</li>
<li>后半部有序（指的是[6,7,0,1,2,3,4,5],中间划开，前面是[6,7,0,1]不完全有序，后边是[2,3,4,5]有序）<ul>
<li>target落在无序序列，即left—-mid中，则查找这个范围所以right = mid-1</li>
<li>target落在有序序列，即mid—right中，则left = mid+1</li>
</ul>
</li>
</ul>
<p>当出现重复的数字，如果不出现在两端还好，没有影响</p>
<p>原本只需要判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:  <span class="comment"># 命中 返回</span></span><br><span class="line">    <span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt;= nums[left]:  <span class="comment"># mid的位置，mid落在前半部还是后半部</span></span><br><span class="line">    <span class="string">'''前半部有序的操作'''</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="string">'''后半部有序的操作'''</span></span><br></pre></td></tr></table></figure>
<p>但是对应有重复数的出现，可能会存在下面的情况，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left == mid == right </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] <span class="keyword">or</span> [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>此时分不清到底是前半部分有序还是后半部分有序，但是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left == mid == right 一定 != target</span><br></pre></td></tr></table></figure>
<p>因为我们先判断了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:  <span class="comment"># 命中 返回</span></span><br><span class="line">		<span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure>
<p>既然左left右right 都不等，我们干脆往中间移动，去掉干扰项即可，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] <span class="number">1</span> <span class="keyword">or</span> <span class="number">5</span> [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>操作之后，问题也就回到了我们熟悉的问题上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 不能确定哪一侧有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == nums[mid] == nums[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 在左侧序列，左侧是有序的</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt;= nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[left]&lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid <span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 在右侧序列，右侧是有序的</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>新聚思（Synnex）</title>
    <url>/2019/12/04/%E9%9D%A2%E7%BB%8F/Synnex/</url>
    <content><![CDATA[<h1 id="synnax实习总结"><a href="#synnax实习总结" class="headerlink" title="synnax实习总结"></a>synnax实习总结</h1><p>问题：</p>
<p>lr 推 还可以</p>
<p>svm推 …</p>
<p>xgboost 推…</p>
<p>编程：</p>
<p>kmeans  </p>
<p>堆排序</p>
<p>鸡蛋落地问题</p>
<p>概率题：  </p>
<p>圆上3点 构成锐角三角形的概率</p>
<p>spark  </p>
<p>完全阵亡</p>
<p>实际业务场景应用问题</p>
<p>文本分类 的全流程</p>
<p><strong>以上问题都是笔试题（是的我在现场笔试了一个小时）</strong></p>
<p>其他一些细节问题</p>
<p>transformer 的问题 每个细节问题 </p>
<p>mutil过程具体怎么操作的  </p>
<p>为啥除以dk</p>
<p>add 和norm 具体操作 为什么 有什么作用</p>
<p>decoder中 的mask Attention 怎么操作的</p>
<p>实习问题：</p>
<p>1.薪资问题  </p>
<p>实习薪资：保密 :smile_cat:</p>
<p>2.团队规模 </p>
<p>400人左右 其中it技术100多人， 算法团队20人这样吧</p>
<p>有transfer北美的机会</p>
<p>3.发展问题</p>
<p>工程师会需要有夜班嘛 对应时差 </p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>京东搜索排序面经-已过</title>
    <url>/2019/12/04/%E9%9D%A2%E7%BB%8F/%E4%BA%AC%E4%B8%9C%E6%90%9C%E7%B4%A2%E6%8E%92%E5%BA%8F%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="京东搜索排序面经"><a href="#京东搜索排序面经" class="headerlink" title="京东搜索排序面经"></a>京东搜索排序面经</h2><h3 id="jd"><a href="#jd" class="headerlink" title="jd"></a>jd</h3><p>招聘岗位：算法实习生（能获得导师许可并保证至少6个月的实习）</p>
<p>工作地点：北辰世纪中心，位于北京朝阳区奥林匹克公园附近</p>
<p>【工作内容】</p>
<ol>
<li>基于京东海量的用户和商家数据，应用机器学习算法，优化搜索排序</li>
</ol>
<p>【任职要求】</p>
<ol>
<li><p>对机器学习、数据挖掘、深度学习等算法领域有研究热情和扎实的基础</p>
</li>
<li><p>计算机、数学及相关专业研究生、博士生</p>
</li>
<li><p>熟悉python、C++与Linux开发 </p>
</li>
<li><p>良好的沟通协调能力，较好的主动性和求知欲</p>
</li>
<li><p>熟悉tensorflow、pytorch、caffe等学习框架优先</p>
</li>
<li><p>熟悉强化学习及相关框架，或对其有强烈兴趣者优先</p>
</li>
</ol>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面：</p>
<p>主要是聊项目经历 说一下项目</p>
<p>基本套路 讲一下项目背景 讲一下项目的基本过程 讲一下其中的亮点  难点 与反思 </p>
<p>其实后边三个是更重要的  </p>
<p><strong>问了神经网络防止过拟合的方法！！！</strong></p>
<blockquote>
<ol>
<li>参数正则化， L1 L2</li>
<li>dropout</li>
<li>early stoping</li>
<li>参数(权值共享)</li>
<li>BatchNormaliaztion</li>
</ol>
</blockquote>
<p>题目一： 从m个数中随机等概率抽取n个数（面试官让我实现random.choice）</p>
<p>题目二：找出一个数组中，超过一半的个数的元素</p>
<p><a href="https://mereder.github.io/2019/12/04/leetcode-169-多数元素/" target="_blank" rel="noopener">Leetcode-169-多数元素</a></p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>主要问我的都是算法点吧…</p>
<p>决策树怎么进行特征选择，信息增益怎么算，信息增益比怎么算</p>
<p>其中着重讲了神经网络的参数更新过程（前向传播，反向传播，要写链式求导）</p>
<p>Xgboost，让我手推一边，能推到哪里就写到哪里，然后讲一下整个表达式中的各个含义</p>
<p>笔试题目：</p>
<p><a href="https://mereder.github.io/2019/11/29/插入排序/" target="_blank" rel="noopener">插入排序</a></p>
<h3 id="三面交叉面"><a href="#三面交叉面" class="headerlink" title="三面交叉面"></a>三面交叉面</h3><p>来的面试官是这边做知识图谱的一位，全程都属于聊天状态。</p>
<p>抛给我的问题都算是思考类型的吧</p>
<p>笔试题目：给出括号的对数，问有多少种不同的排列方式</p>
<p><a href="https://mereder.github.io/2019/11/29/leetcode-22-括号生成" target="_blank" rel="noopener">Leetcode-22-括号生成</a></p>
<h3 id="四面leader"><a href="#四面leader" class="headerlink" title="四面leader"></a>四面leader</h3><p>应该是这个组的老大吧，他说他手下大概20多个人。</p>
<p>老大过来跟我说了下他们这边主要做什么</p>
<p>然后搜索流量占了京东app流量的一半以上，dau6000W，检索条数更是十亿级别吧。</p>
<p>然后说了说自己从nlp转到推荐或者搜索的初衷</p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-169-多数元素</title>
    <url>/2019/12/04/Leetcode/leetcode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="多数元素（超过数组一半的元素）"><a href="#多数元素（超过数组一半的元素）" class="headerlink" title="多数元素（超过数组一半的元素）"></a>多数元素（超过数组一半的元素）</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: [3,2,3]<br>输出: 3<br>示例 2:</p>
<p>输入: [2,2,1,1,1,2,2]<br>输出: 2</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解题方法有很多，最直观的一种就是计数呗，看哪个元素的总数和超过了数组的一半。这种方法就需要考虑用什么来存储计数的结果，当然hash是最好的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        hash=&#123;&#125;</span><br><span class="line">        n=len(nums)</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        max_count=n//<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(nums[i] <span class="keyword">not</span> <span class="keyword">in</span> hash):</span><br><span class="line">                hash[nums[i]]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash[nums[i]]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(hash[nums[i]]&gt;max_count):</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure>
<p>还有一种想法，直接排序，那中间位置的元素肯定是超过数组一半的那个，那这样又涉及到排序算法。最快就是</p>
<p>$nlogn$ 进而想到，其实我们不用完全将数组排好序，只要我们找到中间的那个位置的元素就可以了，如何做到呢？我们知道快排有个良好的特性：每一轮快排结束后，一个元素会被放到最终的位置上，那么我们根据这个特性，只需要找到位于中间位置的那个元素就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">          <span class="comment">#	类似剪枝过程，如果mid不在范围内的一侧就不用去遍历了。</span></span><br><span class="line">            index = self.partition(nums,left,right)</span><br><span class="line">            <span class="keyword">if</span> index == mid:</span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">            <span class="keyword">elif</span> index &lt; mid:</span><br><span class="line">                left = index+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = index<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> nums[mid]</span><br><span class="line">            </span><br><span class="line">		<span class="comment"># 快排基础，用来找一次快排将某个元素确定的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self,nums,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        pivot = nums[right]</span><br><span class="line">        slow = left<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> slow != i:</span><br><span class="line">                    nums[i],nums[slow] = nums[slow],nums[i]</span><br><span class="line">        slow += <span class="number">1</span></span><br><span class="line">        nums[slow],nums[right] = pivot,nums[slow]</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<p><strong>更巧妙的办法</strong>：摩尔投票法</p>
<p>基本思想就是，占大多数的元素个数总和肯定比其他元素总和要高。</p>
<p>count来计数，对于重叠的元素++，对于不同的元素—，当count为0时需要重新选一个值作为计数的基础元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                res = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] == res:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-82-删除排序链表中的重复元素ii</title>
    <url>/2019/12/04/Leetcode/leetcode-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</url>
    <content><![CDATA[<h2 id="删除排序链表中的重复元素ii"><a href="#删除排序链表中的重复元素ii" class="headerlink" title="删除排序链表中的重复元素ii"></a>删除排序链表中的重复元素ii</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5</p>
<p>示例 2:</p>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>相比于easy题目<a href="">Leetcode-83-删除排序链表中的重复元素</a></p>
<p>本题的难度在于不仅仅要删除后边的重复数，连本位置的重复数也要删掉。</p>
<p>所以需要找到所有相同的数，然后进行链表的一次删除操作（排序链表，相同的数在一起，一次删除操作即可）。</p>
<p>简单的地方仍在于给的是排序链表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 哑变量，方便处理头部删除 前一个题不需要是因为头部不会进行删除</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        p = dummy				<span class="comment"># 作为有效链表的尾部，后边只会接上不重复的数</span></span><br><span class="line">        q = dummy.next	<span class="comment"># 重复数的指针，如果有重复则会一直遍历到不重复的数或者None停止</span></span><br><span class="line">        <span class="keyword">while</span> q.next:</span><br><span class="line">            tmp = q.val</span><br><span class="line">            <span class="keyword">if</span> q.next.val == tmp: <span class="comment"># 存在重复情况，进入操作</span></span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> q.val == tmp: <span class="comment"># 不为空并且值重复</span></span><br><span class="line">                    q = q.next</span><br><span class="line">                p.next = q</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> q:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:									<span class="comment"># 前后两个数不重复，则继续向后遍历</span></span><br><span class="line">                p = p.next</span><br><span class="line">                q = q.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-83-删除排序链表中的重复元素</title>
    <url>/2019/12/04/Leetcode/leetcode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>双指针遍历，较为简单</p>
<p>重点是：排序链表，并且删除后还保留了一个基本的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        p = head</span><br><span class="line">        q = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">                p.next = q.next</span><br><span class="line">                q = p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                q = q.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-73-矩阵置0</title>
    <url>/2019/12/04/Leetcode/leetcode-73-%E7%9F%A9%E9%98%B5%E7%BD%AE0/</url>
    <content><![CDATA[<h2 id="矩阵置0"><a href="#矩阵置0" class="headerlink" title="矩阵置0"></a>矩阵置0</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<p>示例 1</p>
<blockquote>
<p>输入:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>输出:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]<br>示例 2:</p>
<p>输入:<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br>输出:<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]<br>进阶:</p>
<p>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。<br>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。<br>你能想出一个常数空间的解决方案吗？</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>限制算法的性能：时间复杂度$O(m*n)$空间复杂度$O(1)$</p>
<p>如果没有任何限制，这个题目其实会很简单，就是遍历，将找到的0所在行列都置为0，那样复杂度绝对不止m*n</p>
<p>当时想到的解法就是，两次遍历，每次的遍历都是m*n，那么最终还是m*n的时间复杂度。</p>
<p>只需要找到的0，将其所在行和所在列标识出来，怎么标识，就是通过矩阵的首行和首列来当我们的存储，把需要置为0的行的首位变为0，首列变为0 ，第二次遍历的时候，只需要遍历第一行将其中为0的所在列都置为0，再遍历第一列，将其中为0的所在行都置为0。</p>
<p>这时又出现一个问题，就是原本首行首列就有的0怎么办？由于只能用常数空间，所以考虑两个变量来标识出来首行首列是否原本就需要都置为0 的。</p>
<p>细节问题：对于矩阵遍历要从1开始，这样起到保护首行首列的作用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        first_row = <span class="literal">False</span></span><br><span class="line">        first_col = <span class="literal">False</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                first_col = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                first_row = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_row:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_col:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>作业帮算法实习生面经——已过</title>
    <url>/2019/12/03/%E9%9D%A2%E7%BB%8F/%E4%BD%9C%E4%B8%9A%E5%B8%AE%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="jd"><a href="#jd" class="headerlink" title="jd"></a>jd</h2><p>投递岗位</p>
<p>1、深入自然语言处理相关的核心技术研究，如对话系统、问答系统、阅读理解等NLP技术；</p>
<p>2、用机器学习/深度学习等技术解决分层模型、点击预估、流失预测等业务问题；</p>
<p>3、负责用户增长中的算法问题，提升约课、到课、转化、回捞等相关转化率；</p>
<p>4、将自然语言技术应用具体业务中，包括智能客服、催到课、用户意图分类等。</p>
<h2 id="一面："><a href="#一面：" class="headerlink" title="一面："></a>一面：</h2><p>写题：</p>
<p>1.旋转数组中找target （腾讯视频NLP二面题目） 面试官指导下磕磕绊绊写出来了，腾讯视频面试时候写出来是因为当时分开完成的，先写了找到断点的地方，然后再找target</p>
<p><a href="https://mereder.github.io/2019/11/18/leetcode-33/" target="_blank" rel="noopener">Leetcode-33-搜索旋转数组</a></p>
<p>2.合并两个有序数组 easy</p>
<p>简单聊了聊项目 对于技术点没有深挖</p>
<h2 id="二面："><a href="#二面：" class="headerlink" title="二面："></a>二面：</h2><p>聊项目（前一段实习在网易的项目） 实现背景 实现策略（数据、算法） 实现结果</p>
<p>没有深挖技术点</p>
<p>思路题：</p>
<p>给了一个问题背景</p>
<p>护林员统计了一片森林的各种树的特征（树的种类啊 树的高度啊 树年龄 等等）</p>
<p>其中有一些数据的树高统计由于人为的失误导致数据异常，问如何检查异常的树高数据</p>
<p>当时的回答，就是离群点检测：</p>
<p>如何检测离群点，我给的方案是，首先可以做回归，比如给定一些基础特征，然后根据特征来预测树高</p>
<p>那么正常的值应该都在回归曲线附近，那么也需要一个超参数来衡量在什么范围内的数据是正常，什么范围外的数据是异常点</p>
<p>其次想到了对于异常点（离群点） 背景就是数据分布属于高斯分布的情况下，那么数据可以根据 </p>
<p>均值 +- n个标准差来做判断</p>
<p>==知识点待补充，如何来分析数据的离群点==</p>
<p>算法题：</p>
<p>给一个矩阵m*N，找从左上角到右下角的路径个数，其中会有一些路径是有障碍的 没有办法走过去。</p>
<p><a href="https://mereder.github.io/2019/12/03/leetcode-63-不同路径II/" target="_blank" rel="noopener">Leetcode-62-不同路径II</a></p>
<p>提问环节：</p>
<p>他们组主要做对话技术部分，之前的都已经搭好了，如果现在过去的话也是做基于分析badcase的解决提高对话的有效转化</p>
<p>聊了下这边的技术主要内容 他们月活大概 1.2亿 </p>
<p>业务的应用场景主要是 约课 和课程转化率</p>
<p>目前主要的操作都是自动化的， ASR 到信息理解 然后输出 语音内容，通过对话来帮助客户完成课程转化或者付费内容的购买。</p>
<p>主要涉及的是对话技术、内容理解、用户拉新 和 约课（课程）转化</p>
<p>最后面完通过hr的交流，大概我当时面的是对话技术组，就是通过推荐那边得到潜在转化客户，然后通过机器人电话对客户进行约课或者付费课的转化。基本都已经搭建完了，他们现在的大部分工作应该是在处理badcase，一些对话结果可能不是很好在做处理。</p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>小米桌面信息流推荐算法面经——已过</title>
    <url>/2019/12/03/%E9%9D%A2%E7%BB%8F/%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="小米桌面信息流推荐算法工程师"><a href="#小米桌面信息流推荐算法工程师" class="headerlink" title="小米桌面信息流推荐算法工程师"></a>小米桌面信息流推荐算法工程师</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>主要聊一下项目 （经典必问问题：项目背景，项目意义指标等，难点，亮点）</p>
<p>全流程推一边 xgboost 完事</p>
<p>写题： 将 一个m*n的矩阵中，有个别的数值为0，将0所在的行和列全都置为0.</p>
<p>基本方法就是 暴力解决， 遍历矩阵的时间复杂度就是O(m*n) 对于一个位置为0，将其行列置为0的时间复杂度是O(m+n)</p>
<p>但是面试官要求，时间复杂度为O(1)，所以需要考虑下</p>
<p>磕磕绊绊吧 最终没有完全写出来但是跟真正的解法已经很接近了</p>
<p>事后补充：<a href="https://mereder.github.io/2019/12/04/leetcode-73-矩阵置0/" target="_blank" rel="noopener">73. 矩阵置零</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        first_row = <span class="literal">False</span></span><br><span class="line">        first_col = <span class="literal">False</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                first_col = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                first_row = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_row:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_col:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>聊下项目</p>
<p>问下transformer 的结构 以及基本的理解</p>
<p>问下lr基本的内容</p>
<p>问下 除了bert这一种预训练词向量外 还有没有了解别的。</p>
<p>（这个地方有必要好好把word2vec、elmo、gpt这些重新学习下）</p>
<p>写题：</p>
<p>链表重复数删除，将一个单链表中，重复的数进行删除。</p>
<p><a href="https://mereder.github.io/2019/12/04/leetcode-82-删除排序链表中的重复元素ii/" target="_blank" rel="noopener">Leetcode-82-删除排序链表中的重复元素ii</a></p>
<p>交流下基本问题：</p>
<p>Dau1800W 桌面信息流 推荐上层在北京这边，内容理解在武汉。他们主要做推荐侧…</p>
<p>其实我个人觉得小米这边对于自己学技术来说这边还是蛮合适的，尤其是晓伟哥跟我说，推荐的技术要比搜索更复杂一些的时候，觉得最后选择京东搜索排序那边可能并不是一个最好的选择吧？….</p>
]]></content>
      <categories>
        <category>实习面试经验</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-3-无重复字符的最长子串</title>
    <url>/2019/12/03/Leetcode/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><strong>滴滴算法工程师（EP组没记错的话  hhh）一面面试题目</strong></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p> 输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p> 输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个破题，前后看了好几遍才理解了最优解法的意义。</p>
<p>这里面主要是利用<strong>滑动窗口</strong>机制，那么还需要使用几个辅助变量来帮助实现这个思想</p>
<blockquote>
<p>d: 是一个字典用来存放&lt;字符,最后一次的位置&gt; 这个一方面 方便我们来查找重复字符 另一方面方便确认两个重复字符直接的距离</p>
<p>start: 是 我们找到的无重复字符串的开始</p>
<p>end：是我们找到的无重复字符串的结尾，同时也是遍历字符串的指针</p>
<p>mx：存储最长无重复字符串的长度</p>
</blockquote>
<p>无重复字符串的长度计算即:$end-start+1$</p>
<p>end是不断再向后走的，我们需要判断的是start应该放在什么位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s[end] <span class="keyword">in</span> d:</span><br><span class="line">  start = max(d[char]+<span class="number">1</span>,start)</span><br></pre></td></tr></table></figure>
<p>start记录无重复子串的开始，char表示当前遍历的字符，d是字典，存放各个字符的最终位置</p>
<ul>
<li><p>查看当前字符是否重复，如果重复再看是否在 无重复串中间：</p>
</li>
<li><p>如果 在 无重复串中间 即 start &lt; d[char] 需要更新无重复字符串的开始位置为 d[char]+1</p>
</li>
<li><p>如果 不在 无重复串中间，即 start &gt; d[char] 那么当前字符不会对我们的无重复字符串产生影响</p>
</li>
<li><p>相当于重新定义了 无重复字符串的开始位置，方便后边计算无重复字符串的长度</p>
</li>
</ul>
<blockquote>
<p>举个例子：</p>
<p>abcdc  当遍历到第二个c时，原本的无重复串为abcd ，此时重复字符c是在重复串中间的，那么需要更新我们的窗口，将start从a的下标调整到前一个c的下标+1</p>
<p>再举个例子</p>
<p>abcdba 接着上一个分析，当经过第二个b之后，无重复子串被置为 cdb，当处理最后一个a时，尽管前面有重复的a但是对于我们的无重复子串是没有影响的，可以直接加上，变成cdba。</p>
<p>每次更新start位置之后，无重复字符串长度为end-start+1，不一定都能得到最长的，所以每次都需要再跟max做个比较</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        d = &#123;&#125;  <span class="comment"># 记录字符以及字符最后一次出现的位置</span></span><br><span class="line">        mx = <span class="number">0</span>  <span class="comment"># 记录最长的长度</span></span><br><span class="line">        start = <span class="number">0</span> <span class="comment"># 记录无重复字符串的开始位置</span></span><br><span class="line">        end = <span class="number">0</span>  <span class="comment"># 记录无重复字符串的结束位置</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; len(s): <span class="comment"># 遍历字符串</span></span><br><span class="line">            char = s[end]  <span class="comment"># 当前字符串</span></span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">in</span> d:</span><br><span class="line">                <span class="comment"># 查看当前字符是否重复，如果重复再看是否在 无重复串中间：</span></span><br><span class="line">                <span class="comment"># 如果 在 无重复串中间 即 start &lt; d[char] 需要更新无重复字符串的开始位置为 d[char]+1</span></span><br><span class="line">                <span class="comment"># 如果 不在 无重复串中间，即 start &gt; d[char] 那么当前字符不会对我们的无重复字符串产生影响</span></span><br><span class="line">                <span class="comment"># 相当于重新定义了 无重复字符串的开始位置，方便后边计算无重复字符串的长度</span></span><br><span class="line">                start = max(d[char]+<span class="number">1</span>,start)</span><br><span class="line">            </span><br><span class="line">            mx = max(mx,end-start+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 更新我的字典中，字符的位置信息</span></span><br><span class="line">            d[char] = end</span><br><span class="line">            end+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
<h4 id="更像滑动窗口套路的解法"><a href="#更像滑动窗口套路的解法" class="headerlink" title="更像滑动窗口套路的解法"></a>更像滑动窗口套路的解法</h4><ul>
<li>右移寻找最长可行解</li>
<li>左移优化解的结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        window = defaultdict(int)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; len(s):</span><br><span class="line">            ch = s[r]  <span class="comment"># 当前遍历到的字符</span></span><br><span class="line">            window[ch] += <span class="number">1</span> <span class="comment"># 窗口内该字符个数+1</span></span><br><span class="line">            r += <span class="number">1</span>		<span class="comment"># 右移一次</span></span><br><span class="line">            length += <span class="number">1</span>  <span class="comment"># 长度+1</span></span><br><span class="line">            <span class="keyword">while</span> window[ch] &gt; <span class="number">1</span>: <span class="comment"># 若不重复，则字符的长度应该为1，若大于1说明重复</span></span><br><span class="line">                window[s[l]] -= <span class="number">1</span> <span class="comment"># 将左侧的移除掉，一直到满足 while 中的条件</span></span><br><span class="line">                l += <span class="number">1</span>						<span class="comment"># 左移一次</span></span><br><span class="line">                length -= <span class="number">1</span>				<span class="comment"># 长度-1</span></span><br><span class="line">            mx = max(mx,length)</span><br><span class="line">        <span class="keyword">return</span> mx</span><br></pre></td></tr></table></figure>
<p>上面length 变量是可以省略的，通过r-l+1来计算得到即可</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p><a href="https://mereder.github.io/2019/12/07/滑动窗口系列题组/" target="_blank" rel="noopener">滑动窗口问题</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-63-不同路径II</title>
    <url>/2019/12/03/Leetcode/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    <content><![CDATA[<h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2><p><strong>作业帮算法实习生二面面试题</strong></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jfbb1hcej30b4053gll.jpg" alt="img"></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<blockquote>
<p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<p>1.向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</p>
<p>2.向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>机器人走路问题，还是用动态规划来解决，最基本的动态规划递归状态是</p>
<script type="math/tex; mode=display">
当前路径数 = 左侧格子路径+上边格子路径 \\
n_{i,j} = n_{i,j-1} + n_{i-1,j} \\
dp[i][j] = dp[i][j-1] + dp[i-1][j]</script><p>这个题有特殊的要求，存在障碍那么就需要对障碍点进行下判断：</p>
<ul>
<li>第一步就是障碍点： 直接返回0</li>
<li>第一列或者第一行存在障碍点 那么后继的都应该为0</li>
<li>其他情况的障碍点 只需要存在就令该位置对应dp为0</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment"># 特殊情况，起始位置就是障碍则为0 否则为1</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># dp空间初始化进行赋值 第一行    </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># dp 空间初始化进行赋值 第一列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 其他情况 需要进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment"># 遇到障碍 dp = 0</span></span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">               	<span class="comment"># 非障碍，根据情况进行dp[i][j]的赋值</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> dp[i<span class="number">-1</span>][j] == <span class="number">0</span> <span class="keyword">and</span> dp[i][j<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i<span class="number">-1</span>][j] == <span class="number">0</span> <span class="keyword">or</span> dp[i][j<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-53-最大子序和</title>
    <url>/2019/12/01/Leetcode/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p>
</blockquote>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>基本方法动态规划，动态规划就是求最值过程，其中每一个元素都面临着两种选择，要还是不要，对应dp过程：</p>
<blockquote>
<p>dp[i] = max(dp[i-1]+nums[i],num[i])</p>
</blockquote>
<p>最终结果是，dp数组中结果最大的那个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        // 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span><br><span class="line">        int result = INT_MIN;</span><br><span class="line">        int numsSize = int(nums.size());</span><br><span class="line">        // dp[i]表示nums中以nums[i]结尾的最大子序和</span><br><span class="line">        vector&lt;int&gt; dp(numsSize);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        result = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            result = max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h4><p>贪心算法就是思考每一步我的选择都是最优的，如果i之前的和为正数，那么可以继续连续和，则加上nums[i]。如果之前的和已经为负数了，那么没有必要继续连续，到i位置，我们重新定义连续和为nums[i]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">                tmp += data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = data</span><br><span class="line">            ans = max(ans,tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>使用更为精妙的分治法来求解</p>
<p>思路就是，求一个数组的最大连续和，可以转化为求左侧数组最大子序列和，求右侧数组最大子序列和，<strong>求跨过分界点的连续子序列</strong>，这样问题就被分治化解了。重点就是如何求跨过分界点的连续子序列和</p>
<p>Ps:这个思路可以了解下，但是解这道题来说，真的是时间空间都不够好</p>
<p>时间复杂度$O(nlogn)$，空间复杂度$O(logn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.helper1(nums,<span class="number">0</span>,n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper1</span><span class="params">(self, nums, left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        </span><br><span class="line">        mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        left_res = self.helper1(nums,left,mid)</span><br><span class="line">        right_res = self.helper1(nums,mid+<span class="number">1</span>,right)</span><br><span class="line">        cross_res = self.helper2(nums,left,mid,right)</span><br><span class="line"></span><br><span class="line">        res = max(left_res,right_res,cross_res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper2</span><span class="params">(self,nums,left,mid,right)</span>:</span></span><br><span class="line">        res_left = -np.inf</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从中间向前</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid,left<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            tmp += nums[i]</span><br><span class="line">            res_left = max(tmp,res_left)</span><br><span class="line"></span><br><span class="line">        res_right = -np.inf</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从中间向后</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid+<span class="number">1</span>,right+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">            tmp += nums[i]</span><br><span class="line">            res_right = max(tmp,res_right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res_left+res_right</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2019/12/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基于分治思想的排序算法，稳定的排序算法，时间复杂度$O(NlogN)$，空间复杂度为$O(N)$（需要一个备份数字来进行存储）。</p>
<p>排序算法的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergreSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment"># 迭代终止条件</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len(nums) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment"># 分治过程 不断划分</span></span><br><span class="line">    left = mergreSort(nums[:mid])</span><br><span class="line">    right = mergreSort(nums[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 核心操作：比较左右两个数组，将比较小的先加入备份数字</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt;= right[r]:</span><br><span class="line">            res.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left):</span><br><span class="line">        res.append(left[l])</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> r &lt; len(right):</span><br><span class="line">        res.append(right[r])</span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a =[<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">    print(a)</span><br><span class="line">    res = mergreSort(a)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>最基础的应用，求逆序对数。</p>
<p>基本思想就是：左边的都是小于右边的，那么逆序对数就是右边的一个对应左边每一个。</p>
<p>在merge过程就可以进行计数</p>
<p>举个例子：</p>
<blockquote>
<p>[1,3,5],[2,4,6]</p>
<p>左侧序列的5可以组成的逆序对有(5,2)(5,4)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-222-完全二叉树的节点个数</title>
    <url>/2019/12/01/Leetcode/leetcode-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h2><p>给出一个完全二叉树，求出该树的节点个数。</p>
<p>说明：</p>
<p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / \  /</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始想法是，计算完全二叉树的节点个数是有技巧的，根据其最后一层的深度以及最后一层的叶子节点个数，是可以计算出完全二叉树的节点个数的。</p>
<blockquote>
<p>若最后一层深度为d，最后一层节点个数为N</p>
<p>$ total = 2^{d-1}-1+N$</p>
</blockquote>
<p>但是想到我都能遍历到叶子节点了，肯定也能遍历叶子节点上面的其他节点了，所以我只需要遍历一遍二叉树，就知道我的树节点个数了-_-！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>
<p>解法简单粗暴：时间复杂度是O(N)，N是叶子节点个数</p>
<p>优化解法</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-117-填充每个节点的下一个右侧节点指针 II</title>
    <url>/2019/12/01/Leetcode/leetcode-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/</url>
    <content><![CDATA[<h2 id="填充每个节点的下一个右侧节点指针ii"><a href="#填充每个节点的下一个右侧节点指针ii" class="headerlink" title="填充每个节点的下一个右侧节点指针ii"></a>填充每个节点的下一个右侧节点指针ii</h2><p>给定一个二叉树</p>
<blockquote>
<p>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}</p>
</blockquote>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：</p>
<blockquote>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>参考题目<a href="https://mereder.github.io/2019/11/27/leetcode-116-填充每个节点的下一个右侧节点指针/" target="_blank" rel="noopener">Leetcode-116-填充每个节点的下一个右侧节点指针</a></p>
<p>自己的解法还是依靠于层次遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            cur -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>,nxt):</span><br><span class="line">                    queue[index<span class="number">-1</span>].next = queue[index]</span><br><span class="line">                cur = nxt</span><br><span class="line">                nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2019/11/29/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>基础排序算法之一，也是基于交换的排序方案</p>
<p>时间复杂度是$O(N^2)$</p>
<p>当然有可以优化的点，就是当一次插入中，没有跟  有序部分最后一个发生交换的话，可以直接退出当前循环了，继续去操作下一个数值</p>
<p>算法实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">        flag = <span class="literal">False</span> <span class="comment"># 优化地方</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">0</span>,<span class="number">-1</span>): <span class="comment"># j=i开始，向j=0 遍历</span></span><br><span class="line">            <span class="keyword">if</span> nums[j<span class="number">-1</span>] &gt; nums[j]:</span><br><span class="line">                nums[j<span class="number">-1</span>],nums[j] = nums[j],nums[j<span class="number">-1</span>]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag: <span class="comment"># 未发生交换</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">    insertSort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-22-括号生成</title>
    <url>/2019/11/29/Leetcode/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p><strong>京东搜索排序实习生面试——三面试题</strong></p>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<blockquote>
<p>[“((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”]</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>面试当时这个题实际上是没有正确的搞出来的，当时的大概思路是，我可以对括号进行全排列（类似字母组合排列的那个），然后对生成的每一次结果进行判断，如果符合括号规则就是正确的，如果不符合就不保留</p>
<p>（当时交叉面，只让我提了下思路，回leetcode惊人的发现这个题的暴力解法就是这样，不过怎样递归生成一个串，确实没有写出来）</p>
<p>面试官提示，这个题是可以通过dfs来解决的。（然并卵…..）</p>
<p>==正题==</p>
<h4 id="方法一-暴力解法"><a href="#方法一-暴力解法" class="headerlink" title="方法一 暴力解法"></a>方法一 暴力解法</h4><p>正如上边说的，我先去考虑如何生成，然后对生成的序列做判断，来判断是否有效，有效就加入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(A = [])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(A) == <span class="number">2</span>*n:</span><br><span class="line">                <span class="keyword">if</span> valid(A):</span><br><span class="line">                    ans.append(<span class="string">""</span>.join(A))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.append(<span class="string">'('</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line">                A.append(<span class="string">')'</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(A)</span>:</span></span><br><span class="line">            bal = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">'('</span>: bal += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: bal -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bal &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> bal == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        generate()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="方法二-深度优先搜索"><a href="#方法二-深度优先搜索" class="headerlink" title="方法二 深度优先搜索"></a>方法二 深度优先搜索</h4><p>看解法里面大家也管这个过程叫回溯，没想明白回溯体现在哪里。</p>
<p>重点来了！！！</p>
<p>leetcode大佬的分析图：<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/" target="_blank" rel="noopener">回溯算法（深度优先遍历）+ 广度优先遍历 + 动态规划</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9fcqtixz8j31hc0u0q9e.jpg" alt="LeetCode 第 22 题：“括号生出”题解配图.png"></p>
<p>对于自己来说，真的是一图胜千言，看了这个图就明白是怎么回事了。</p>
<p>方法一是不断的生成，生成很多个叶子节点，但是大部分都是无效的，但是采用的是”后剪枝“</p>
<p>那我干嘛不在生成的过程中就考虑下合法性呢？ 相当于”预剪枝“</p>
<p>下面解法我觉得巧妙的地方应该是<strong>left和right 两个变量</strong>的利用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        left = n</span><br><span class="line">        right = n</span><br><span class="line">        self.dfs(<span class="string">''</span>,left,right,res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, string, left,right,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right ==<span class="number">0</span>:</span><br><span class="line">            res.append(string)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span>: <span class="comment"># 对于不满足的情况不在进行遍历</span></span><br><span class="line">            self.dfs(string+<span class="string">'('</span>, left<span class="number">-1</span>,right,res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:  <span class="comment"># 对于不满足的情况不在进行遍历</span></span><br><span class="line">            self.dfs(string+<span class="string">')'</span>,left,right<span class="number">-1</span>,res)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-86-分隔链表</title>
    <url>/2019/11/29/Leetcode/leetcode-86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<blockquote>
<p> 示例:</p>
<p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
</blockquote>
<p><strong>链表归并排序的基础模块</strong></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路很简单，设置两个 dummy node 来分别表示 前面 和后面的链表，这样遍历一次head就可以直接得到结果了</p>
<p><strong>采用dummy node这个方法可以很方便的处理链表问题</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        before = ListNode(<span class="number">-1</span>) <span class="comment"># dummy node</span></span><br><span class="line">        after = ListNode(<span class="number">-2</span>)</span><br><span class="line">        p = before</span><br><span class="line">        q = after</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                p.next = head</span><br><span class="line">                p = p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q.next = head</span><br><span class="line">                q = q.next</span><br><span class="line">            </span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        p.next = after.next</span><br><span class="line">        q.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> before.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2019/11/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>先留几个坑，有空回来填：</p>
<ul>
<li>快排的时间复杂度平均为$NlogN$，最差退化为$N^2$</li>
<li>快排是不稳定排序算法，即相同值的前后顺序可能会发生变化</li>
<li>快排的优化是：1.先将数组乱序random.shuffle(in place)  2.枢值的选取随机</li>
</ul>
<p>基本面试最最最基础的问题了</p>
<p>尤其是其中的partition函数，更是很多其他算法题的应用基础</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个跟市面上大多数partition不太一样</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition1</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="comment"># 选一个枢值</span></span><br><span class="line">    pivot = nums[right]</span><br><span class="line">    slow = left - <span class="number">1</span>   <span class="comment"># slow指针用来记录较小元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> slow != i:</span><br><span class="line">                nums[slow],nums[i] = nums[i],nums[slow]</span><br><span class="line">    <span class="comment"># 经过上面的遍历过程，slow指向小于pivot的最后一个，所以还需要将slow++ 才是pivot的位置</span></span><br><span class="line">    slow += <span class="number">1</span></span><br><span class="line">    nums[slow], nums[right] = pivot, nums[slow]</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 市面上的妖艳贱货 hhhhh</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr,left,right)</span>:</span></span><br><span class="line">  pivot = arr[left]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> left &lt; right:</span><br><span class="line">      <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right]&gt;= pivot:</span><br><span class="line">          right -= <span class="number">1</span></span><br><span class="line">      arr[left],arr[right] = arr[right], arr[left]</span><br><span class="line">      <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt; pivot:</span><br><span class="line">          left += <span class="number">1</span></span><br><span class="line">      arr[left],arr[right] = arr[right], arr[left]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt; right:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    index = partition1(nums,left,right)</span><br><span class="line">    quick_sort(nums, left, index<span class="number">-1</span>)</span><br><span class="line">    quick_sort(nums, index+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    quick_sort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">10</span>]</span><br><span class="line">    print(a)</span><br><span class="line">    quickSort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<h3 id="对单链表进行快排"><a href="#对单链表进行快排" class="headerlink" title="对单链表进行快排"></a>对单链表进行快排</h3>]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Naive Bayes</title>
    <url>/2019/11/28/ML/NB/</url>
    <content><![CDATA[<h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>基础知识点：</p>
<ul>
<li><p>为什么叫朴素（特征之间独立）</p>
</li>
<li><p>贝叶斯公式（）</p>
<script type="math/tex; mode=display">
P\left(B_{i} | A\right)=\frac{P\left(B_{i}\right) P\left(A | B_{i}\right)}{\sum_{j=1}^{n} P\left(B_{j}\right) P\left(A | B_{j}\right)}</script></li>
</ul>
<ul>
<li><p>朴素贝叶斯算法的极大似然过程（就是统计做count）</p>
</li>
<li><p>朴素贝叶斯算法的贝叶斯估计（+1平滑，拉普拉斯平滑？）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ML</category>
        <category>算法面试</category>
      </categories>
  </entry>
  <entry>
    <title>Logistic Regression</title>
    <url>/2019/11/28/ML/LR/</url>
    <content><![CDATA[<h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>机器学习最基础的东西，基本上也涵盖了一个机器学习算法的方方面面，可谓麻雀虽小五脏俱全。</p>
<p>对于LR，需要重点掌握：</p>
<ul>
<li>对数几率的含义，以及为什么是逻辑<strong>回归</strong></li>
<li>可以写出逻辑回归的概率分布函数（我的理解就是个分段函数，y取0或y取1）</li>
<li>可以写出逻辑回归的极大似然</li>
<li>损失函数最终的化简结果</li>
<li>梯度下降中的梯度怎么求出来的</li>
</ul>
<h3 id="关于逻辑回归的几个问题"><a href="#关于逻辑回归的几个问题" class="headerlink" title="关于逻辑回归的几个问题"></a>关于逻辑回归的几个问题</h3><ul>
<li><p>为什么使用梯度下降来求最优，为什么不直接用解析解直接得到最优结果就好了呢？</p>
<blockquote>
<p>这个问题归结于解析解的计算问题上：</p>
<p>$\theta = (XX^T)^{-1}X^TY$</p>
<p>如果想一次性计算出参数的最优值，这个计算量是很庞大的，尤其计算机求矩阵的逆的计算量巨大，所以没有办法实现，只能依靠梯度下降这种方法，逐步到达最优</p>
</blockquote>
</li>
<li><p>LR如何来进行过拟合限制，具体怎么操作的，为什么这样就可以达到抑制过拟合</p>
<blockquote>
<p>引入L2正则项</p>
</blockquote>
</li>
<li><p>为什么用极大似然来操作，或者换句话问，为什么要用交叉熵损失，用均方误差不可以吗？</p>
<blockquote>
<p>不可以，我们平时做的都是凸优化，对于分类问题用均方误差，优化函数是非凸的？？</p>
<p>需要按照 均方误差 把 这个 写出来</p>
</blockquote>
</li>
<li><p>LR模型需要归一化嘛？为什么需要归一化，体现在哪里？归一化的类型都有什么？</p>
<blockquote>
<p>LR肯定需要归一化，</p>
<p>为什么需要归一化呢，重点问题出现在进行梯度下降过程，如果两个特征的的特征空间不是一致的，那么梯度下降过程很可能走的是“之字形”（优化的是个椭圆形的，每次优化都是垂直等高线向下），那么不会收敛或者很难收敛，进行特征归一化之后，特征空间都是相同的，那么优化的方向是一致的（优化的等高线是个圆形，垂直圆一直向圆心）</p>
<p>问题是出现在L2正则上，</p>
<p>归一化的类型有：</p>
<p>线性归一化： 这种归一化方法比较适用在数值比较集中的情况。这种方法有个缺陷，如果max和min不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。实际使用中可以用经验常量值来替代max和min。</p>
<script type="math/tex; mode=display">
x^{\prime}=\frac{x-\min (x)}{\max (x)-\min (x)}</script><p>标准差归一化：经过处理的数据符合标准正态分布，即均值为0，标准差为1，其转化函数为：</p>
<script type="math/tex; mode=display">
x^{*}=\frac{x-\mu}{\sigma}</script><p>非线性归一化：</p>
<p>经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括 log、指数，正切等。需要根据数据分布的情况，决定非线性函数的曲线，比如log(V, 2)还是log(V, 10)等。</p>
</blockquote>
</li>
<li><p>LR的特征离散化</p>
<blockquote>
<h4 id="为什么LR把特征离散化后效果更好？离散化的好处有哪些？"><a href="#为什么LR把特征离散化后效果更好？离散化的好处有哪些？" class="headerlink" title="为什么LR把特征离散化后效果更好？离散化的好处有哪些？"></a>为什么LR把特征离散化后效果更好？离散化的好处有哪些？</h4><p>逻辑回归属于广义线性模型，表达能力受限；<br>在工业界，很少直接将连续值作为逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1特征交给逻辑回归模型，这样做的优势有以下几点：</p>
<ol>
<li>逻辑回归属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，能够提升模型表达能力，加大拟合；</li>
<li>离散化后可以进行特征交叉，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力；</li>
<li>特征离散化以后，起到了简化了逻辑回归模型的作用，降低了模型过拟合的风险。</li>
<li>离散特征的增加和减少都很容易，易于模型的快速迭代；</li>
<li>稀疏向量内积乘法运算速度快，计算结果方便存储，容易扩展；</li>
<li>离散化后的特征对异常数据有很强的鲁棒性：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰；</li>
<li>特征离散化后，模型会更稳定，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问；</li>
</ol>
<p>李沐曾经说过：模型是使用离散特征还是连续特征，其实是一个“海量离散特征+简单模型” 同 “少量连续特征+复杂模型”的权衡。既可以离散化用线性模型，也可以用连续特征加深度学习。就看是喜欢折腾特征还是折腾模型了。</p>
</blockquote>
</li>
</ul>
<p>lr 为什么用交叉熵损失 不用均方误差</p>
<p>lr需要做归一化嘛 为什么要做归一化</p>
<p>树模型不需要归一化</p>
<p>为什么lr要用极大似然估计。或者为什么求梯度。直接求解析解不可以嘛</p>
]]></content>
      <categories>
        <category>ML</category>
        <category>算法面试</category>
      </categories>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2019/11/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>几个重要的排序算法中比较常用的或者经常写的</p>
<p>主要过程就是：</p>
<ul>
<li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 大顶推  将最大值往上挪  最小值在叶子节点</span></span><br><span class="line"><span class="comment"># 1. 大顶堆的一次调整过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">headAdjust</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">    <span class="comment"># 函数内的临时变量</span></span><br><span class="line">    root = start</span><br><span class="line">    child = <span class="number">2</span>*root+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> child &lt; end:</span><br><span class="line">        <span class="comment"># 找左右叶子节点中值较大的一个</span></span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt; end <span class="keyword">and</span> nums[child+<span class="number">1</span>] &gt; nums[child]:</span><br><span class="line">            child = child + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若 某一个叶节点值确实 大于根 则进行操作</span></span><br><span class="line">        <span class="keyword">if</span> nums[root] &lt; nums[child]:</span><br><span class="line">            <span class="comment"># 交换 根 和 叶的值</span></span><br><span class="line">            nums[root], nums[child] = nums[child], nums[root]</span><br><span class="line">            <span class="comment"># 调换了叶子节点的值，继续调整以叶子节点为根的分支</span></span><br><span class="line">            root = child</span><br><span class="line">            child = <span class="number">2</span>*root+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># 从第一个非叶子节点开始 从下向上调整树为大顶堆</span></span><br><span class="line">    start = n &gt;&gt; <span class="number">1</span> - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 2. 从下到上建造大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start,<span class="number">-1</span>,<span class="number">-1</span>):   <span class="comment"># 从start 到0</span></span><br><span class="line">        headAdjust(nums,i,n)</span><br><span class="line">    <span class="comment"># 此时已经  调整为大顶堆</span></span><br><span class="line">    <span class="comment"># 3. 堆排序过程：不断将最大值交换到数组尾部，然后再调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        nums[<span class="number">0</span>],nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        headAdjust(nums,<span class="number">0</span>,i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试阶段</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">10</span>]</span><br><span class="line">    print(a)</span><br><span class="line">    heapSort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<h3 id="主要应用场景"><a href="#主要应用场景" class="headerlink" title="主要应用场景"></a>主要应用场景</h3><p>1.面试直接写堆排序的过程</p>
<p>2.海量数据中取最小（或最大 topK问题）</p>
<blockquote>
<p>维护一个k大小的堆，如果堆不满直接加入，若满堆，则根堆内最值比较，选择替换堆内元素 或者 不替换</p>
<p>若不是海量数据取topk， 可以考虑 快排形式</p>
</blockquote>
<p>3.<strong>优先队列</strong>：通过堆来实现的优先队列，可以处理</p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-74-搜索二维矩阵</title>
    <url>/2019/11/28/Leetcode/leetcode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h2><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>示例 1:</p>
<blockquote>
<p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>输出: true</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是个二分查找的过程，重点就是如何将二维矩阵变成我们熟悉的一维数组形式。</p>
<p><strong>重点</strong></p>
<blockquote>
<p>二维矩阵的行标和列标可以完全对应到一维数组的index上</p>
<p>以示例为例：</p>
<p>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]</p>
<p>取数字 10，其row_index = 1, col_index =0</p>
<p>对应到一维数组上就是，row_index<em>n+col_index = 1\</em>n+0 = 4 </p>
</blockquote>
<p>借用官方的一张图</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9e1zgrvrvj30y40aswgy.jpg" alt="image-20191128210209085"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = m*n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">            row = mid//n </span><br><span class="line">            col = mid%n </span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-116-填充每个节点的下一个右侧节点指针</title>
    <url>/2019/11/27/Leetcode/leetcode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h2><p>给定一个<strong>完美</strong>二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9czbm9s44j30vk0d0aby.jpg" alt="image-20191127224430562"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看到示意图的时候，很明显的树的层次遍历嘛。</p>
<p>重点就是在层次遍历的什么阶段把指针都连接上，也就是换到下一层的时候，把队列内的节点都接上</p>
<blockquote>
<p>执行用时 :48 ms, 在所有 python3 提交中击败了100.00%的用户</p>
<p>内存消耗 :13.9 MB, 在所有 python3 提交中击败了97.13%的用户</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            cur -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">                nxt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> index,tree <span class="keyword">in</span> enumerate(queue):</span><br><span class="line">                    <span class="keyword">if</span> index+<span class="number">1</span> == len(queue):</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tree.next = queue[index+<span class="number">1</span>]</span><br><span class="line">                cur = nxt</span><br><span class="line">                nxt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>写完这个还觉得蛮不错，想去写个解法，结果在讨论区看到大神的解法</p>
<p>基本思想就是  给的next指针不仅仅赋值了，而且还利用到了，方便后边问题的解决</p>
<ul>
<li>pre 指针一直是处于每一层的最左侧</li>
<li>cur 指针则依次遍历这一层的节点<ul>
<li>先把cur的左和cur的右链接起来</li>
<li>如果cur的next还有 那么就把cur的右和cur下一个节点的左链接起来</li>
<li>向右移动一次cur</li>
</ul>
</li>
<li>pre向下移动一层</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pre = root</span><br><span class="line">        cur = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pre.left:</span><br><span class="line">            cur = pre</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                cur.left.next = cur.right</span><br><span class="line">                <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.right.next = cur.next.left</span><br><span class="line">                cur = cur.next</span><br><span class="line">            pre = pre.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-106-从后序和前序构建二叉树</title>
    <url>/2019/11/27/Leetcode/leetcode-106-%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="从后序和前序构建二叉树"><a href="#从后序和前序构建二叉树" class="headerlink" title="从后序和前序构建二叉树"></a>从后序和前序构建二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<blockquote>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]</p>
</blockquote>
<p>返回如下的二叉树：<br>        3<br>       / \<br>      9  20<br>         /  \<br>       15   7</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于Python实现起来太简单了（可以利用list的切片特性）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.helper(inorder,postorder)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,inorder,postorder)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(postorder[<span class="number">-1</span>])</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,val <span class="keyword">in</span> enumerate(inorder):</span><br><span class="line">            <span class="keyword">if</span> val == root.val:</span><br><span class="line">                index = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">        root.left = self.helper(inorder[:index],postorder[:index])</span><br><span class="line">        root.right = self.helper(inorder[index+<span class="number">1</span>:],postorder[index:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>树的基本操作</title>
    <url>/2019/11/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="深度优先遍历（dfs）"><a href="#深度优先遍历（dfs）" class="headerlink" title="深度优先遍历（dfs）"></a>深度优先遍历（dfs）</h2><h3 id="前序遍历（递归）"><a href="#前序遍历（递归）" class="headerlink" title="前序遍历（递归）"></a>前序遍历（递归）</h3><h3 id="前序遍历（迭代-stack）"><a href="#前序遍历（迭代-stack）" class="headerlink" title="前序遍历（迭代+stack）"></a>前序遍历（迭代+stack）</h3><h3 id="中序遍历（递归版本）"><a href="#中序遍历（递归版本）" class="headerlink" title="中序遍历（递归版本）"></a>中序遍历（递归版本）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.helper(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,root,result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        self.helper(root.left,result)</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        self.helper(root.right,result)</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历（迭代版本）"><a href="#中序遍历（迭代版本）" class="headerlink" title="中序遍历（迭代版本）"></a>中序遍历（迭代版本）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            </span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            cur = node.right</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-104-二叉树的最大深度</title>
    <url>/2019/11/27/Leetcode/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9corf4apnj30uu0bu0te.jpg" alt="image-20191127163906089"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>树的基础题目，理解树的递归调用，同时该题目还是</p>
<p>leetcode-xxx-平衡二叉树</p>
<p>的基础，平衡二叉树的判定条件主要就是计算左右两个子树的高度差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left = self.maxDepth(root.left)</span><br><span class="line">        right = self.maxDepth(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>最简单的方法是通过递归实现的，</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetode-111-二叉树的最小高度</title>
    <url>/2019/11/27/Leetcode/leetcode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="二叉树的最小高度"><a href="#二叉树的最小高度" class="headerlink" title="二叉树的最小高度"></a>二叉树的最小高度</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9codkqvmmj30vs0ciwf6.jpg" alt="image-20191127162545789"></p>
<p><strong>注意是最小高度，区别于算法题二叉树的高度（指二叉树的最大高度）</strong></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目简单，但是没有写出来，答案error，问题理解的不好</p>
<p>最小的深度：题目限制，只有到叶节点才能计算深度</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9coidktqyj30a207cwel.jpg" alt="image-20191127163024655"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">		<span class="comment">#			1</span></span><br><span class="line">		<span class="comment">#		/</span></span><br><span class="line">		<span class="comment">#	2	</span></span><br><span class="line">		<span class="comment"># 上述这种树，其最小深度为2  而按照下面的写法结果返回为1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">       <span class="keyword">return</span> self.helper(root)</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       </span><br><span class="line">       left = self.helper(root.left)</span><br><span class="line">       right = self.helper(root.right)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> min(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>问题出在：对于一个节点只含有一个子节点，只需要计算一侧就好，如果把为空的另一侧也算进去，这样在该层深度肯定为 1。不符合叶节点才计算长度的要求了</p>
<p>正解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        depth = <span class="number">10000</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            depth = min(self.helper(root.left),depth)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            depth = min(self.helper(root.right),depth)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth+<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-430-扁平化多级双向链表</title>
    <url>/2019/11/27/Leetcode/leetcode-430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="扁平化多级双向链表"><a href="#扁平化多级双向链表" class="headerlink" title="扁平化多级双向链表"></a>扁平化多级双向链表</h2><p>您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9csuhhhhgj30uw0degme.jpg" alt="截屏2019-11-27下午7.00.04"></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9d0viqd2nj31190l5gmo.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9d0vm9n9mj325905lmxs.jpg" alt="img"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跟<a href="https://mereder.github.io/2019/11/26/leetcode-114-二叉树展开为链表/" target="_blank" rel="noopener">Leetcode-114-二叉树展开为链表</a>的整体解决方案是一样的，只不过需要注意下问题是双向链表。</p>
<p>坑：前后节点之间是有前后指针相连的，当对于child节点，其prev节点并没有直接指向父节点<strong>而是None</strong>，进行指针操作的时候注意</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, prev, next, child):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.prev = prev</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.child = child</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.child <span class="keyword">and</span> cur.next:</span><br><span class="line">              	<span class="comment"># 1. 拿出子链表，同时子链的prev连上cur</span></span><br><span class="line">                p = cur.child</span><br><span class="line">                p.prev = cur</span><br><span class="line">                <span class="comment"># 2. 遍历子链表直到尾部</span></span><br><span class="line">                <span class="keyword">while</span> p.next:</span><br><span class="line">                    p = p.next</span><br><span class="line">                <span class="comment"># 3. 将原后续链表接入到子链表尾部</span></span><br><span class="line">                p.next = cur.next</span><br><span class="line">                cur.next.prev = p</span><br><span class="line">                <span class="comment"># 4. 调整子链表成为后续链表 并且child为None</span></span><br><span class="line">                cur.next = cur.child</span><br><span class="line">                cur.child = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 链表最后一个含有子链表，就直接调换下位置即可</span></span><br><span class="line">            <span class="keyword">elif</span> cur.child <span class="keyword">and</span> <span class="keyword">not</span> cur.next:</span><br><span class="line">                cur.next = cur.child</span><br><span class="line">                cur.child.prev = cur <span class="comment"># 因为这个没有导致case 20/22  没完全通过</span></span><br><span class="line">                cur.child = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 链表后移动 一个</span></span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Xgboost 原理分析</title>
    <url>/2019/11/26/ML/xgboost/</url>
    <content><![CDATA[<ul>
<li>学的是什么？<ul>
<li>很多CART树</li>
<li>loss+regulization</li>
</ul>
</li>
<li>怎么学的？<ul>
<li>增量学习，每次只学一棵树，前面树固定</li>
<li>loss怎么写：泰勒展开</li>
<li>正则怎么做：</li>
</ul>
</li>
<li>还有哪些优化：<ul>
<li>shrinkage</li>
<li>列采样</li>
</ul>
</li>
<li>跟其他方法有何异同<ul>
<li>与gbdt的优缺点</li>
<li>与RF有什么优缺点</li>
</ul>
</li>
<li>怎么用<ul>
<li>几个关键参数：树的个数，树深， 叶子节点个数， </li>
</ul>
</li>
</ul>
<h2 id="学的是什么？"><a href="#学的是什么？" class="headerlink" title="学的是什么？"></a>学的是什么？</h2><p>对于任何一个有监督模型来说，都是从一批又标签的数据中进行学习</p>
<h2 id="怎么学"><a href="#怎么学" class="headerlink" title="怎么学"></a>怎么学</h2><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h2 id="与其他方法异同"><a href="#与其他方法异同" class="headerlink" title="与其他方法异同"></a>与其他方法异同</h2><h3 id="XGB与GBDT的区别"><a href="#XGB与GBDT的区别" class="headerlink" title="XGB与GBDT的区别"></a>XGB与GBDT的区别</h3><ul>
<li>传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。</li>
<li>传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。</li>
<li>xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。</li>
<li>Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把eta设置得小一点，然后迭代次数设置得大一点。（补充：传统GBDT的实现也有学习速率）</li>
<li>列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。</li>
</ul>
<p>xgboost 如果对多分类情况 如何增长树</p>
]]></content>
      <categories>
        <category>ML</category>
        <category>算法面试</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-114-将二叉树展开为链表</title>
    <url>/2019/11/26/Leetcode/leetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bkaid387j30vq0r4wft.jpg" alt="题目描述"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如下过程生动的描述了节点的拼接过程</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">//将 <span class="number">1</span> 的左子树插入到右子树的地方</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line">//将原来的右子树接到左子树的最右边节点</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> //将 <span class="number">2</span> 的左子树插入到右子树的地方</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> //将原来的右子树接到左子树的最右边节点</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">作者：windliang (leetcode 用户的分享)</span><br><span class="line">链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-<span class="number">-26</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.left:   </span><br><span class="line">                <span class="comment"># 1. 找到最右点</span></span><br><span class="line">                before = cur.left</span><br><span class="line">                <span class="keyword">while</span> before.right:</span><br><span class="line">                    before = before.right</span><br><span class="line">                <span class="comment"># 2. 右子树插入到嘴有点</span></span><br><span class="line">                before.right = cur.right</span><br><span class="line">                <span class="comment"># 3. 左子树放到右子树位置</span></span><br><span class="line">                cur.right = cur.left</span><br><span class="line">                <span class="comment"># 4. 原左子树置为None</span></span><br><span class="line">                cur.left = <span class="literal">None</span></span><br><span class="line">                <span class="comment"># 5. 继续下一个节点</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.right</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-103-二叉树之字形遍历</title>
    <url>/2019/11/26/Leetcode/leetcode-103-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树锯齿形遍历（之字形）"><a href="#二叉树锯齿形遍历（之字形）" class="headerlink" title="二叉树锯齿形遍历（之字形）"></a>二叉树锯齿形遍历（之字形）</h2><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9big7ti98j30uw0hw0to.jpg" alt="image-20191126161510462"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>trick：</p>
<ul>
<li><p>使用两个栈 一个栈负责左-&gt;右压栈，一个栈负责右-&gt;左压栈</p>
</li>
<li><p>flag来区分对哪个栈进行操作</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        s1 = [] <span class="comment"># 左右压  出栈先右</span></span><br><span class="line">        s2 = [] <span class="comment"># 右左压  出栈先左</span></span><br><span class="line">        tmp = []</span><br><span class="line">        s1.append(root)</span><br><span class="line">        flag =<span class="literal">True</span>  <span class="comment"># 表示flag非空</span></span><br><span class="line">        <span class="keyword">while</span> s1 <span class="keyword">or</span> s2:</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                node = s1.pop()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    s2.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    s2.append(node.right)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> s1:</span><br><span class="line">                    res.append(tmp)</span><br><span class="line">                    tmp = []</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = s2.pop()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    s1.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    s1.append(node.left)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> s2:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    res.append(tmp)</span><br><span class="line">                    tmp = []</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-98-验证二叉搜索树</title>
    <url>/2019/11/26/Leetcode/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>首先二叉搜索树（二叉排序树，二叉查找树）的概念：</p>
<blockquote>
<p>它或者是一棵空树，</p>
<p>或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照概念，只需要递归判定就好了。</p>
<p>如果左节点符合，右节点符合，且根的值也符合 left&lt;root&lt;right，则符合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root, <span class="number">-2</span>**<span class="number">32</span>, <span class="number">2</span>**<span class="number">32</span><span class="number">-1</span>)  <span class="comment"># 这个地方有trick 借用最大最小值来完成</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= left <span class="keyword">or</span> root.val &gt;= right: <span class="comment"># 记得带上等号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.helper(root.left,left,root.val) <span class="keyword">and</span> self.helper(root.right, root.val, right)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-95-不同的二叉搜索树（具体路径）</title>
    <url>/2019/11/26/Leetcode/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/</url>
    <content><![CDATA[<blockquote>
<p>复习要点：</p>
<p>需要给出具体的组合情况: 注意返回的是 List[TreeNode]  不是像示例给的那样需要给出一个 具体list</p>
<p>1.分别以不同的值作为root 进行递归建树</p>
<p>2.然后返回的左右List[TreeNode] 里面进行 组合</p>
</blockquote>
<h2 id="不同的二叉搜索树II"><a href="#不同的二叉搜索树II" class="headerlink" title="不同的二叉搜索树II"></a>不同的二叉搜索树II</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bg9rbsntj30v20nq768.jpg" alt="image-20191126145946420"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没有思路…. 看一下人家是怎么解决的</p>
<p>总的解决是两个部分</p>
<ul>
<li>先构建以i为根的树，构建过程可以依靠递归来实现</li>
<li>再遍历构建好的树，进行左—右的排列组合</li>
</ul>
<p>这样就完成了以i为根的所有可能情况的搜索，然后再按照这样的办法一次遍历1…N.</p>
<p>注意 要求的返回结果是 List[TreeNode]  相当于降低了难度，组装树的过程只需要考虑左右节点就可以了</p>
<p>==不要受题目描述的输出结果影响，实际输出只需要输出根节点就好了，系统内部应该会有一个遍历操作==</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span>    </span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>,n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;right:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]  <span class="comment"># 不可以直接返回None  函数之间返回的都是 []</span></span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 1. 以为i根递归建树</span></span><br><span class="line">            left_tree = self.helper(left,i<span class="number">-1</span>)</span><br><span class="line">            right_tree = self.helper(i+<span class="number">1</span>,right)</span><br><span class="line">						<span class="comment"># 2. 以i为根对左右两侧进行排列组合</span></span><br><span class="line">            <span class="keyword">for</span> l_tree <span class="keyword">in</span> left_tree:</span><br><span class="line">                <span class="keyword">for</span> r_tree <span class="keyword">in</span> right_tree:</span><br><span class="line">                    root = TreeNode(i)</span><br><span class="line">                    root.left = l_tree</span><br><span class="line">                    root.right = r_tree</span><br><span class="line">                    <span class="comment"># 3. 排好的结果加入结果集</span></span><br><span class="line">                    res.append(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 数据形式 [TreeNode1,TreeNode2,....TreeNode...]</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>实习期间的租房体验</title>
    <url>/2019/11/26/%E5%AE%9E%E4%B9%A0%E7%A7%9F%E6%88%BF/</url>
    <content><![CDATA[<h3 id="租房原因"><a href="#租房原因" class="headerlink" title="租房原因"></a>租房原因</h3><p>实习立项，学院要求搬出校区，只能在外边租房住。还好是个码农，可以靠实习工资基本贴补下租房的费用。</p>
<h3 id="租房选择"><a href="#租房选择" class="headerlink" title="租房选择"></a>租房选择</h3><p>其实租房的时候，可选择的空间特别大，条件也特别多，如果漫无目的的去找房子很费时间很费力气，还很费鞋子。所有需要自己优先确定好3个自己最在意的事情，基本上按照这3个标准（就一个标准也行）然后排查一下就可以很快的定位出租房范围，然后价格差不多的情况下，中介靠谱就签了。</p>
<p>我的三个标准：</p>
<ul>
<li>租房最好在公司附近，每天路上的时间一定一定不要超过1小时，半小时最好</li>
<li>合租房间其他卧室正常（最好几室就几个人住）</li>
<li>价格是实习工资的一半，要不就活不下去了</li>
</ul>
<p>第一个条件是比较坚决的，第二三个条件可以波动。</p>
<h3 id="中介"><a href="#中介" class="headerlink" title="中介"></a>中介</h3><p>永丰南那里中润置家还是挺好的，至少我租了6个月的体验还算可以吧</p>
<p>肖家河东西区那边就是合美家还可以，就是收服务费这个事情一定要搞清楚</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode-96-不同的二叉搜索树</title>
    <url>/2019/11/25/Leetcode/leetcode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>复习要点：</p>
<p>只需要计算数目，不用得出具体的数目情况   考虑 dp</p>
<p>dp[i] 所表示 有i个节点时候可以组成的搜索树的种类</p>
<p>dp[i] = dp[j-1]*dp[i-j]   base情况dp[0]=1  dp[1] = 1</p>
<p>以i=5为例： dp[5] = dp[0] <em> dp[4] + dp[1] </em> dp[3] + dp[2] <em> dp[2] + dp[3] </em> dp[1] + dp[4] * dp[0]</p>
</blockquote>
<h1 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9anyc2kikj30iw06st8u.jpg" alt="image-20191125223959254"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则</p>
<script type="math/tex; mode=display">G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)</script><p>当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>$ f(i)=G(i−1)∗G(n−i) $</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9ao389x1kj30ss09oabr.jpg" alt="image-20191125224443905"></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>重点感受下将一个大问题划分为小问题，并且存在较多重复子问题时候考虑dp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 当出现节点个数为0表示None 也算一个节点</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>): <span class="comment"># i相当于 数字总数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>): <span class="comment"># j 相当于每次作为根的数字</span></span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>]*dp[i-j] <span class="comment"># 以j为根，左侧总数*右侧总数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题目：单链表快排</title>
    <url>/2019/11/25/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<h1 id="单链表快排"><a href="#单链表快排" class="headerlink" title="单链表快排"></a>单链表快排</h1><p>微软小冰组实习生面试</p>
<p>给一个单链表，按照快排的思想将单链表进行快速排序</p>
<p>相似题目leetcode 148 排序链表（上面解法使用的是归并排序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单链表的快速排序</span></span><br><span class="line"><span class="comment"># 微软小冰一面笔试题 已挂</span></span><br><span class="line"><span class="comment"># 思考问题复杂了，真正交换的过程不用考虑节点交换，只需要交换节点的值就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要数组，其中的left right 就是链表可以进行遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    pivot = left.val</span><br><span class="line">    p = left  <span class="comment"># 用来返回中间</span></span><br><span class="line">    q = left  <span class="comment"># 用来遍历</span></span><br><span class="line">    <span class="keyword">while</span> q != right:  <span class="comment"># 注意此处的条件</span></span><br><span class="line">        <span class="keyword">if</span> q.val &lt; pivot:</span><br><span class="line">            p = p.next</span><br><span class="line">            <span class="comment"># swap 此处交换是 一个大值 和 一个小值的交换</span></span><br><span class="line">            <span class="keyword">if</span> p != q:</span><br><span class="line">                q.val, p.val = p.val, q.val</span><br><span class="line">        q = q.next</span><br><span class="line">    <span class="comment"># 交换一次  此处是pivot和目标位置的交换，交换后pivot被交换到了最终位置上</span></span><br><span class="line">    left.val, p.val = p.val, pivot</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left == right <span class="keyword">or</span> left.next == right:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    mid = partition(left, right)</span><br><span class="line">    quickSort(left, mid)</span><br><span class="line">    quickSort(mid.next, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    quickSort(head, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printList</span><span class="params">(head)</span>:</span></span><br><span class="line">    tmp = []</span><br><span class="line">    p = head</span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        tmp.append(p.val)</span><br><span class="line">        p = p.next</span><br><span class="line"></span><br><span class="line">    print(tmp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 3 5 2 4 1</span></span><br><span class="line">    head = ListNode(<span class="number">3</span>)</span><br><span class="line">    head.next = ListNode(<span class="number">5</span>)</span><br><span class="line">    head.next.next = ListNode(<span class="number">2</span>)</span><br><span class="line">    head.next.next.next = ListNode(<span class="number">4</span>)</span><br><span class="line">    head.next.next.next.next =ListNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    printList(head)</span><br><span class="line">    sort(head)</span><br><span class="line">    printList(head)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>面试题目</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-94-二叉树中序遍历</title>
    <url>/2019/11/25/Leetcode/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h1><p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3</p>
<p>输出: [1,3,2]</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>1.递归解决很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        self.inorderTraversal(root.left)</span><br><span class="line">        self.res.append(root.val)</span><br><span class="line">        self.inorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
<p>2.迭代方式解决</p>
<p>思路：模拟递归调用，用栈来实现系统的递归调用栈</p>
<p>需要一个栈来记录，需要一个cur来表示当前节点</p>
<ul>
<li>如果栈不空且cur不空 则循环：<ul>
<li>如果cur.left不空，则循环压栈：<ul>
<li>将cur的左边节点压栈</li>
<li>Cur = cur.left</li>
</ul>
</li>
<li>栈顶出栈 且获取该节点的数值</li>
<li>该节点右节点压栈</li>
<li>cur指向当前节点（此时当前节点为上一步节点的右节点）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            </span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            cur = node.right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode/leetcode-1104-二叉树寻路</title>
    <url>/2019/11/25/Leetcode/leetcode-1104-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode-15-三数之和</title>
    <url>/2019/11/25/Leetcode/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>完全异于2Sum的思路</p>
<ul>
<li><p>特殊情况处理None等。。。</p>
</li>
<li><p>首先通过排序使数字基本有序</p>
<blockquote>
<p>预排序，通过预排序方便处理重复的情况，这样相同的数字都在一块，跳过则方便。而且本身是$O(n^3)$的时间复杂度，用一个排序才$O(nlogn)$还是划得来</p>
<p>本题解题思路体现了很重要的一点，当复杂度高于排序的时间复杂度时候，可以通过预排序来降低时间复杂度。毕竟做一次排序的时间复杂度为O(NlogN)，所有数字排序之后，就有了很好的特性<strong>有序</strong>。</p>
</blockquote>
</li>
<li><p>遍历排序后的数组</p>
<ul>
<li>如果num[i] &gt;0 说明其后元素都&gt;0 不会出现相加为0情况 break</li>
<li>如果i&gt;0 and num[i] == num[i-1]，说明当前i为重复情况 ，可考虑跳过</li>
<li>令left = i+1 right = n-1 (相当于左右指针):left&lt;right 循环<ul>
<li>如果三数相加为0 则找到匹配的，加入结果集，并且依次排出（跳过）left(或right)为相似值的情况</li>
<li>如果三数相加&lt;0，说明不够大，则left++</li>
<li>如果三数相加&gt;0，说明太大了，则right—</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><p>预排序$O(nlogn)$，遍历数组的过程是$O(n)$ 双指针遍历$O(n)$，总的来说还是$O(n^2)$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 预排序 很重要</span></span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> : </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            right = len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right]) == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i],nums[left],nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> nums[right] == nums[right<span class="number">-1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span>  <span class="comment"># 这个地方需要注意 要把数移动到下一个不一样的数那里 </span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> (nums[i] + nums[left] + nums[right]) &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-237-删除链表中的节点</title>
    <url>/2019/11/21/Leetcode/leetcode-237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h1><p>普通删除方法是有前一个节点，然后将前一个节点的next指向待删除节点的下一个节点，这样完成了当前节点的删除</p>
<p>问题是</p>
]]></content>
  </entry>
  <entry>
    <title>打家劫舍系列题组(198/213/337)</title>
    <url>/2019/11/21/Leetcode/leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="打家劫舍系列"><a href="#打家劫舍系列" class="headerlink" title="打家劫舍系列"></a>打家劫舍系列</h1><p>这个题可以深刻的领悟到dp过程中的一个思想：就是对于某一个状态，我存在两种选择，要或者不要 </p>
<p>如果要 考虑要的情况，如果不要考虑不要的情况。</p>
<h2 id="Leetcode-198-easy"><a href="#Leetcode-198-easy" class="headerlink" title="Leetcode 198 easy"></a>Leetcode 198 easy</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>示例 2:</p>
<p>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单dp过程，优化方法：只和前后两个状态有关，没必要维护一个数组，考虑两个变量就OK了</p>
<p>基本dp 状态转移方程：</p>
<script type="math/tex; mode=display">
dp[n+1] = max(dp[n-1]+num[n+1],dp[n])</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span>]*n </span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line"><span class="comment">## 优化了存储空间的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  	<span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    		<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      	pre = <span class="number">0</span></span><br><span class="line">      	cur = <span class="number">0</span></span><br><span class="line">      	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        		tmp = cur</span><br><span class="line">        		cur = max(pre+nums[i],cur)</span><br><span class="line">        		pre = tmp</span><br><span class="line">      	<span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
<p>其中max就是来选择两种状态的最大值，其中$dp[n-1]+num[n+1]$就是n+1状态我要的结果，$dp[n]$就是n+1状态我不要的结果，通过max做出选择。</p>
<h2 id="Leetcode-213-medium"><a href="#Leetcode-213-medium" class="headerlink" title="Leetcode 213 medium"></a>Leetcode 213 medium</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着<strong>第一个房屋和最后一个房屋</strong>是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在基础上增加限制条件，实际问题就是两次leetcode-198的基础问题</p>
<p>第一次就是我要开始的节点那么我的序列就是[：-1]</p>
<p>第二次我要某位的节点不要开始的节点序列就是[1:]</p>
<p>对应两个数字序列，依次进行rob过程，最后再取这两个过程的最大值作为结果返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        head = self.helper(nums[:<span class="number">-1</span>])</span><br><span class="line">        tail = self.helper(nums[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(head,tail)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">             <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span>]*n</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-337-medium"><a href="#Leetcode-337-medium" class="headerlink" title="Leetcode 337 medium"></a>Leetcode 337 medium</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>示例 1:</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bfbwcv4ij30uo0c0t9i.jpg" alt="image-20191126142711223"></p>
<p>示例2：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bfe1ylhej30um0c8wfa.jpg" alt="image-20191126142918342"></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p> 2019年5月时候二面 头条实习生的题目，当时没写出来….</p>
</blockquote>
<p>之前的都是一维数组，来选择当前值是要还是不要，这里变成了树，树的好处就是可以通过递归来操作。</p>
<p>这里需要作出的选择是当前的根   是选择要还是不要</p>
<p>直接计算过程依靠递归也是从下到上完成的：即会先计算叶子节点然后逐层向上。</p>
<p>在当前节点时候，选择要或者不要的时候，下面的子节点已经计算好结果了</p>
<p>如果要当前节点的值：$要 = root.val + 左子节点不要 + 右子节点不要$</p>
<p>如果不要当前节点的值：$不要 = max(左要的值，左不要的值)+max(右要的值，右不要的值)$</p>
<p>不要当前节点的意思就是 当前root不要，那么该root可要获取的最大值就是 左最大+右最大</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        res = self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> max(res[<span class="number">0</span>],res[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        res = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># res[0] 表示不要根   res[1] 表示要根</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">				<span class="comment"># 不要根的值</span></span><br><span class="line">        res[<span class="number">0</span>] = max(left[<span class="number">0</span>],left[<span class="number">1</span>])+max(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 要根的值</span></span><br><span class="line">        res[<span class="number">1</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root.val</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>核心就是 res[不要根，要根] 的使用，相当于给每个树节点都有了一个数组，来进行存放不同情况的值</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-62-不同路径</title>
    <url>/2019/11/20/Leetcode/leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga7jzz42kuj30b4053gll.jpg" alt="img"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<p>向右 -&gt; 向右 -&gt; 向下</p>
<p>向右 -&gt; 向下 -&gt; 向右</p>
<p>向下 -&gt; 向右 -&gt; 向右</p>
</blockquote>
<p>示例 2:<br>&gt;</p>
<blockquote>
<p>输入: m = 7, n = 3<br>输出: 28</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>基于dp思想，其实就是对于第i行，第j列的点有多少种方案。</p>
<p>因为移动只能向右或者向下，那么对于i,j点，只能来自于其上或者其左侧点，所以对于i,j点，的路径数:</p>
<script type="math/tex; mode=display">
dp[i][j] = d[i][j-1] + dp[i-1][j]</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-33-搜索旋转排序数组</title>
    <url>/2019/11/18/Leetcode/leetcode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p><strong>腾讯视频NLP实习面试二面算法题</strong></p>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例 1:</p>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4<br>示例 2:</p>
<p>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>刚看到题，想到了剑指offer里面的那个题【旋转数组中的最小数字】，当时的思路是想直接找，但是发现判断条件依赖于 中间那个断开的地方<br>如果找到断开（旋转的地方）就很好解决了<br>所以这个题相当于两步，先找数组中的最小数字，再根据返回的最小数 二分全部 or 二分左 or 二分右</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_rotate_index</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[pivot] &gt; nums[pivot + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> pivot + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> nums[pivot] &lt; nums[left]:</span><br><span class="line">                        right = pivot - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            Binary search</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[pivot] == target:</span><br><span class="line">                    <span class="keyword">return</span> pivot</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; nums[pivot]:</span><br><span class="line">                        right = pivot - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] == target <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        rotate_index = find_rotate_index(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if target is the smallest element</span></span><br><span class="line">        <span class="keyword">if</span> nums[rotate_index] == target:</span><br><span class="line">            <span class="keyword">return</span> rotate_index</span><br><span class="line">        <span class="comment"># if array is not rotated, search in the entire array</span></span><br><span class="line">        <span class="keyword">if</span> rotate_index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> search(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> target &lt; nums[<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># search on the right side</span></span><br><span class="line">            <span class="keyword">return</span> search(rotate_index, n - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># search on the left side</span></span><br><span class="line">        <span class="keyword">return</span> search(<span class="number">0</span>, rotate_index)</span><br></pre></td></tr></table></figure>
<h3 id="更优的解法"><a href="#更优的解法" class="headerlink" title="更优的解法"></a>更优的解法</h3><p>不去找间断点，直接通过情况分类来处理</p>
<ul>
<li>前半部有序（指的是[3,4,5,6,7,0,12]，中间划开前面是[3,4,5,6]有序，后边是[7,0,1,2]不完全有序）<ul>
<li>target落在有序序列，即left—-mid中，则查找这个范围所以right = mid-1</li>
<li>target落在无序序列，即mid—right中，则left = mid+1</li>
</ul>
</li>
<li>后半部有序（指的是[6,7,0,1,2,3,4,5],中间划开，前面是[6,7,0,1]不完全有序，后边是[2,3,4,5]有序）<ul>
<li>target落在无序序列，即left—-mid中，则查找这个范围所以right = mid-1</li>
<li>target落在有序序列，即mid—right中，则left = mid+1</li>
</ul>
</li>
</ul>
<p><strong>策略更像分治</strong>通过将一个旋转数组，划分成了一个有序数组和一个新的旋转数组，那么只需要继续解决这两个问题即可。</p>
<blockquote>
<p>eg: 【6,7,0,1,2,3,4,5】一次划分后：新的旋转数组[6,7,0,1]和一个有序数组[,2,3,4,5]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[left]:  <span class="comment"># 前半部有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]: <span class="comment"># target落在有序序列</span></span><br><span class="line">                    right = mid <span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:																<span class="comment"># target 落在非有序序列</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-1-两数之和</title>
    <url>/2019/11/17/Leetcode/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>python 使用字典来减少遍历时间</p>
<p><strong>关键点</strong></p>
<ul>
<li>往字典存的过程是动态的从前向后的，也就是说 后边的每一次查找，其前面元素都放进字典里面了</li>
<li>也对应了题目要求：不能重复利用这个数组中同样的元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> nums == <span class="literal">None</span> <span class="keyword">or</span> nums == []:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            err = target - value</span><br><span class="line">            <span class="keyword">if</span> err <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> [d[err], index]</span><br><span class="line">            <span class="comment"># 不在就加入字典</span></span><br><span class="line">            d[value] = index</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>日常awk命令汇总</title>
    <url>/2019/11/04/awk/</url>
    <content><![CDATA[<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>适用于文本处理和报表生成（是一种一旦学会了就会成为您的<strong><a href="https://docs.nvidia.com/deeplearning/sdk/cudnn-install/" target="_blank" rel="noopener">战略代码库</a></strong>的重要部分语言:laughing:）</p>
<p>awk处理文件的过程是一行一行读取并处理的，总是先去匹配pattern（模式），如果匹配成功就是执行action。</p>
<p>除了核心模块外还有两个辅助部分，即<code>BEGIN</code>和<code>END</code>模块，这两个部分是在核心处理机制外的，大白话来解释就是：</p>
<blockquote>
<p>先执行BEGIN模块，进行赋值和一些声明，然后进入核心处理模块，即 读取第一行，匹配pattern，然后进行action，然后第二行…第三行…第N行，最后再执行END模块。</p>
</blockquote>
<h3 id="awk的print命令"><a href="#awk的print命令" class="headerlink" title="awk的print命令"></a>awk的print命令</h3><p>普通输出，$0对应整个当前行，或者pritn “”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk '&#123; print $0 &#125;' /etc/passwd</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk -F <span class="string">":"</span> <span class="string">'&#123; print $1 " " $6 &#125;'</span> /etc/passwd</span></span><br><span class="line">这条命令对应，使用":"分割，并取分割后的第一位、第六位。（计数从1开始的）</span><br><span class="line">/etc/passwd 内的内容格式如下，使用:分割后，</span><br><span class="line">mengdi:x:10395:1001::/home/mengdi:/bin/bash</span><br><span class="line">mengdi  x  10395  1001  _  /home/mengdi:/bin/bash</span><br><span class="line">输出第1、6位，输出结果就是 mengdi /home/mengdi:/bin/bash</span><br><span class="line"></span><br><span class="line">解释$0， 上面$1 和 $6对应输出的是第一第六位，如果换成$0，则输出的就是整行文件。</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F <span class="string">":"</span>就是格式化分解，以：为分解符号</span></span><br><span class="line">上面的例子还可以通过格式化进行输出</span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F <span class="string">":"</span> <span class="string">'&#123; print "username: " $1 "\t\tuid:" $3 &#125;'</span> /etc/passwd</span></span><br><span class="line">上面这种输出就是格式化输出，加上自定义字符串以及变量。</span><br></pre></td></tr></table></figure>
<p>-F实际上是设置了FS变量分隔符，也可以通过外部脚步设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    FS=":"</span><br><span class="line">&#125;</span><br><span class="line">&#123;print $1&#125;</span><br></pre></td></tr></table></figure>
<p>awk 也可以像shell一样 编写脚本文件，然后来运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -f progfile     optional list of input files</span><br><span class="line">progfile 就是脚本程序</span><br></pre></td></tr></table></figure>
<h3 id="打印特定字段"><a href="#打印特定字段" class="headerlink" title="打印特定字段"></a>打印特定字段</h3><p>NF 表示字段数量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;print NF, $1, $NF&#125;</span><br><span class="line">会打印每行的字段数量，第一个字段的值，最后一个字段的值</span><br></pre></td></tr></table></figure>
<p><strong>计算和打印字段</strong></p>
<h3 id="按照某列条件筛选"><a href="#按照某列条件筛选" class="headerlink" title="按照某列条件筛选"></a>按照某列条件筛选</h3><p>按照第四列条件进行筛选， 如果第四列的值&lt;100 那么输出 该行全部内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F "\t" '$4&lt;100 &#123;print$0&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="按列合并数据"><a href="#按列合并数据" class="headerlink" title="按列合并数据"></a>按列合并数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'NR==FNR&#123;a[$1]=$0&#125; NR&gt;FNR&#123;print $1" "a[$2]&#125;' file2 file1</span><br></pre></td></tr></table></figure>
<p>应用成功的场景：</p>
<blockquote>
<p>data2_abolo是 从数据库拉回的数据，其数量&lt;原始数据，因为部分从数据库中 拉不到<br>目的就是让两个文件 按照docid 进行合并</p>
</blockquote>
<p>知识点：</p>
<ul>
<li><p>NR表示从最开始运行到现在处理的记录总行数</p>
</li>
<li><p>FNR表示当前文件的当前处理行数</p>
</li>
<li><p>NR==FNR 表示正在读取的是第一个文件，含义就是  当前处理总行数和 当前文件的处理行数相等</p>
</li>
<li><p>a[$1]=$0 表示把第一个文件的一行内容 都放入 数组a中。这个过程可以以一个例子来理解：</p>
<blockquote>
<p>一行内容 为 id+name：1234  xiaoming</p>
<p>那么执行a[$1]=$0 就相当于   a[‘1234’] = xiaoming</p>
<p>与其说是数组，不如说是字典 更加形象</p>
</blockquote>
</li>
<li><p>NR&gt;FNR 则表示 当前处理总行数 &gt; 当前文件行数  （第二个文件了）</p>
</li>
<li><p>执行判断，在读第二个文件时候，如果$1 in a  就是 第二个文件的 第一列的 内容 如果在a这个字典中的话，就输出print $0, a[$1]，即输出第二个文件的全部以及 存在字典a中的所有内容；否则只输出第二个文件的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F"\t" 'NR==FNR&#123;a[$1]=$0;next&#125; NR&gt;FNR&#123;if($1 in a)print $0, a[$1]; else print $0&#125;' data2_abolo  data2&gt; tttt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="按列求和"><a href="#按列求和" class="headerlink" title="按列求和"></a>按列求和</h3><p>场景：统计所有文件的行数的平均数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 统计文件数</span></span><br><span class="line">ls -l |wc |awk '&#123;total = $1&#125;;&#123;print total-1&#125; '</span><br><span class="line">100</span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算总数</span></span><br><span class="line">wc *|awk '&#123;sum += $1&#125;;END &#123;print sum/100&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="按列求平均值"><a href="#按列求平均值" class="headerlink" title="按列求平均值"></a>按列求平均值</h3><p>上面的 场景也可以用一条awk 来实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc *.txt|awk '&#123;sum += $1&#125;;END &#123;print sum/NR&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="改变输入输出分隔符"><a href="#改变输入输出分隔符" class="headerlink" title="改变输入输出分隔符"></a>改变输入输出分隔符</h3><p>FS : 输入字段分隔符，默认空格。</p>
<p>RS : 输入行分隔符，默认\n。</p>
<p>OFS : 输出字段分隔符，默认空格。</p>
<p>ORS : 输出行分隔符，默认\n。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;FS="\n";RS="";ORS=""&#125;&#123;for(x=1;x&lt;=NF;x++)&#123;print $x"\t"&#125; print "\n"&#125;' ./t.txt</span><br></pre></td></tr></table></figure>
<h3 id="按某列数值排序"><a href="#按某列数值排序" class="headerlink" title="按某列数值排序"></a>按某列数值排序</h3><p>（百度信息流一面问题）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;</span><br><span class="line">FS="|"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">ary[$</span><span class="bash">14,NR]=<span class="variable">$0</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">nrw=asorti(ary, newary)</span><br><span class="line">for(i=1;i&lt;=nrw;i++)</span><br><span class="line">print ary[newary[i]]</span><br><span class="line">&#125;' test.log |tail -n 10</span><br></pre></td></tr></table></figure>
<h3 id="将某列删除"><a href="#将某列删除" class="headerlink" title="将某列删除"></a>将某列删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk ‘$5=null;$0’ filename  &gt;</span><br></pre></td></tr></table></figure>
<p>将第5列置为null 也就是删去 保留其他列输出<code>$0</code></p>
<h3 id="给所有行加行号"><a href="#给所有行加行号" class="headerlink" title="给所有行加行号"></a>给所有行加行号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk ‘$0=NR"\t"$0’ filename</span><br></pre></td></tr></table></figure>
<h3 id="输出第N行"><a href="#输出第N行" class="headerlink" title="输出第N行"></a>输出第N行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n +10 file |head -n 1   # +10的意思是从第10行开始</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk 'NR==10' file.txt</span><br></pre></td></tr></table></figure>
<h3 id="查找某个字段"><a href="#查找某个字段" class="headerlink" title="查找某个字段"></a>查找某个字段</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"></span><br><span class="line">awk '/匹配串/ &#123;for(i=1;i&lt;=NF;i++) if($i ~ /字符串/)  print $i i&#125;'  $filename</span><br><span class="line">awk '/匹配串/ &#123;for(i=1;i&lt;=NF;i++) if($i ~ /(字符串1|…|字符串n)/)  print $i i&#125;'    $filename</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br><span class="line">awk '/WEB_TITLE/ &#123;for(i=1;i&lt;=NF;i++) if($i ~ /( 双线 | 单线 )/)  print $i i&#125;' t_config.txt</span><br></pre></td></tr></table></figure>
<p>awk 处理两个件的问题</p>
<p><a href="https://blog.csdn.net/song865850387/article/details/79761287" target="_blank" rel="noopener">https://blog.csdn.net/song865850387/article/details/79761287</a></p>
<p><a href="https://awk.readthedocs.io/en/latest/chapter-one.html" target="_blank" rel="noopener">https://awk.readthedocs.io/en/latest/chapter-one.html</a> 优先</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/shell/awk/awk-1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/shell/awk/awk-1/</a></p>
<p><a href="https://blog.csdn.net/shangboerds/article/details/49427535" target="_blank" rel="noopener">https://blog.csdn.net/shangboerds/article/details/49427535</a></p>
<p>awk 总结 +很多 使用例子</p>
<p><a href="https://www.cnblogs.com/jython/p/5224217.html" target="_blank" rel="noopener">https://www.cnblogs.com/jython/p/5224217.html</a></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
</search>
